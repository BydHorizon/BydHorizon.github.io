<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一轮明月照九洲</title>
  
  <subtitle>长将静趣观天地，自有幽怀契古今</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-20T15:29:08.277Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>我与我周旋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaSE基础 （十一）</title>
    <link href="http://yoursite.com/2020/03/20/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/20/JavaSE基础-（十一）/</id>
    <published>2020-03-20T15:16:57.000Z</published>
    <updated>2020-03-20T15:29:08.277Z</updated>
    
    <content type="html"><![CDATA[<p>包packge（可以理解为是一个文件夹）</p><pre><code>在我们类的第一行会出现package关键字如果package和import同时出现先写package后写importpackage只能有一个import可以有多个</code></pre><p>类的关系<br>    has-a</p><pre><code>包含关系（组合 聚合 关联） 语义从亲密程度来讲不太一样组合---&gt;人的大脑  人和心脏的关系     整体和部分的关系 不可分割 要出现整体出现 要消亡整体消亡整合----&gt;汽车和轮子 电脑和主板     整体和部分的关系 创建时可能是分开的关联----&gt;人有汽车 人有电脑     整体和部分的关系 可以分割后来形成一起从Java程序来描述这样的关系 通过一个类的对象当做另一个类的属性来存储</code></pre><p>ues a &nbsp;&nbsp;&nbsp;&nbsp;(need a ) 依赖关系</p><pre><code>屠夫 杀 猪           可以做一件事情 杀猪           需要一头猪不是整体和部分的关系 某一件事情产生关系临时组合在一起 这件事情一旦做完关系就解散通过在方法中引用另一个类的对象实现</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;包packge（可以理解为是一个文件夹）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在我们类的第一行会出现package关键字
如果package和import同时出现
先写package后写import
package只能有一个import可以有多个&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>html-css-js  （二）</title>
    <link href="http://yoursite.com/2020/03/20/html-css-js-%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/20/html-css-js-（二）/</id>
    <published>2020-03-20T14:19:19.000Z</published>
    <updated>2020-03-20T15:15:27.772Z</updated>
    
    <content type="html"><![CDATA[<p>高级标签 </p><pre><code>空格标签     &amp;nbsp;左尖括号     &amp;lt;   less than右尖括号     &amp;gt;   great than换行        &lt;br&gt;划线        &lt;hr&gt;</code></pre><p>   有序列表   </p><pre><code>  &lt;ol&gt;       &lt;li&gt;苹果&lt;/li&gt;     &lt;li&gt;香蕉&lt;/li&gt;     &lt;li&gt;菠萝&lt;/li&gt;   &lt;/ol&gt;  有序表属性  &lt;ol type =&quot;a&quot;(a,A,1,i,I)  reversed = &quot;reversed&quot;  start = &quot;3&quot;&gt;  //排序可以按a，A，1,罗马小写i，罗马大写 i reversed属性表示倒序 start表示起始顺序                </code></pre><p>   *无序表 </p><pre><code>&lt;ul&gt;   &lt;li&gt;Marvel&lt;/li&gt;   &lt;li&gt;返老还童&lt;/li&gt;   &lt;li&gt;了不起的盖茨比&lt;/li&gt; &lt;/ul&gt;&lt;ul type = &quot;disc&quot; (square circle)&gt;//标签是实心圆 实心方块 空心圆</code></pre><p>   超文本链接 </p><pre><code>&lt;a herf &quot; &quot; &gt;www.baidu.com&lt;/a&gt; //hyperText reference   数字 文字 图片均可以跳转 target在当前页面打开 blank打开新页面  &lt;打电话&gt;  &lt;a herf=&quot;tel:&quot;&gt;  &lt;发邮件&gt;  &lt;a herf=&quot;mailto&quot;&gt;  &lt;协议限定符&gt;  //&lt;a herf=&quot;javascript=while(1）{alert（&quot;让你手欠&quot;）} 你点我试试呀！come on 来呀！&lt;/a&gt;</code></pre><p> 图片标签   </p><pre><code>    &lt;img src=&quot;url&quot;&gt;//可以打开网络url；本地绝对路径；本地相对路径 alt属性图片占位符（图片出错时显示信息）     title属性图片提示符（光标移动到图片显示） </code></pre><p>锚点                   </p><pre><code>anhor（实现置顶）记录位置 </code></pre><p>表单                     </p><pre><code>&lt;form method=&quot;get/post&quot; action=&quot;&quot;&gt;&lt;input type=&quot;text&quot;  name=&quot;username&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;login&quot;&gt;&lt;/form&gt;// 发送数据 需要数据名和数据内容两项  提交检验 pro/Desktop/lesson2.html?username=sunny&amp;password=123123.  md5协议进行加密         123123                     加密后&amp;@#￥&amp;￥&lt;input type =&quot;radio&quot;&gt;单选                     </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;高级标签 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;空格标签     &amp;amp;nbsp;
左尖括号     &amp;amp;lt;   less than
右尖括号     &amp;amp;gt;   great than
换行        &amp;lt;br&amp;gt;
划线        &amp;lt;
      
    
    </summary>
    
      <category term="前端基础" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十）</title>
    <link href="http://yoursite.com/2020/03/19/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/19/JavaSE基础-（十）/</id>
    <published>2020-03-19T15:03:29.000Z</published>
    <updated>2020-03-19T15:58:48.949Z</updated>
    
    <content type="html"><![CDATA[<p>类和类之间的关系</p><p>A is a B 泛化 （继承 实现）</p><p>A has a B 包含 （组合 聚合 关联）</p><p>A use a B 依赖 （依赖）need a </p><p>继承</p><pre><code>1.子类继承父类，通过一个关键字 extends2.子类的对象可以调用父类中的（public protected）属性和方法3.子类可以添加自己的属性和方法4.子类从父类继承过来的方法不能满足子类的需要，可以在子类中重写父类的方法 指内容重写5.每一个类都有一个继承类，如果extrends关键字不写，默认继承Object类6.java中继承是单个存在的（单继承）每一个类都只能有一个继承类（在extrends后面写一个类）目的是让类变得更安全，可以通过传递方式实现多继承的效果，后续还有多实现7.继承在内存中的存储形式8.关于this和super的使用</code></pre><p>   方法重写与重载</p><pre><code>   方法重写override                                 方法重载overload1.   产生两个继承关系的类                          一个类中的一组方法     子类可以写父类的方法2.特征符            final static abstract                          没有要求          父类方法是 final  子类不能重写      父类方法是 static 子类不存在      父类方法是 abstract 子类必须重写3.权限修饰符         子类可以大于等于父类                             没有要求4.返回值          子类可以小于等于父类                             没有要求5.参数             子类父类必须一致                          每一个方法参数必须不一致6.名字            子类父类必须一致                          一个类中的方法名必须一致7.异常                 运行时 编译时    如果父类方法抛出运行时异常：                         没有要求    子类可不予理会    如果父类方法抛出编译时异常：    子类抛出异常的个数和类型都少于等于父类8.方法体   子类方法内容和父类不一致              每个重载方法执行过程不一致</code></pre><p> Object类       </p><pre><code>        Object类是所有类的父类 Object类没有父类        Object方法         1.toString方法 打印输出一个对象变成字符串        public String toString() {    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());}        2.hashcode（）将对象的地址在内存中计算得到一个整数        3.equals（）用来比较两个对象的内容         == 和equals的区别         equals方法是Object类中继承的方法 默认比较地址         ==可以比较基本类型比较（值）也可以用来比较引用类型比较（地址）         如果想要改变规则可以方法重写          public boolean equals(Object obj) {    return (this == obj);}        4.getclass（）   获取对应类的映射        5.wait（）      线程进入挂起等待状态        6.notify（）     唤醒线程        7.notifyAll（）   唤醒所有        8.finalize      权限修饰符 protected在对象被GC回收时默认执行方法 相当于C++析构函数        9.clone（）     权限修饰符 protected为了克隆对象</code></pre><p> this和super的使用  </p><pre><code>1.this和super都是指代词 代替的是对象2.this代替的是当前执行方法时的那个对象 不一定是当前类的  super代替的是当前执行方法时父类的那个对象 空间内部那个3.都能调用一般属性和方法4.可以放在类成员的任一位置（属性，方法，构造，块）5.注意调用一般方法的时候来回调用（写法编译好用）执行可能产生问题 （stack overflow error）6.可调用构造方法（放在构造方法的第一行）7.this和super在构造方法中调用另一个类的构造方法不能出现在第一行8.构造方法之间不能用来互相调用（编译不好用）</code></pre><p>  <img src="/2020/03/19/JavaSE基础-（十）/%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;类和类之间的关系&lt;/p&gt;
&lt;p&gt;A is a B 泛化 （继承 实现）&lt;/p&gt;
&lt;p&gt;A has a B 包含 （组合 聚合 关联）&lt;/p&gt;
&lt;p&gt;A use a B 依赖 （依赖）need a &lt;/p&gt;
&lt;p&gt;继承&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.子类继承父类，通过一个
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>html-css-js  （一）</title>
    <link href="http://yoursite.com/2020/03/19/html-css-js-%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/19/html-css-js-（一）/</id>
    <published>2020-03-19T14:38:00.000Z</published>
    <updated>2020-03-19T15:02:14.840Z</updated>
    
    <content type="html"><![CDATA[<p>HTML 基础标签</p><p>html  （hyper text markup language） 超文本标记语言</p><pre><code>&lt;html lang = &quot;en&quot;&gt;&lt;head&gt;     &lt;meta charset = &quot;utf-8&quot;&gt;     &lt;title&gt; hello！new friend！&lt;/title&gt;&lt;/head&gt;&lt; body&gt;      Life is full of hope!      生活充满希望！&lt;/body&gt;&lt;/html&gt;</code></pre><p>  基础标签</p><pre><code>根标签 &lt;html&gt; &lt;/html&gt;头标签 &lt;head&gt; &lt;/head&gt;   浏览器设置内容标签 &lt;body&gt; &lt;/body&gt;  用户可见属性标签 &lt;meta&gt;       可对关键字赋值标题标签 &lt;title&gt; &lt;/title&gt; 设置浏览器角标段落标签 &lt;p&gt; &lt;/p&gt;字号标签 &lt;h1-6&gt; &lt;h1-6&gt;   由大到小加粗标签 &lt;strong&gt; &lt;/strong&gt;斜体标签 &lt;em&gt; &lt;/em&gt;     斜体中划线标签 &lt;dek&gt; &lt;/del&gt;地址标签 &lt;adress&gt; &lt;/adress&gt;容器标签 &lt;div&gt; &lt;/div&gt;    换行 结构化 分块明确 捆绑操作         &lt;span&gt;&lt;sapn&gt;</code></pre><p> 字符集</p><pre><code>gb2312    只收录简体gbk      包含繁体unicod    万国码utf -8    Unicode transformation format 第八版lang = &quot;en&quot; en表示英语 中文 zh</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HTML 基础标签&lt;/p&gt;
&lt;p&gt;html  （hyper text markup language） 超文本标记语言&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;html lang = &amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
     &amp;lt;meta 
      
    
    </summary>
    
      <category term="前端基础" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （九）</title>
    <link href="http://yoursite.com/2020/03/15/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/15/JavaSE基础-（九）/</id>
    <published>2020-03-15T14:04:33.000Z</published>
    <updated>2020-03-15T14:57:18.907Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象的编程思想"><a href="#面向对象的编程思想" class="headerlink" title="面向对象的编程思想"></a>面向对象的编程思想</h3><p>类——–抽象的  属性（特征）和方法（行为）</p><p>对象—–具体的</p><p>1.描述一个类</p><pre><code>属性权限修饰符  {特征修饰符}  数据类型  属性名字  {=值}方法权限修饰符  {特征修饰符}  返回值类型 方法名字（参数列表）  {抛出异常} {{方法体}}；</code></pre><p>2.创建一个对象          </p><pre><code>new  对象     调用属性   存值/取值对象.方法  调用方法   执行一次  （存储 执行）</code></pre><p>3.类的加载</p><pre><code>对象的创建属性及方法的存储方法的执行方法执行的过程中  参数返回值的传递{基本数据类型  引用数据类型的区别}</code></pre><p>4.方法的重载 overloard</p><pre><code>1.概念：一个类中的一个一组方法  相同的方法名字 不同的参数列表  构成了方法的重载参数的不同体现在  参数的个数 参数的类型 参数的顺序 三个方面2.作用为了便于记忆和调用 使得方法调用的时候更加的灵活3.自己也可以设计方法的重载  调用的时候 先通过方法的名字来定位  名字一致 通过参数列表的数据类型来定位  方法返回值  修饰符 ---- 与方法重载无关4.JDK1.5之后的  新写法 动态参数列表 ...   参数类型固定  参数的个数可以动态  0-n  使用起来类似于数组的使用 length index  int...x    int[][] x  动态参数列表的方法   对应匹配的数组类型的方法不能构成重载（本质上是一样的）  动态参数列表在方法的参数中只能存一份  且放置在参数的末尾 </code></pre><p>5.构造方法 —–做事情</p><pre><code>1.作用：只有一个  构建（构造）当前类的对象2.写法：   权限修饰符  与类名一致的方法名 （参数列表）{抛出异常}{方法体}3.用法  通过new关键字调用4.特点：      （1）每个类都有构造方法：若自己的类中没有定义系统会默认提供一个无参的构造方法，若在类中定义了构造方法，则默认无参的狗造方法被覆盖      （2）构造方法存值方法重载5.每个类都提供一个构造方法  在创建对象的时候想做一些事情可以用构造方法</code></pre><p>6.程序块  （代码块） </p><pre><code>1.作用：跟普通方法一样 做事情的2.写法：可以认为程序块是一个 没有修饰符 没有参数 没有返回值 没有名字的特殊方法{}3.用法：块需要调用才执行 我们自己调用不到（没有名字）每次我们调用构造方法之前系统就会调用一次程序块（让他执行一遍）4.特点：没有什么重载的概念 但可以在类中定义多个程序块5.可以在里面写一些程序 我想要在创建对象之前执行</code></pre><p>7.this关键字的使用</p><pre><code>1.是一个关键字  代替某一个对象 （当前调用属性或方法时的那个对象）2.this 既然指代一个对象  this 可以调用 属性 方法  this 可以调用构造方法  通过this();省略了构造方法的名字（必须与类名一致） 必须放在程序第一行  一般方法不能调用构造方法</code></pre><p>8.Scanner类</p><pre><code>              1.导包               java.util              2.创建对象         Scanner input = new Scanner(System.in);              3.做事情          int value = input.nextInt（）;                                String value = input.nextLine();            --------------------------------------------------------------------------             nextInt（nextFloat nextByte）next nextLine1.读取方式上  大家都以回车符作为结束符号          除了nextLine以外其余方法都不读取回车符2.读取的返回结果来讲    nextInt---&gt;int   nextFloat----float  nextLine---String  next--string            next 方法看到回车或空格都认为结束               输入  abc def  g              输出  abc             nextLine 只认回车是结束符              输入 abc def g              输出 abc def g</code></pre><p>8.利用包装类做string与基本类型的转化问题</p><pre><code>int value = Interger.parseInt(&quot;&quot;);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;面向对象的编程思想&quot;&gt;&lt;a href=&quot;#面向对象的编程思想&quot; class=&quot;headerlink&quot; title=&quot;面向对象的编程思想&quot;&gt;&lt;/a&gt;面向对象的编程思想&lt;/h3&gt;&lt;p&gt;类——–抽象的  属性（特征）和方法（行为）&lt;/p&gt;
&lt;p&gt;对象—–具体的&lt;/p&gt;

      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （八）</title>
    <link href="http://yoursite.com/2020/03/14/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%85%AB%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/14/JavaSE基础-（八）/</id>
    <published>2020-03-14T14:33:53.000Z</published>
    <updated>2020-03-14T15:20:08.371Z</updated>
    
    <content type="html"><![CDATA[<p>转义字符</p><pre><code>\转义字符 将身后的一个字符意思发生转换 转换特殊符号   比如 &quot; &apos; \ 转换几个特殊的字母 比如 \n换行  \r回车 \t制表符</code></pre><p>main方法</p><pre><code>public static void static (String[] args){}public 访问权限修饰符  公有的staric  特征修饰符  静态的 有且只有一份void   关键字   方法执行完没有返回值main()  方法名称  主要的主方法中的参数args参数  可否传递？1.主方法不是我们调用的 JVM虚拟机启动的时候 虚拟机调用的2.主方法里面有args参数 是一个String[]类型 我们可以传递参数进去给JVM</code></pre><p>命名规则和规约</p><p>规则</p><pre><code>字母 数字 符号 中文字母 区分大小写数字 不能开头符号 _$中文 不推荐</code></pre><p>规约</p><pre><code>类名字  首字母大写 两个单词以上 每一个首字母都大写      Test TestOne TestTwo 属性/方法/变量 驼峰式命名规约 首字母小写 两个单词以上 第二个以后的每个首字母大写构造方法  与类名一致 类中唯一的大写字母开头的方法静态常量  全部字母大写 通过 做具体说明 BOOKSTORE ADMIN包名    全部字母小写 java关键字都是小写 注意与关键字不要冲突</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转义字符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\转义字符 将身后的一个字符意思发生转换
 转换特殊符号   比如 &amp;quot; &amp;apos; \
 转换几个特殊的字母 比如 \n换行  \r回车 \t制表符&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;main方法&lt;/p&gt;
&lt;pre&gt;&lt;code
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础  （七）</title>
    <link href="http://yoursite.com/2020/03/13/avaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/13/avaSE基础-（七）/</id>
    <published>2020-03-13T14:12:24.000Z</published>
    <updated>2020-03-13T14:36:43.119Z</updated>
    
    <content type="html"><![CDATA[<p>多维数组</p><p>0.数组的特点</p><pre><code>数组本身是一个引用类型声明时必须指定长度  长度一旦确定就不能再次发生改变</code></pre><p> 1.定义/声明</p><pre><code>里面存储的类型[] 数组名字;int[][]  arry;</code></pre><p> 2.初始化</p><pre><code>静态---有长度 有元素  int[][] arry = {{1,2},{1}.{1.2.3}};动态---只有长度 没有元素（默认值）  int[][] arry = new int[3][2];  arry -----&gt;{{x,x},{x,x},{x,x}}  x默认值是0</code></pre><p> 3.元素访问          </p><pre><code>通过元素在数组中的位置----indexarray[i][j]i控制大数组中 小数组的位置j控制小数组中 元素的位置</code></pre><p> 4.遍历轮循          </p><pre><code>正常for 增强for  嵌套完成</code></pre><p> 5.引用类型在内存中的结构</p><pre><code>二维数组在内存中的存储，逻辑结构不是矩阵而是树int[][] arry = new int[3][2];//3表示有3个小数组int[]//2表示每一个小数组有两个元素//NullPointerException    空指针异常</code></pre><p>6.常见的运行时异常</p><pre><code>1.InputMisMatchException   输入类型不匹配      input.nextInt();      如：输入一个a2.ArrayIndexOutOfBoundsException  数组索引越界  静态初始化 int array[]={10,20};             array[2]  //索引超过边界3.NegativeArraySizeException  数组长度不合法（长度出现负数）  动态初始化 int[] array = new int [-2]4.NullPointerException    空指针异常    引用为null 还拿来使用就不行啦   int[] arry = null;   arry[0] = 10 ;//空元素再来用</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;多维数组&lt;/p&gt;
&lt;p&gt;0.数组的特点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;数组本身是一个引用类型
声明时必须指定长度  长度一旦确定就不能再次发生改变&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 1.定义/声明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;里面存储的类型[] 数组名字;
int[][] 
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （六）</title>
    <link href="http://yoursite.com/2020/03/12/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/12/JavaSE基础-（六）/</id>
    <published>2020-03-12T14:13:00.000Z</published>
    <updated>2020-03-12T15:39:07.081Z</updated>
    
    <content type="html"><![CDATA[<p>数组（容器）</p><pre><code>数组是一组数据类型相同的数据的组合，将这些数据统一管理起来数组本身是一个引用数据类型，但数组内可以存储基本数据类型，也可以存储引用数据类型</code></pre><p>1.数组的定义（声明）  </p><pre><code>数据类型[] 数组名字;    int[] a;    char[] b;    boolean[] c;    string[] m;</code></pre><p>2.数组的（赋值）初始化 </p><pre><code>静态初始化    有长度 有元素    int[] arry = {10,20,30,40,50,60};    int[] arry = new int[] {10,20,30,40,50,60};动态初始化    有长度   没有元素（默认值0）    int[] arry = new int[5] ;    整数默认值-----0    浮点数默认值---0.0    字符型默认值----0--char  97-a 65-A 48-&apos;0&apos;    布尔型默认值----false    引用数据类型默认值----null</code></pre><p>3.数组元素的访问 </p><pre><code>通过元素在数组中的位置来访问存值/取值位置-------&gt;index索引索引是有取值范围    [从0开始------到数组长度减1]如果数组的索引超过了上诉范围会出现了一个运行时的异常ArrayIndexOutOfBoundsException</code></pre><p>4 数组元素的遍历<br>                  通过循环的方式访问数组每一个元素<br>                  for（;;）{</p><pre><code>}JDK1.5版本之后 增加新特性 增强for循环 加强for forEachfor（自定义的变量（接收数组内每一个元素）：遍历的数组arry）{}1.正常的for循环 有三个必要的条件 找到一个元素的位置可以通过index直接访问数组的某一个位置 存值 取值都可以不好在于写法相对比较麻烦2.增强for 有两个条件 用来取值的变量 用来遍历的数组 没有index索引 写法相对容易只能取值 不能存值没有index索引  找不到元素是哪一个</code></pre><p>5.基本数据类型和引用数据类型在内存结构上的区别<br>              所有的变量空间都存储在栈内存<br>              变量空间可以存储基本数据类型  也可以引用数据类型<br>              如果变量空间存储的是一个基本数据类型  存储的是值 一个变量改变 另一个不会改变<br>              如果变量空间存储的是引用数据类型 存储的是引用（地址）一个变量地址改变 另一个跟着改变</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数组（容器）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;数组是一组数据类型相同的数据的组合，将这些数据统一管理起来
数组本身是一个引用数据类型，但数组内可以存储基本数据类型，也可以存储引用数据类型&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;1.数组的定义（声明）  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （五）</title>
    <link href="http://yoursite.com/2020/03/11/avaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/11/avaSE基础-（五）/</id>
    <published>2020-03-11T14:47:00.000Z</published>
    <updated>2020-03-12T15:46:00.760Z</updated>
    
    <content type="html"><![CDATA[<p>java运算符</p><p>   运算符：用来指明操作数的运算方式</p><p>   按照操作数的数目来分类</p><pre><code>单目运算符    a++双目运算符    a+b三目运算符    (a&gt;b)? x : y</code></pre><p>   按运算符的功能来分类</p><pre><code>算数运算符   + - * / %（取余 求模）++（自增） --（自减）int x=1；int y=x++；//++在后 先赋值 再自增（先进行计算 后赋值）     x++//x=x+1//将x变量空间的内容 先取出 从常量区取出1 进行计算 再次存到x中     想要做值交换的时候 会产生一个临时的副本空间（备份）     ++在变量的前面 先自增后备份 ++在变量的后面 先备份后自增 并将副本空间（备份）内的值赋给别人     x=2 y=1例：int a = 1;   for(int i=0;1&lt;100;i++){        a=a++;   }   a=1   //因为赋值的永远是备份空间的1   --------------------------------------------------------------   int m = 1；//210   int n = 2；//321   int sum = m++ + ++n - n-- - --m + n-- - --m；   m=0 n= 1 sum=2   ----------------------------------------------------------------   赋值运算符   = 赋值符号   将=右边的值()   关系运算符（比较）   &gt; &lt; &gt;= &lt;= != ==   逻辑运算符   &amp; | ^ ！ &amp;&amp;短路与 ||   // ^逻辑异或 只要两个表达式结果不同 最终结果就是true   位（bit）运算   &amp;按位与 |按位或 ^按位异或 ~ 按位取反&lt;&lt;按位左移位 &gt;&gt;按位右移位 &gt;&gt;&gt;按位右移（无符号）</code></pre><p> 笔试题</p><p> 1.&amp;和&amp;&amp;的区别</p><pre><code>&amp;可以视为逻辑运算 也可以视为位运算 &amp;&amp;只能当做逻辑运算来用如果两个都当做逻辑运算符来用 区别如下&amp;前后两个条件都是true 最终结果就是true&amp;&amp; 短路与正常情况下&amp;的执行结果一致   当前面条件为flase的时候发生短路最终结果flase</code></pre><p>2.最有效率的方式计算2*8的结果</p><pre><code>   00000001                  2 &lt;&lt; 3相当于2乘以2的3次幂*  00001000                  00000010-------------                00010000 == 1600000010000==16</code></pre><p>3.两个变量 int a = 1； b = 2如果将两个变量的值互换</p><pre><code> int a = 1; int b = 2; 方式一 采用一个中间变量 int c = a;     a = b;      b =c;好处容易理解 值不会出问题 不好在于会产生一个新的存储空间方式二a = a+b;b = a-b;a = a-b;好处省略了一个存储空间，不好在于+值可能产生越界方法三a = a^b;b = a^b;a = a^b;学的就是高难度~</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java运算符&lt;/p&gt;
&lt;p&gt;   运算符：用来指明操作数的运算方式&lt;/p&gt;
&lt;p&gt;   按照操作数的数目来分类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;单目运算符    a++
双目运算符    a+b
三目运算符    (a&amp;gt;b)? x : y&lt;/code&gt;&lt;/pre&gt;&lt;p
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>GIT (一)</title>
    <link href="http://yoursite.com/2020/03/10/GIT%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/10/GIT（一）/</id>
    <published>2020-03-10T11:12:00.000Z</published>
    <updated>2020-03-10T11:48:12.764Z</updated>
    
    <content type="html"><![CDATA[<p>GIt Bash 常用命令</p><p>#change director</p><pre><code>cd</code></pre><p>#make director</p><pre><code>mkdir</code></pre><p>#print working directory </p><pre><code>pwd</code></pre><p>#move </p><pre><code>mv</code></pre><p>#copy                     </p><pre><code>cp</code></pre><p>#remove</p><pre><code>rm</code></pre><p>其他  </p><pre><code>echo 打印echo &apos;hello&apos; 在命令行中打印一个 helloecho &apos;hello&apos; &gt; a.txt 创建一个纯文本文件a把hello打印进去cat a.txt 查看a中的内容cp a.txt b.txt 复制a 到bls 目录ls ..上一级目录mv b.txt ../b.txt 把b移动到上一级文件夹mv a.txt c.txt 重命名rm c.txt  删除c</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;GIt Bash 常用命令&lt;/p&gt;
&lt;p&gt;#change director&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;#make director&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;#print working 
      
    
    </summary>
    
      <category term="GIT" scheme="http://yoursite.com/categories/GIT/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE基础（四）</title>
    <link href="http://yoursite.com/2020/03/09/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/09/JavaSE基础（四）/</id>
    <published>2020-03-09T15:33:00.000Z</published>
    <updated>2020-03-10T11:04:44.665Z</updated>
    
    <content type="html"><![CDATA[<p>内存结构与执行过程</p><p>1.在硬盘上创建一个文件                            Test.java</p><p>2.文件的内容是我们编写的源代码（跟计算机发送的指令）</p><pre><code>public  class Test{         static void main( String[] args ){              byte x;              x=1;        }  }</code></pre><p>3.将Test.java源文件——&gt;编译——&gt;Test.classc</p><p>4.执行——–&gt;内存中执行</p><p><img src="/2020/03/09/JavaSE基础（四）/pasted-0.png" alt="upload successful"><br>常量值</p><pre><code>常量值是在常量缓存区中的常量区只存一份   常量存储的形式不是十进制而是二进制在常量池中整数默认是按照 int型存储如果使用长整型时需要末尾加L告知long d = 2147483648L;浮点型默认为64位double.</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;内存结构与执行过程&lt;/p&gt;
&lt;p&gt;1.在硬盘上创建一个文件                            Test.java&lt;/p&gt;
&lt;p&gt;2.文件的内容是我们编写的源代码（跟计算机发送的指令）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public  class Test{

      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础（三）</title>
    <link href="http://yoursite.com/2020/03/08/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/08/JavaSE基础（三）/</id>
    <published>2020-03-08T15:54:16.000Z</published>
    <updated>2020-03-10T11:06:40.491Z</updated>
    
    <content type="html"><![CDATA[<p>常量</p><pre><code>常量是代表在程序运行过程中，不能再改变的值。</code></pre><p>常量的作用     </p><pre><code>1.固定的值  代表在计算过程中经常用到的值便于程序计算。    如：  圆周率  3.14159262.表示一个含义    如：  up==&gt;1 down==&gt;2</code></pre><p>什么样的值算是常量</p><pre><code>1. 可以认为所有基本类型的值固定不变是常量    如：    3.14   &apos;a&apos;  true2.特殊的常量     如：   “a b c”-----&gt;string        string是一个引用数据类型，它的值很特殊，可以简单视为常量3.自己创建的空间存储一个值让他固定不变    如：   final int up = 1；</code></pre><p>变量</p><pre><code>变量是指程序执行过程中可以改变的量；变量是内存空间（小容器）；变量空间在创建（声明）的时候必须指定数据类型变量空间的名字；变量空间里面只能存储一个内容（值 引用）变量空间的内容可以改变；</code></pre><p>变量如何创建/声明</p><pre><code>数据类型   类型名字；int a；string b；</code></pre><p>创建变量需要注意命名的问题</p><pre><code>命名规则： 字母、数字（不允许作为开头）、符号（英文符号_和$）还有中文（不推荐）命名的规约：              类名字：  首字母大写 如果两个以上单词  所有首字母都大写                     如：SuperPerson            变量名：  首字母小写 如果两个以上单词之后首字母大写                     如： superPerson                     遵循驼峰式命名规约            所有名字需要见名知意，为了增强程序可读性！注意：变量是空间可以只创建东西不存放内容      变量空间创建后是无内容的、空的      空的变量空间是不能拿来使用的</code></pre><p>注释</p><pre><code>1.单行注释     //2.多行注释     /*         */3.文档注释     //*        */</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;常量是代表在程序运行过程中，不能再改变的值。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;常量的作用     &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.固定的值  代表在计算过程中经常用到的值便于程序计算。
    如：  圆周率  3.1415926
2.
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础（二）</title>
    <link href="http://yoursite.com/2020/03/08/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/08/JavaSE基础（二）/</id>
    <published>2020-03-08T15:32:23.000Z</published>
    <updated>2020-03-10T11:06:31.608Z</updated>
    
    <content type="html"><![CDATA[<p>数据类型</p><p> 基本数据类型 （8个）</p><pre><code>整型 byte short int long浮点型 float double字符型 char布尔型 blooean</code></pre><p> 引用数据类型</p><pre><code>数组  []array类    class（抽象类 abstract class）接口  interface  枚举  enum注解  @interface</code></pre><p>   byte 字节型                                                            </p><pre><code>1 byte = 8 bit   00000000   256种组合用第一个bit的位置记录符号 0表示正数 1表示负数数值的范围2的-7次方到二的7次方减1-128~127</code></pre><p>   以上其他整数类型依次乘2</p><pre><code>short  2字节  16bitint    4字节  32bitlong   8字节  64bit</code></pre><p>  浮点型</p><pre><code>float  4字节  32bitdouble 8字节  64bit</code></pre><p>  字符型</p><pre><code>&apos;a&apos; &apos;+&apos; &apos;我&apos; ‘5’英文符号和数字是1字节   采用ASCII  美国信息交换标准代码 由字母 数字 符号组成中文是2字节    unicode编码</code></pre><p>   布尔型</p><pre><code>boolean  1bittrue  false</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据类型&lt;/p&gt;
&lt;p&gt; 基本数据类型 （8个）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;整型 byte short int long
浮点型 float double
字符型 char
布尔型 blooean&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 引用数据类型&lt;/p&gt;
&lt;pre&gt;&lt;cod
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE 基础     (一)</title>
    <link href="http://yoursite.com/2020/03/08/JavaSE-%E5%9F%BA%E7%A1%80-%E4%B8%80/"/>
    <id>http://yoursite.com/2020/03/08/JavaSE-基础-一/</id>
    <published>2020-03-08T14:59:17.000Z</published>
    <updated>2020-03-10T11:06:21.657Z</updated>
    
    <content type="html"><![CDATA[<pre><code>JavaSE基础</code></pre><p> 1996年  正式发布了可以下载的JDK工具包 jdk1.0</p><p> 1999年  发布了第二代平台 简称 java2 细化三个不同的版本；</p><pre><code>标准版  Standard Edition      J2SE企业版  Enterprise Edition    J2EE微型版  Mirco Edition         J2ME</code></pre><p> 2005年  Oracle 公司74亿收购了SUN</p><p>java语言的特点</p><pre><code>跨平台性  平台（操作系统）面向对象简单性  多继承  健壮性（鲁棒性）  垃圾回收  异常机制多线程大数据相关开发</code></pre><p>JVM                               </p><pre><code>Java virtual machine  虚拟机     源文件.java 编译字节码文件.class</code></pre><p>jRE             </p><pre><code>Java Run Environment 运行环境运行别人写的java程序</code></pre><p>JDK</p><pre><code>Java Development kit 开发工具包javac.exe 编译工具   java.exe  执行工具bin文件夹   全都是工具inlcude文件夹  包含了其他语言的程序jre文件夹    包含了运行环境lib文件夹    包含了人家写好的java类src.zip压缩文件夹  源代码</code></pre><p>常用命令</p><pre><code>win(窗口键)+R  输入cmd命令  打开一个dos命令行窗口使用cd 文件夹名 进入 cd ..退出一层文件夹javac test.java  编译一个test文件java test  运行一个test文件其他 win+R 输出  mspaint 打开画图</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;JavaSE基础&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 1996年  正式发布了可以下载的JDK工具包 jdk1.0&lt;/p&gt;
&lt;p&gt; 1999年  发布了第二代平台 简称 java2 细化三个不同的版本；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;标准版  Standard 
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>PTA基础题算法&amp;&amp;心得（7-1---7-12）</title>
    <link href="http://yoursite.com/2020/02/01/PTA%E5%9F%BA%E7%A1%80%E9%A2%98%E7%AE%97%E6%B3%95-%E5%BF%83%E5%BE%97/"/>
    <id>http://yoursite.com/2020/02/01/PTA基础题算法-心得/</id>
    <published>2020-02-01T08:44:00.000Z</published>
    <updated>2020-03-10T11:08:26.766Z</updated>
    
    <content type="html"><![CDATA[<p>#整型变量存储规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int foot=height/30.48;</span><br><span class="line">int inch=(height/30.48-foot)*12;</span><br></pre></td></tr></table></figure><p>对于C而言  整数除浮点数结果是浮点数 但存储在整型变量中会自动将浮点型化为整型，<br>          而其本质还是浮点数。</p><p>#求和  1/1+……..1/n  or  1/1-1/2+1/3……+1/n</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">int i;</span><br><span class="line">double sum=0.0;</span><br><span class="line">int sign=1; </span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for(i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"> sum+=sign*1.0/i;</span><br><span class="line"> sign=-sign;</span><br><span class="line">&#125; </span><br><span class="line">printf(&quot;f(%d)=%f\n&quot;,n,sum);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义变量sum 不给初值直接使用的话 sum的值是随机的；<br>f（%d）=f（%f），n，sum 解决第n 项求和表示；<br>一正一负的交替相加用sign=-sign，sign的初值为-1，乘以原式,也可将sign 设为double型 初值为1.0可替代循环体，sum+=sign/i；</p><p>#整数分解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line"> int x;</span><br><span class="line"> scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line"> int t;</span><br><span class="line"> int mask=1;</span><br><span class="line"> t=x;</span><br><span class="line"> while(t&gt;9)&#123;</span><br><span class="line">      t/=10;</span><br><span class="line">      mask=mask*10;</span><br><span class="line"> &#125;</span><br><span class="line"> printf(&quot;%d\n&quot;,mask);</span><br><span class="line"> do&#123;</span><br><span class="line">  int d=x/mask;</span><br><span class="line">  printf(&quot;%d&quot;,d); </span><br><span class="line">  if(mask&gt;9)&#123;</span><br><span class="line">   printf(&quot; &quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  x%=mask;</span><br><span class="line">  mask/=10;</span><br><span class="line"> &#125;</span><br><span class="line"> while(mask&gt;0);</span><br><span class="line"> printf(&quot;\n&quot;);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mask的值用x的位数确定，因为不能直接消耗x，用辅助变量t存储x，mask循环要少一次10的n-1次方，用t每除10然后，mask*10，直到t大于9；<br>x整除mask确定第一位，然后x再对mask取余求剩下位数，mask在/10；<br>中间空格用mask判断mask&gt;9,每循环一次输出一个空格；</p><p>#最大公约数 辗转相除法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line"> int a,b;</span><br><span class="line"> int t;</span><br><span class="line"> scanf(&quot;%d %d&quot;,&amp;a,&amp;b);</span><br><span class="line"> while(b!=0)</span><br><span class="line"> &#123;</span><br><span class="line">  t=a%b;</span><br><span class="line">  a=b;</span><br><span class="line">  b=t;</span><br><span class="line"> &#125;</span><br><span class="line"> printf(&quot;gcd=%d&quot;,a);</span><br><span class="line"> return 0;</span><br><span class="line">&#125; </span><br><span class="line">辗转相除法：如果b=0，a就是最大公约数；</span><br><span class="line">否则，计算a除以b的余数，让b=a，b=a的余数；</span><br><span class="line">回到第一步；</span><br><span class="line">#求符合条件的整数集</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">int a;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a);</span><br><span class="line">int i,j,k;</span><br><span class="line">int ctn=0;</span><br><span class="line">for(i=a;i&lt;=a+3;i++)&#123;</span><br><span class="line">   for(j=a ;j&lt;=a+3;j++)</span><br><span class="line">        &#123;</span><br><span class="line">         for(k=a;k&lt;=a+3;k++)</span><br><span class="line">         if(i!=j &amp;&amp; i!=k &amp;&amp;j!=k)&#123;</span><br><span class="line">          ctn++;</span><br><span class="line">   printf(&quot;%d%d%d&quot;,i,j,k); </span><br><span class="line">   if(ctn==6)&#123;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    ctn=0;</span><br><span class="line">   &#125;</span><br><span class="line">   else printf(&quot; &quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>格式控制：用计数器ctn 记录不重复的数，每6个数换行用if（ctn==6）输出换行然后ctn归零，以此循环，用else 输出中间的空格；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#整型变量存储规则&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/spa
      
    
    </summary>
    
      <category term="PTA" scheme="http://yoursite.com/categories/PTA/"/>
    
    
  </entry>
  
  <entry>
    <title>union-find</title>
    <link href="http://yoursite.com/2019/08/11/union-find/"/>
    <id>http://yoursite.com/2019/08/11/union-find/</id>
    <published>2019-08-11T03:25:00.000Z</published>
    <updated>2019-08-11T03:44:45.371Z</updated>
    
    <content type="html"><![CDATA[<p>发展一个可用的算法的步骤：<br>把问题模型化<br>找到一个算法去解决它<br>足够快？适合内存？<br>如果不是，想想为什么<br>寻找一个方法去解决这个问题<br>重复直到一切都满意<br>动态连接（Dynamic connectivity）<br>我们假设“被连接”是一个相等的关系：<br>自反：p被p连接<br>对称：如果p被q连接，那么q也被p连接<br>传递：如果p被q连接，q被r连接，那么p被r连接<br>连接集合（Connected components）：每个对象被连接的所以元素</p><p>发现问题：检查两个对象是否都在同一个集合里面<br>连接命令：用连接替换两个对象集合</p><p>联合查找数据类型（Union-find data type）API<br>目标 设计有效的数据结构为联合查找<br>定义一个 UF类<br>对数据初始化<br>给数据添加连接<br>判断数据是否在同一集合内<br>找到p所在的集合<br>确定集合的数量</p><p>动态连接客户端（Dynamic-connectivity client）<br>从标准输入中读取n个对象<br>重复：</p><ul><li>从标准输入中读取整数对</li><li>如果他们未被连接请将他们连接<br>代码<pre><code>public static void main（string[] args）{ int N = StdIn.readInt(); UF uf = new UF(N); while （！stdIn.isEmpty（）） {   int p = stdIn.readInt();   int q = stdIn.readInt();   if (!uf.connected（p，q））   {     uf.union(p,q);     stdOut.prtinln(p+&quot; &quot;+q);   }  }}</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;发展一个可用的算法的步骤：&lt;br&gt;把问题模型化&lt;br&gt;找到一个算法去解决它&lt;br&gt;足够快？适合内存？&lt;br&gt;如果不是，想想为什么&lt;br&gt;寻找一个方法去解决这个问题&lt;br&gt;重复直到一切都满意&lt;br&gt;动态连接（Dynamic connectivity）&lt;br&gt;我们假设“被连接”
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Algorithms, Part I | Coursera by Princeton University</title>
    <link href="http://yoursite.com/2019/08/09/%E2%80%9Ctest-post/"/>
    <id>http://yoursite.com/2019/08/09/“test-post/</id>
    <published>2019-08-09T10:28:07.000Z</published>
    <updated>2019-08-10T01:45:07.061Z</updated>
    
    <content type="html"><![CDATA[<p>ALGORITHMS, PARTS I AND II 概述<br>Algorithm: method for solving a problem<br>Data structure: method to store information<br>       topic              data structure<br>  data types     stack,queue ,bag,union-find,priority queue<br>storting    quicksort,mergesort,heapsort<br>mergesort<br>BST,red-black BST,hash table<br>graphs    BFS,DFS,Prim,Kruskal,dijkstra<br>strings    radix sorts,tries,KMP,regexps,data compression<br>advanced    B-tree,suffix array,maxflow</p><p>why we study algorithms?<br>Their impacts is board and far-reaching.<br>Old roots,new opportunities.<br>To solve problems that could not otherwise be addressed.<br>For intellectual stimulation.<br>To become a proficient programmer.<br>They may unlock the secrets of life and of the universe.<br>For fun and profit.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ALGORITHMS, PARTS I AND II 概述&lt;br&gt;Algorithm: method for solving a problem&lt;br&gt;Data structure: method to store information&lt;br&gt;       topic  
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/07/05/hello-world/"/>
    <id>http://yoursite.com/2019/07/05/hello-world/</id>
    <published>2019-07-05T04:45:49.322Z</published>
    <updated>2019-07-05T04:45:49.323Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
