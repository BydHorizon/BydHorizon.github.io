<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="一轮明月照九洲" type="application/atom+xml">






<meta property="og:type" content="website">
<meta property="og:title" content="一轮明月照九洲">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="一轮明月照九洲">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一轮明月照九洲">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>一轮明月照九洲</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    <a href="https://github.com/BydHorizon" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">一轮明月照九洲</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">长将静趣观天地，自有幽怀契古今</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/30/avaSE基础-（三十五）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我与我周旋">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一轮明月照九洲">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/30/avaSE基础-（三十五）/" itemprop="url">JavaSE基础  （三十五）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-30T20:20:01+08:00">
                2020-03-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>软件架构CS／BS</li>
<li>网络通信三要素</li>
<li>TCP通信</li>
<li>Socket套接字</li>
<li>ServerSocket</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled type="checkbox"> 能够辨别UDP和TCP协议特点</li>
<li><input disabled type="checkbox"> 能够说出TCP协议下两个常用类名称</li>
<li><input disabled type="checkbox"> 能够编写TCP协议下字符串数据传输程序</li>
<li><input disabled type="checkbox"> 能够理解TCP协议下文件上传案例</li>
<li><input disabled type="checkbox"> 能够理解TCP协议下案例2</li>
</ul>
<h1 id="第一章-网络编程入门"><a href="#第一章-网络编程入门" class="headerlink" title="第一章 网络编程入门"></a>第一章 网络编程入门</h1><h2 id="1-1软件结构"><a href="#1-1软件结构" class="headerlink" title="1.1软件结构"></a>1.1软件结构</h2><ul>
<li><strong>C/S结构</strong> ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。</li>
</ul>
<p><img src="/2020/03/30/avaSE基础-（三十五）/1_cs.jpg" alt></p>
<p><strong>B/S结构</strong> ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</p>
<p><img src="/2020/03/30/avaSE基础-（三十五）/2_bs.jpg" alt></p>
<p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p>
<h2 id="1-2-网络通信协议"><a href="#1-2-网络通信协议" class="headerlink" title="1.2 网络通信协议"></a>1.2 网络通信协议</h2><ul>
<li><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</li>
</ul>
<ul>
<li><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</li>
</ul>
<p><img src="/2020/03/30/avaSE基础-（三十五）/3_tcp_ip.jpg" alt></p>
<p>上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</p>
<h2 id="1-3-协议分类"><a href="#1-3-协议分类" class="headerlink" title="1.3 协议分类"></a>1.3 协议分类</h2><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p>
<p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p>
<ul>
<li><p><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p>
<p>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p>
<p>但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。</p>
</li>
</ul>
<p><img src="/2020/03/30/avaSE基础-（三十五）/img%5CUDP%E9%80%9A%E4%BF%A1%E5%9B%BE%E8%A7%A3.bmp" alt="UDP通信图解"></p>
<p>特点:数据被限制在64kb以内，超出这个范围就不能发送了。</p>
<p>数据报(Datagram):网络传输的基本单位 </p>
<ul>
<li><p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p>
<p>在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p>
<ul>
<li>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。<ul>
<li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。</li>
<li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。</li>
<li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2020/03/30/avaSE基础-（三十五）/4_tcp.jpg" alt></p>
<p>​    完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p>
<h2 id="1-4-网络编程三要素"><a href="#1-4-网络编程三要素" class="headerlink" title="1.4 网络编程三要素"></a>1.4 网络编程三要素</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul>
<li><strong>协议：</strong>计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。</li>
</ul>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul>
<li><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</li>
</ul>
<p><strong>IP地址分类</strong></p>
<ul>
<li><p>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p>
</li>
<li><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。</p>
<p>为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p>
</li>
</ul>
<p><strong>常用命令</strong></p>
<ul>
<li>查看本机IP地址，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure>

<ul>
<li>检查网络是否连通，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping 空格 IP地址</span><br><span class="line">ping <span class="number">220.181</span>.57.216</span><br></pre></td></tr></table></figure>

<p><strong>特殊的IP地址</strong></p>
<ul>
<li>本机IP地址：<code>127.0.0.1</code>、<code>localhost</code> 。</li>
</ul>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p>
<p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p>
<ul>
<li><strong>端口号：用两个字节表示的整数，它的取值范围是0~65535</strong>。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</li>
</ul>
<p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p>
<h1 id="第二章-TCP通信程序"><a href="#第二章-TCP通信程序" class="headerlink" title="第二章 TCP通信程序"></a>第二章 TCP通信程序</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。</p>
<p><strong>两端通信时步骤：</strong></p>
<ol>
<li>服务端程序，需要事先启动，等待客户端的连接。</li>
<li>客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。</li>
</ol>
<p><strong>在Java中，提供了两个类用于实现TCP通信程序：</strong></p>
<ol>
<li>客户端：<code>java.net.Socket</code> 类表示。创建<code>Socket</code>对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li>
<li>服务端：<code>java.net.ServerSocket</code> 类表示。创建<code>ServerSocket</code>对象，相当于开启一个服务，并等待客户端的连接。</li>
</ol>
<h2 id="2-2-Socket类"><a href="#2-2-Socket类" class="headerlink" title="2.2 Socket类"></a>2.2 Socket类</h2><p><code>Socket</code> 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><p><code>public Socket(String host, int port)</code> :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。  </p>
<blockquote>
<p>小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p>
</blockquote>
</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket client = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">6666</span>);</span><br></pre></td></tr></table></figure>

<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li><p><code>public InputStream getInputStream()</code> ： 返回此套接字的输入流。</p>
<ul>
<li>如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。</li>
<li>关闭生成的InputStream也将关闭相关的Socket。</li>
</ul>
</li>
<li><p><code>public OutputStream getOutputStream()</code> ： 返回此套接字的输出流。</p>
<ul>
<li>如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。</li>
<li>关闭生成的OutputStream也将关闭相关的Socket。</li>
</ul>
</li>
<li><p><code>public void close()</code> ：关闭此套接字。</p>
<ul>
<li>一旦一个socket被关闭，它不可再使用。</li>
<li>关闭此socket也将关闭相关的InputStream和OutputStream 。 </li>
</ul>
</li>
<li><p><code>public void shutdownOutput()</code> ： 禁用此套接字的输出流。   </p>
<ul>
<li>任何先前写出的数据将被发送，随后终止输出流。 </li>
</ul>
<h2 id="2-3-ServerSocket类"><a href="#2-3-ServerSocket类" class="headerlink" title="2.3 ServerSocket类"></a>2.3 ServerSocket类</h2></li>
</ul>
<p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public ServerSocket(int port)</code> ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure>

<h3 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li><code>public Socket accept()</code> ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 </li>
</ul>
<h2 id="2-4-简单的TCP网络程序"><a href="#2-4-简单的TCP网络程序" class="headerlink" title="2.4 简单的TCP网络程序"></a>2.4 简单的TCP网络程序</h2><h3 id="TCP通信分析图解"><a href="#TCP通信分析图解" class="headerlink" title="TCP通信分析图解"></a>TCP通信分析图解</h3><ol>
<li>【服务端】启动,创建ServerSocket对象，等待连接。</li>
<li>【客户端】启动,创建Socket对象，请求连接。</li>
<li>【服务端】接收连接,调用accept方法，并返回一个Socket对象。</li>
<li>【客户端】Socket对象，获取OutputStream，向服务端写出数据。</li>
<li>【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。</li>
</ol>
<blockquote>
<p>到此，客户端向服务端发送数据成功。</p>
</blockquote>
<p><img src="/2020/03/30/avaSE基础-（三十五）/5_%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%A1.jpg" alt></p>
<blockquote>
<p>自此，服务端向客户端回写数据。</p>
</blockquote>
<ol start="6">
<li>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</li>
<li>【客户端】Scoket对象，获取InputStream，解析回写数据。</li>
<li>【客户端】释放资源，断开连接。</li>
</ol>
<h3 id="客户端向服务器发送数据"><a href="#客户端向服务器发送数据" class="headerlink" title="客户端向服务器发送数据"></a>客户端向服务器发送数据</h3><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTCP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端启动 , 等待连接 .... "</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        Socket server = ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        InputStream is = server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      	<span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      	<span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="keyword">int</span> len = is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        String msg = <span class="keyword">new</span> String(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="comment">//5.关闭资源.</span></span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTCP</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"客户端 发送数据"</span>);</span><br><span class="line">		<span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">		Socket client = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">		<span class="comment">// 2.获取流对象 . 输出流</span></span><br><span class="line">		OutputStream os = client.getOutputStream();</span><br><span class="line">		<span class="comment">// 3.写出数据.</span></span><br><span class="line">		os.write(<span class="string">"你好么? tcp ,我来了"</span>.getBytes());</span><br><span class="line">		<span class="comment">// 4. 关闭资源 .</span></span><br><span class="line">		os.close();</span><br><span class="line">		client.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务器向客户端回写数据"><a href="#服务器向客户端回写数据" class="headerlink" title="服务器向客户端回写数据"></a>服务器向客户端回写数据</h3><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTCP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端启动 , 等待连接 .... "</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        Socket server = ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        InputStream is = server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      	<span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      	<span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="keyword">int</span> len = is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        String msg = <span class="keyword">new</span> String(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">      	<span class="comment">// =================回写数据=======================</span></span><br><span class="line">      	<span class="comment">// 5. 通过 socket 获取输出流</span></span><br><span class="line">      	 OutputStream out = server.getOutputStream();</span><br><span class="line">      	<span class="comment">// 6. 回写数据</span></span><br><span class="line">      	 out.write(<span class="string">"我很好,谢谢你"</span>.getBytes());</span><br><span class="line">      	<span class="comment">// 7.关闭资源.</span></span><br><span class="line">      	out.close();</span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTCP</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"客户端 发送数据"</span>);</span><br><span class="line">		<span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">		Socket client = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">		<span class="comment">// 2.通过Scoket,获取输出流对象 </span></span><br><span class="line">		OutputStream os = client.getOutputStream();</span><br><span class="line">		<span class="comment">// 3.写出数据.</span></span><br><span class="line">		os.write(<span class="string">"你好么? tcp ,我来了"</span>.getBytes());</span><br><span class="line">      	<span class="comment">// ==============解析回写=========================</span></span><br><span class="line">      	<span class="comment">// 4. 通过Scoket,获取 输入流对象</span></span><br><span class="line">      	InputStream in = client.getInputStream();</span><br><span class="line">      	<span class="comment">// 5. 读取数据数据</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">      	<span class="keyword">int</span> len = in.read(b);</span><br><span class="line">      	System.out.println(<span class="keyword">new</span> String(b, <span class="number">0</span>, len));</span><br><span class="line">		<span class="comment">// 6. 关闭资源 .</span></span><br><span class="line">      	in.close();</span><br><span class="line">		os.close();</span><br><span class="line">		client.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章-综合案例"><a href="#第三章-综合案例" class="headerlink" title="第三章 综合案例"></a>第三章 综合案例</h1><h2 id="3-1-文件上传案例"><a href="#3-1-文件上传案例" class="headerlink" title="3.1 文件上传案例"></a>3.1 文件上传案例</h2><h3 id="文件上传分析图解"><a href="#文件上传分析图解" class="headerlink" title="文件上传分析图解"></a>文件上传分析图解</h3><ol>
<li>【客户端】输入流，从硬盘读取文件数据到程序中。</li>
<li>【客户端】输出流，写出文件数据到服务端。</li>
<li>【服务端】输入流，读取文件数据到服务端程序。</li>
<li>【服务端】输出流，写出文件数据到服务器硬盘中。</li>
</ol>
<p><img src="/2020/03/30/avaSE基础-（三十五）/6_upload.jpg" alt>    </p>
<h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">      	ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">  		<span class="comment">// 2. 建立连接 </span></span><br><span class="line">        Socket accept = serverSocket.accept();</span><br><span class="line">      	<span class="comment">// 3. 创建流对象</span></span><br><span class="line">      	<span class="comment">// 3.1 获取输入流,读取文件数据</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">        <span class="comment">// 3.2 创建输出流,保存到本地 .</span></span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"copy.jpg"</span>));</span><br><span class="line">		<span class="comment">// 4. 读写数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5. 关闭 资源</span></span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">        accept.close();</span><br><span class="line">        System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUPload_Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 创建输入流,读取本地文件  </span></span><br><span class="line">        BufferedInputStream bis  = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.jpg"</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端 </span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">        BufferedOutputStream   bos   = <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据. </span></span><br><span class="line">        <span class="keyword">byte</span>[] b  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="keyword">int</span> len ; </span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">            bos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"文件发送完毕"</span>);</span><br><span class="line">        <span class="comment">// 3.释放资源</span></span><br><span class="line"></span><br><span class="line">        bos.close(); </span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close(); </span><br><span class="line">        System.out.println(<span class="string">"文件上传完毕 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件上传优化分析"><a href="#文件上传优化分析" class="headerlink" title="文件上传优化分析"></a>文件上传优化分析</h3><ol>
<li><p><strong>文件名称写死的问题</strong></p>
<p>服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis()+<span class="string">".jpg"</span>) <span class="comment">// 文件名称</span></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>循环接收的问题</strong></p>
<p>服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次接收新的连接,创建一个Socket</span></span><br><span class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</span><br><span class="line">    Socket accept = serverSocket.accept();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>效率问题</strong></p>
<p>服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</span><br><span class="line">    Socket accept = serverSocket.accept();</span><br><span class="line">    <span class="comment">// accept 交给子线程处理.</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      	......</span><br><span class="line">        InputStream bis = accept.getInputStream();</span><br><span class="line">      	......</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">      	<span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">          	<span class="comment">/* </span></span><br><span class="line"><span class="comment">          	3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="string">".jpg"</span>);</span><br><span class="line">                    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                      bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//4. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                  	e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信息回写分析图解"><a href="#信息回写分析图解" class="headerlink" title="信息回写分析图解"></a>信息回写分析图解</h3><p>前四步与基本文件上传一致.</p>
<ol start="5">
<li>【服务端】获取输出流，回写数据。</li>
<li>【客户端】获取输入流，解析回写数据。</li>
</ol>
<p><img src="/2020/03/30/avaSE基础-（三十五）/6_upload2.jpg" alt></p>
<h4 id="回写实现"><a href="#回写实现" class="headerlink" title="回写实现"></a>回写实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">          	<span class="comment">/*</span></span><br><span class="line"><span class="comment">          	3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="string">".jpg"</span>);</span><br><span class="line">                    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.=======信息回写===========================</span></span><br><span class="line">                    System.out.println(<span class="string">"back ........"</span>);</span><br><span class="line">                    OutputStream out = accept.getOutputStream();</span><br><span class="line">                    out.write(<span class="string">"上传成功"</span>.getBytes());</span><br><span class="line">                    out.close();</span><br><span class="line">                    <span class="comment">//================================</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//5. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 创建输入流,读取本地文件</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.jpg"</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据.</span></span><br><span class="line">        <span class="keyword">byte</span>[] b  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="keyword">int</span> len ;</span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 关闭输出流,通知服务端,写出数据完毕</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        System.out.println(<span class="string">"文件发送完毕"</span>);</span><br><span class="line">        <span class="comment">// 3. =====解析回写============</span></span><br><span class="line">        InputStream in = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] back = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">        in.read(back);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(back));</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="comment">// ============================</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-模拟B-S服务器-扩展知识点"><a href="#3-2-模拟B-S服务器-扩展知识点" class="headerlink" title="3.2 模拟B\S服务器(扩展知识点)"></a>3.2 模拟B\S服务器(扩展知识点)</h2><p>模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li><p>准备页面数据，web文件夹。</p>
<p>复制到我们Module中，比如复制到day08中</p>
<p><img src="/2020/03/30/avaSE基础-（三十五）/img%5C%E5%A4%8D%E5%88%B6.png" alt></p>
</li>
<li><p>我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    	ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8000</span>);</span><br><span class="line">    	Socket socket = server.accept();</span><br><span class="line">    	InputStream in = socket.getInputStream();</span><br><span class="line">   	    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    	<span class="keyword">int</span> len = in.read(bytes);</span><br><span class="line">    	System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">    	socket.close();</span><br><span class="line">    	server.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/30/avaSE基础-（三十五）/img%5C%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE.jpg" alt></p>
</li>
<li><p>服务器程序中字节输入流可以读取到浏览器发来的请求信息</p>
<p><img src="/2020/03/30/avaSE基础-（三十五）/img%5C%E8%AF%BB%E5%8F%96%E8%AE%BF%E9%97%AE%E4%BF%A1%E6%81%AF.jpg" alt></p>
</li>
</ol>
<p>GET/web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转换流,读取浏览器请求第一行</span></span><br><span class="line">BufferedReader readWb = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">String requst = readWb.readLine();</span><br><span class="line"><span class="comment">//取出请求资源的路径</span></span><br><span class="line">String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line"><span class="comment">//去掉web前面的/</span></span><br><span class="line">String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">System.out.println(path);</span><br></pre></td></tr></table></figure>

<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>服务端实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端  启动 , 等待连接 .... "</span>);</span><br><span class="line">        <span class="comment">// 创建ServerSocket 对象</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        <span class="comment">// 转换流读取浏览器的请求消息</span></span><br><span class="line">        BufferedReader readWb = <span class="keyword">new</span></span><br><span class="line">        BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">        String requst = readWb.readLine();</span><br><span class="line">        <span class="comment">// 取出请求资源的路径</span></span><br><span class="line">        String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="comment">// 去掉web前面的/</span></span><br><span class="line">        String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 读取客户端请求的资源文件</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line">        <span class="comment">// 字节输出流,将文件写会客户端</span></span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 写入HTTP协议响应头,固定写法</span></span><br><span class="line">        out.write(<span class="string">"HTTP/1.1 200 OK\r\n"</span>.getBytes());</span><br><span class="line">        out.write(<span class="string">"Content-Type:text/html\r\n"</span>.getBytes());</span><br><span class="line">        <span class="comment">// 必须要写入空行,否则浏览器不解析</span></span><br><span class="line">        out.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        out.close();</span><br><span class="line">        readWb.close();	</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问效果"><a href="#访问效果" class="headerlink" title="访问效果"></a>访问效果</h3><ul>
<li><strong>火狐</strong></li>
</ul>
<p><img src="/2020/03/30/avaSE基础-（三十五）/%E6%95%88%E6%9E%9C%E5%9B%BE1.png" alt></p>
<blockquote>
<p>小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。</p>
</blockquote>
<p>发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。</p>
<p>浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket socket = server.accept();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Web(socket)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Web</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Web</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket=socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//转换流,读取浏览器请求第一行</span></span><br><span class="line">                BufferedReader readWb = <span class="keyword">new</span></span><br><span class="line">                        BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String requst = readWb.readLine();</span><br><span class="line">                <span class="comment">//取出请求资源的路径</span></span><br><span class="line">                String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line">                System.out.println(Arrays.toString(strArr));</span><br><span class="line">                String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">                System.out.println(path);</span><br><span class="line"></span><br><span class="line">                FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">                System.out.println(fis);</span><br><span class="line">                <span class="keyword">byte</span>[] bytes= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line">                <span class="comment">//向浏览器 回写数据</span></span><br><span class="line">                OutputStream out = socket.getOutputStream();</span><br><span class="line">                out.write(<span class="string">"HTTP/1.1 200 OK\r\n"</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">"Content-Type:text/html\r\n"</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">                <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    out.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">                &#125;</span><br><span class="line">                fis.close();</span><br><span class="line">                out.close();</span><br><span class="line">                readWb.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>访问效果：</strong></p>
<p><img src="/2020/03/30/avaSE基础-（三十五）/%E6%95%88%E6%9E%9C%E5%9B%BE2.png" alt>图解：</p>
<p><img src="/2020/03/30/avaSE基础-（三十五）/img%5CBS%E9%80%9A%E4%BF%A1.bmp" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/30/JavaSE基础-（三十四）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我与我周旋">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一轮明月照九洲">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/30/JavaSE基础-（三十四）/" itemprop="url">JavaSE基础 （三十四）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-30T19:36:48+08:00">
                2020-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Annocation（注释-注解）"><a href="#Annocation（注释-注解）" class="headerlink" title="Annocation（注释 注解）"></a>Annocation（注释 注解）</h1><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><pre><code>单行注释 //
多行注释 /*   */
文档注释 /**  */</code></pre><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="注解的写法"><a href="#注解的写法" class="headerlink" title="注解的写法"></a>注解的写法</h2><pre><code>@xxxx[{一些信息}]</code></pre><h2 id="注解放在哪里"><a href="#注解放在哪里" class="headerlink" title="注解放在哪里"></a>注解放在哪里</h2><pre><code>类的上面  属性的上面 方法的上面 构造方法的上面 参数的前面</code></pre><h2 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h2><pre><code>1.用来充当注释的作用（仅仅是一个文字说明）@deprecated
2.用来做代码的检测（验证）    @Override
3.可以携带一些信息（内容）    文件.properties.xml 注解</code></pre><h2 id="Java中有一些写好的注解给我们使用"><a href="#Java中有一些写好的注解给我们使用" class="headerlink" title="Java中有一些写好的注解给我们使用"></a>Java中有一些写好的注解给我们使用</h2><pre><code>@Deprecated   用来说明方法是废弃的
@Override     用来做代码检测 检测此方法是否重写
@SuppressWarnings(信息)  String[]  {&quot;&quot;}如果数组内的元素只有一个长度  可以省略()
unused   变量定义后未被使用
serial   类实现了序列化接口  不添加序列化ID号
rawtypes  集合没有定义泛型
deprecation 方法以废弃
*unchecked  出现了泛型问题 可以不检测
all       包含以上所有（不推荐）</code></pre><h2 id="注解中可以携带信息-可以不携带"><a href="#注解中可以携带信息-可以不携带" class="headerlink" title="注解中可以携带信息 可以不携带"></a>注解中可以携带信息 可以不携带</h2><pre><code>信息不能随便写 信息类型只能是如下的类型
1.基本数据类型
2.String数据类型
3.枚举数据类型
4.注解类型@
5.数组类型[] 数组的内部需要加上的四种类型</code></pre><h2 id="如何自己描述一个注解类型"><a href="#如何自己描述一个注解类型" class="headerlink" title="如何自己描述一个注解类型"></a>如何自己描述一个注解类型</h2><pre><code>1.通过@interface 定义个新的注解类型
2.发现写法与接口非常相似
  可以描述public static final 的属性 比较少见
  可以描述public abstract的方法 方法返回值必须有 返回值类型是如上那些
3.我们自己定义的注解拿来使用
     光定义还不够还需要做很多细致的说明（需要利用java提供好的注解来说明）
     元注解（也是注解 不是拿来使用的 是用来说明注解）
     @target 描述当前的注解可以放在哪里写
     @retention 描述当前的这个注解存在什么作用域中的
            源代码文件----&gt;编译----&gt;字节码文件----&gt;加载---&gt;内存执行
            SOURCE                    CLASS                  RUNTIME
     @Inherited  描述当前这个注解能否被子类对象继承
     @Document   描述这个注解能否生成文档</code></pre><h2 id="我们使用自己描述的注解"><a href="#我们使用自己描述的注解" class="headerlink" title="我们使用自己描述的注解"></a>我们使用自己描述的注解</h2><pre><code>问题1.注解里面描述了一个方法 方法没有参数 方法有返回值String[]
     使用注解的时候让我们传递参数
     理解为 注解的方法做事 将我们传递的参数 搬运走了给了别人
问题2.使用别人写好的注解不用写方法名 我们自己定义的方法必须写名字
     如果我们自己定义的注解 只有一个方法名字叫value
     在使用的时候可以省略方法名
     如果传递的信息是一个数组 数组内只有一个元素 可以省略{}
     如果是两个以上 每一个方法必须写名字</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/30/JavaSE基础-（三十三）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我与我周旋">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一轮明月照九洲">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/30/JavaSE基础-（三十三）/" itemprop="url">JavaSE基础 （三十三）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-30T08:05:21+08:00">
                2020-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="反射-reflect"><a href="#反射-reflect" class="headerlink" title="反射 reflect"></a>反射 reflect</h1><h2 id="类是用来描述一组类"><a href="#类是用来描述一组类" class="headerlink" title="类是用来描述一组类"></a>类是用来描述一组类</h2><h2 id="反射机制认为是描述一组类"><a href="#反射机制认为是描述一组类" class="headerlink" title="反射机制认为是描述一组类"></a>反射机制认为是描述一组类</h2><pre><code>Class           用来描述类本身
Package         用来描述所属类的包
Field           用来描述类中的属性
Method          用来描述类的方法
Constructor     用来描述类中的构造方法
Annotation      用来描述类中的注解</code></pre><h1 id="如何获取Class"><a href="#如何获取Class" class="headerlink" title="如何获取Class"></a>如何获取Class</h1><pre><code>如何下三种方式
Class    clazz = Class.for.Name(&quot;包名.类名&quot;)
Class    clazz = 类名.class;
Class    clazz = 对象.getClass();//Object类中的方法</code></pre><h1 id="Class中的常用方法"><a href="#Class中的常用方法" class="headerlink" title="Class中的常用方法"></a>Class中的常用方法</h1><pre><code>int result = getModifiers();   获取类的修饰符（权限 特征）
每一个修饰符 用一个整数来进行表示
0开始----0-1-2-4-8-16-32--64-128-256-512-1024
0---默认不写  1---public         2---private    4---protected 8---static
16---final    32----sychronized  64---voliate   128---trasnsient
256---native  512---interface    1024---abstract
String name = getName(); 获取名字
String simpleName = getSimpleName();简单名
Package p = getPackage();
p.getName();
Class sclazz = getSuperClass();//获取父类
Class[] classes = getModifiers();
Object obj = newInstance();//默认调用无参构造方法创建对象
Filed f = getField(&quot;属性名&quot;);
Field[] fs = getField();
如上两个方法只能获取公有属性 但是包含继承过来父类属性
getDeclaredField(&quot;属性&quot;)
Field[] fs =getDeclaredFields();
如上的两个方法能获取公有和私有的属性 但是只能获取本类中的属性</code></pre><h1 id="Filed类中常用方法"><a href="#Filed类中常用方法" class="headerlink" title="Filed类中常用方法"></a>Filed类中常用方法</h1><pre><code>int = getModifers()
Class = getType()
String = getName()
操作属性 向里面存值
set(对象，值）
操作属性 从里面取值
值 = get(对象)
对象 =new():// 创建对象空间 当前对象空间有自己的一套元素（属性 方法）    
setAccessable（true）可以修改属性设备操作</code></pre><h1 id="如何操作类中的方法"><a href="#如何操作类中的方法" class="headerlink" title="如何操作类中的方法"></a>如何操作类中的方法</h1><pre><code>Class类中的方法
Method m = class.getMethod(&quot;方法名&quot;，Class...参数类型);  获取公有方法（自己类+父类）
Method[] = clazz.getMethod();获取所有的方法（公有 自己+父类）
Method = getDeclaredMethod（&quot;方法名字&quot;，参数类型class...）获取所有的方法（自己类 公有 私有）
Method = getDeclaredMethods()   获取全部的方法（自己类 公有加私有）
获取构造方法
Construct = clazz.getConstructor（class...参数类型）</code></pre><h1 id="Method类中常用的方法"><a href="#Method类中常用的方法" class="headerlink" title="Method类中常用的方法"></a>Method类中常用的方法</h1><pre><code>int mm = m.getModififers()//获取方法的修饰符（权限+特征）
Class mrt = m.getReturnType();//获取返回值数据类型
String mn= m.getName();//获取方法名字
Class[] mpts = m.getParameterTypes();//获取方法参数列表的类型
Class[] mets = m.getExceptionTypes();//获取方法抛出异常类型
如何操作方法
调用方法 让他执行一次
Object result = invoke（对象.执行方法需要传递的所有参数）
若方法是私有方法 不许与操作
可以设置setAccessable（True）设置方法使用权准入</code></pre><h1 id="Constructor类中的常用方法"><a href="#Constructor类中的常用方法" class="headerlink" title="Constructor类中的常用方法"></a>Constructor类中的常用方法</h1><pre><code>con.getModifiers();
con.getName();
con.getParamenterTyper();
con.getExceptionTypers()
如何操作构造方法
执行一次 创建对象
Object = newInstance（执行构造方法时的所有参数）;</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/29/JavaSE基础-（三十二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我与我周旋">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一轮明月照九洲">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/29/JavaSE基础-（三十二）/" itemprop="url">JavaSE基础 （三十二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-29T21:33:41+08:00">
                2020-03-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="主线程-系统线程"><a href="#主线程-系统线程" class="headerlink" title="主线程  系统线程"></a>主线程  系统线程</h1><h1 id="用户线程-main"><a href="#用户线程-main" class="headerlink" title="用户线程 main"></a>用户线程 main</h1><h1 id="守护线程-GC"><a href="#守护线程-GC" class="headerlink" title="守护线程 GC"></a>守护线程 GC</h1><h1 id="线程——操作系统级别-CPU"><a href="#线程——操作系统级别-CPU" class="headerlink" title="线程——操作系统级别 CPU"></a>线程——操作系统级别 CPU</h1><h1 id="如何在Java中创建线程-让线程执行-多线程"><a href="#如何在Java中创建线程-让线程执行-多线程" class="headerlink" title="如何在Java中创建线程 让线程执行 多线程"></a>如何在Java中创建线程 让线程执行 多线程</h1><h1 id="掌握线程的几种不同状态以及如何切换"><a href="#掌握线程的几种不同状态以及如何切换" class="headerlink" title="掌握线程的几种不同状态以及如何切换"></a>掌握线程的几种不同状态以及如何切换</h1><pre><code>new      start()     cpu分配run()      wait()       exception over 
创建线程----就绪状态---执行状态------等待/挂起----------异常/消亡
               |                          |
               |__________________________|
                      notify/notifyAll唤醒</code></pre><h1 id="实现线程的过程"><a href="#实现线程的过程" class="headerlink" title="实现线程的过程"></a>实现线程的过程</h1><h2 id="自己描述一个类"><a href="#自己描述一个类" class="headerlink" title="自己描述一个类"></a>自己描述一个类</h2><h2 id="基础父类Thead"><a href="#基础父类Thead" class="headerlink" title="基础父类Thead"></a>基础父类Thead</h2><h2 id="重写run方法"><a href="#重写run方法" class="headerlink" title="重写run方法"></a>重写run方法</h2><h2 id="new一个线程对象-调用start方法让线程进入就绪状态"><a href="#new一个线程对象-调用start方法让线程进入就绪状态" class="headerlink" title="new一个线程对象 调用start方法让线程进入就绪状态"></a>new一个线程对象 调用start方法让线程进入就绪状态</h2><h1 id="实现线程的过程-1"><a href="#实现线程的过程-1" class="headerlink" title="实现线程的过程"></a>实现线程的过程</h1><h2 id="自己描述一个类-1"><a href="#自己描述一个类-1" class="headerlink" title="自己描述一个类"></a>自己描述一个类</h2><h2 id="实现一个父类接口Runnerable"><a href="#实现一个父类接口Runnerable" class="headerlink" title="实现一个父类接口Runnerable"></a>实现一个父类接口Runnerable</h2><h2 id="重写run方法-1"><a href="#重写run方法-1" class="headerlink" title="重写run方法"></a>重写run方法</h2><h2 id="new一个线程对象-需要创建Thead将自己包起来-然后调用Start"><a href="#new一个线程对象-需要创建Thead将自己包起来-然后调用Start" class="headerlink" title="new一个线程对象 需要创建Thead将自己包起来 然后调用Start()"></a>new一个线程对象 需要创建Thead将自己包起来 然后调用Start()</h2><h1 id="生产者和消费者模型"><a href="#生产者和消费者模型" class="headerlink" title="生产者和消费者模型"></a>生产者和消费者模型</h1><h2 id="通过这个模型-成功演示出-线程的安全问题"><a href="#通过这个模型-成功演示出-线程的安全问题" class="headerlink" title="通过这个模型 成功演示出 线程的安全问题"></a>通过这个模型 成功演示出 线程的安全问题</h2><pre><code>两个消费者 同时访问一个仓库对象 仓库内只有一个元素的时候
两个消费者 并发访问 会有可能产生抢夺资源的问题</code></pre><h2 id="自己解决一下线程安全的问题"><a href="#自己解决一下线程安全的问题" class="headerlink" title="自己解决一下线程安全的问题"></a>自己解决一下线程安全的问题</h2><pre><code>让仓库对象被线程访问的时候 仓库对象被锁定
仓库对象只能被一个线程所访问 其他对象处于等待状态
特征修饰符
synchronized 同步 一个时间段只有一个线程能访问</code></pre><h2 id="线程安全锁两种写法"><a href="#线程安全锁两种写法" class="headerlink" title="线程安全锁两种写法"></a>线程安全锁两种写法</h2><h3 id="将synchronized关键字-放在方法结构上"><a href="#将synchronized关键字-放在方法结构上" class="headerlink" title="将synchronized关键字 放在方法结构上"></a>将synchronized关键字 放在方法结构上</h3><pre><code>public synchronized void get(){}
锁定的是调用方法时的那个对象</code></pre><h3 id="将synchronized关键字-方法在（构造方法内部）的内部"><a href="#将synchronized关键字-方法在（构造方法内部）的内部" class="headerlink" title="将synchronized关键字 方法在（构造方法内部）的内部"></a>将synchronized关键字 方法在（构造方法内部）的内部</h3><pre><code>public void get(){
     好多代码
     synchronzied（对象）{
     好多代码
     }
     好多代码
}</code></pre><h2 id="我们觉得return-不是很好"><a href="#我们觉得return-不是很好" class="headerlink" title="我们觉得return 不是很好"></a>我们觉得return 不是很好</h2><pre><code>应该让线程的不同状态来回切换
执行 等待 执行 等待
wait() Object类中的方法
对象.wait();
对象.wait();不是当前对象wait 
             访问当前这个对象的线程wait
 notify
 notifyAll
 p.setPriority(10);   p.getPriorty();
 产生一个类似假死的状态
 所有的线程进入等待状态 没有线程做事</code></pre><h1 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h1><h2 id="程序-进程-线程-概念的区别"><a href="#程序-进程-线程-概念的区别" class="headerlink" title="程序 进程 线程 概念的区别"></a>程序 进程 线程 概念的区别</h2><h2 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h2><h2 id="线程的几种状态-如何切换"><a href="#线程的几种状态-如何切换" class="headerlink" title="线程的几种状态 如何切换"></a>线程的几种状态 如何切换</h2><h2 id="sleep方法-和-wait方法区别"><a href="#sleep方法-和-wait方法区别" class="headerlink" title="sleep方法 和  wait方法区别"></a>sleep方法 和  wait方法区别</h2><pre><code>1.类    Thead类                       Object类
2.调用  静态 类名                       对象
3，理解  那个位置调用                    对象调用的方法
      那个线程等待                    访问对象的其他线程等待
4.唤醒   不需要别人                     需要其他对象调用notiy唤醒
5.锁    不会释放锁                      等会会释放锁</code></pre><h1 id="比较重要的方法-join"><a href="#比较重要的方法-join" class="headerlink" title="比较重要的方法 join"></a>比较重要的方法 join</h1><pre><code>设计一个模型
1.有两个线程 One   Two  Two加入到One里面
2.设计模型的时候  two线程在one的run里面创建 保证两个先后顺序
3.Two.join();  无参数==0; 有参数==2000
         two.join(0){
         while(two.isAlive()){
                    Two.wait（0）；//访问Two的线程进入等待状态
         }</code></pre><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="一旦对象锁定-不释放的情况下其他对象都需要等待-有可能会产生死锁的效果"><a href="#一旦对象锁定-不释放的情况下其他对象都需要等待-有可能会产生死锁的效果" class="headerlink" title="一旦对象锁定 不释放的情况下其他对象都需要等待 有可能会产生死锁的效果"></a>一旦对象锁定 不释放的情况下其他对象都需要等待 有可能会产生死锁的效果</h2><h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><h2 id="解决死锁的问题"><a href="#解决死锁的问题" class="headerlink" title="解决死锁的问题"></a>解决死锁的问题</h2><h3 id="礼让—–-gt-产生时间差"><a href="#礼让—–-gt-产生时间差" class="headerlink" title="礼让—–&gt;产生时间差"></a>礼让—–&gt;产生时间差</h3><h3 id="不要产生公用对象问题"><a href="#不要产生公用对象问题" class="headerlink" title="不要产生公用对象问题"></a>不要产生公用对象问题</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/26/JavaSE基础-（三十一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我与我周旋">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一轮明月照九洲">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/26/JavaSE基础-（三十一）/" itemprop="url">JavaSE基础  （三十一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-26T23:25:56+08:00">
                2020-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="学习文件流"><a href="#学习文件流" class="headerlink" title="学习文件流"></a>学习文件流</h1><h2 id="文件流按照读取或写入的单位（字节数）大小来区分"><a href="#文件流按照读取或写入的单位（字节数）大小来区分" class="headerlink" title="文件流按照读取或写入的单位（字节数）大小来区分"></a>文件流按照读取或写入的单位（字节数）大小来区分</h2><h2 id="字节型文件流（1字节）"><a href="#字节型文件流（1字节）" class="headerlink" title="字节型文件流（1字节）"></a>字节型文件流（1字节）</h2><h3 id="FileInputStream-FileOutputStream"><a href="#FileInputStream-FileOutputStream" class="headerlink" title="FileInputStream/FileOutputStream"></a>FileInputStream/FileOutputStream</h3><h2 id="字符型文件流（2-字节–1字符）"><a href="#字符型文件流（2-字节–1字符）" class="headerlink" title="字符型文件流（2-字节–1字符）"></a>字符型文件流（2-字节–1字符）</h2><h3 id="FileReader-FileWriter"><a href="#FileReader-FileWriter" class="headerlink" title="FileReader/FileWriter"></a>FileReader/FileWriter</h3><h1 id="字节型文件输入流"><a href="#字节型文件输入流" class="headerlink" title="字节型文件输入流"></a>字节型文件输入流</h1><h2 id="了解一下继承关系-inputStream类-字节型输入流的父类"><a href="#了解一下继承关系-inputStream类-字节型输入流的父类" class="headerlink" title="了解一下继承关系 inputStream类 字节型输入流的父类"></a>了解一下继承关系 inputStream类 字节型输入流的父类</h2><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="调用一个带File类型的构造方法"><a href="#调用一个带File类型的构造方法" class="headerlink" title="调用一个带File类型的构造方法"></a>调用一个带File类型的构造方法</h3><h3 id="调用一个带String类型的构造方法"><a href="#调用一个带String类型的构造方法" class="headerlink" title="调用一个带String类型的构造方法"></a>调用一个带String类型的构造方法</h3><h2 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h2><pre><code>int code = read(); 每次从流管道中读取一个字节 返回字节码的code码
int count = read(byte[] )每次从流管道中读取若干字节 存入数组内 返回有效元素
skip（long n）跳过几个字节 读取
多线程————————&gt;利用几个线程同时读取文件
*close()   将流管道关闭---必须要做 最好放在fianlly里 注意代码的健壮性 严谨性</code></pre><h1 id="字节型文件输出流"><a href="#字节型文件输出流" class="headerlink" title="字节型文件输出流"></a>字节型文件输出流</h1><h2 id="FileOutput-将数据写入文件中"><a href="#FileOutput-将数据写入文件中" class="headerlink" title="FileOutput 将数据写入文件中"></a>FileOutput 将数据写入文件中</h2><h2 id="java-io"><a href="#java-io" class="headerlink" title="java.io"></a>java.io</h2><h2 id="继承OutputStream-所有字节输出型的父类"><a href="#继承OutputStream-所有字节输出型的父类" class="headerlink" title="继承OutputStream 所有字节输出型的父类"></a>继承OutputStream 所有字节输出型的父类</h2><h2 id="创建对象-1"><a href="#创建对象-1" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="调用一个带file参数-还有file-Boolean重载"><a href="#调用一个带file参数-还有file-Boolean重载" class="headerlink" title="调用一个带file参数 还有file Boolean重载"></a>调用一个带file参数 还有file Boolean重载</h3><h3 id="调用一个带String参数-还有String-boolean-重载"><a href="#调用一个带String参数-还有String-boolean-重载" class="headerlink" title="调用一个带String参数 还有String boolean 重载"></a>调用一个带String参数 还有String boolean 重载</h3><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><pre><code>writr(int code);将给定的code对应的字符写入文件“=”
write(byte[]) 将数组中的全部字节写入文集 getByte()
flush() 将管道内的字节推入(刷新)文件
close() 注意在finaly类中关闭</code></pre><h1 id="字符型文件流"><a href="#字符型文件流" class="headerlink" title="字符型文件流"></a>字符型文件流</h1><h2 id="FileReader-FileWriter-1"><a href="#FileReader-FileWriter-1" class="headerlink" title="FileReader   FileWriter"></a>FileReader   FileWriter</h2><h2 id="只能操作存文本文件（右键打开方式-记事本打开-能看懂）-txt"><a href="#只能操作存文本文件（右键打开方式-记事本打开-能看懂）-txt" class="headerlink" title="只能操作存文本文件（右键打开方式 记事本打开 能看懂）.txt"></a>只能操作存文本文件（右键打开方式 记事本打开 能看懂）.txt</h2><h1 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h1><h2 id="java-io包"><a href="#java-io包" class="headerlink" title="java.io包"></a>java.io包</h2><h2 id="继承-InputStreamReader-Reader"><a href="#继承-InputStreamReader-Reader" class="headerlink" title="继承 InputStreamReader Reader"></a>继承 InputStreamReader Reader</h2><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><h3 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h3><h3 id="read-char"><a href="#read-char" class="headerlink" title="read(char[])"></a>read(char[])</h3><h1 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h1><h2 id="java-io包-1"><a href="#java-io包-1" class="headerlink" title="java.io包"></a>java.io包</h2><h2 id="继承OutputStreamWriter-Writer"><a href="#继承OutputStreamWriter-Writer" class="headerlink" title="继承OutputStreamWriter Writer"></a>继承OutputStreamWriter Writer</h2><h2 id="构造方法-带file参数-带file-boolean参数"><a href="#构造方法-带file参数-带file-boolean参数" class="headerlink" title="构造方法 带file参数 带file,boolean参数"></a>构造方法 带file参数 带file,boolean参数</h2><h2 id="nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-带String参数-带String，boolean参数"><a href="#nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-带String参数-带String，boolean参数" class="headerlink" title="&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;带String参数 带String，boolean参数"></a>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;带String参数 带String，boolean参数</h2><h2 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h2><pre><code>writer（int）
writer（char[]）
writer（String）
int count = read(char[]);
close() flush()</code></pre><h1 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h1><h2 id="在管道中内增加缓存的数据"><a href="#在管道中内增加缓存的数据" class="headerlink" title="在管道中内增加缓存的数据"></a>在管道中内增加缓存的数据</h2><h2 id="让我们使用流读取的文字更加流畅"><a href="#让我们使用流读取的文字更加流畅" class="headerlink" title="让我们使用流读取的文字更加流畅"></a>让我们使用流读取的文字更加流畅</h2><h2 id="高级流—–》创建通过低级流"><a href="#高级流—–》创建通过低级流" class="headerlink" title="高级流—–》创建通过低级流"></a>高级流—–》创建通过低级流</h2><pre><code>BufferedInputStream/BufferedOutputStream
BufferedReader/BufferedWriter
BUfferedInPutStream
构建方式 使用低级流构建
基本上使用与低级流完全一致
read()skip()available()close() 
BufferedOutStream
构建方式 使用低级流构建 注意缓冲流构建的时候没有boolean类型的参数
基本使用与低级流的方法完全一致
read()skip()available()close()
BufferedOutputStream</code></pre><h1 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h1><h2 id="对象的序列化-反序列化"><a href="#对象的序列化-反序列化" class="headerlink" title="对象的序列化/反序列化"></a>对象的序列化/反序列化</h2><h2 id="为什么要有文件"><a href="#为什么要有文件" class="headerlink" title="为什么要有文件"></a>为什么要有文件</h2><pre><code>文件永久保存信息    很多数据存入文件-----数据持久化</code></pre><h2 id="如果按照以行为单位写信息"><a href="#如果按照以行为单位写信息" class="headerlink" title="如果按照以行为单位写信息"></a>如果按照以行为单位写信息</h2><h3 id="好处在于每一行记录的信息都是相关的"><a href="#好处在于每一行记录的信息都是相关的" class="headerlink" title="好处在于每一行记录的信息都是相关的"></a>好处在于每一行记录的信息都是相关的</h3><h3 id="信息我们可以读出来-直接看懂文件"><a href="#信息我们可以读出来-直接看懂文件" class="headerlink" title="信息我们可以读出来 直接看懂文件"></a>信息我们可以读出来 直接看懂文件</h3><h3 id="不好在于第一不一定安全-直接看懂"><a href="#不好在于第一不一定安全-直接看懂" class="headerlink" title="不好在于第一不一定安全 直接看懂"></a>不好在于第一不一定安全 直接看懂</h3><h3 id="不好在于只能记录String信息-不一定能记录一些动作（方法）"><a href="#不好在于只能记录String信息-不一定能记录一些动作（方法）" class="headerlink" title="不好在于只能记录String信息 不一定能记录一些动作（方法）"></a>不好在于只能记录String信息 不一定能记录一些动作（方法）</h3><h3 id="读取出来的信息-String——-gt-Person"><a href="#读取出来的信息-String——-gt-Person" class="headerlink" title="读取出来的信息 String——&gt;Person"></a>读取出来的信息 String——&gt;Person</h3><h3 id="如果能将对象拆分成字节码直接写入文件"><a href="#如果能将对象拆分成字节码直接写入文件" class="headerlink" title="如果能将对象拆分成字节码直接写入文件"></a>如果能将对象拆分成字节码直接写入文件</h3><h2 id="将对象直接存入文件中—–对象流"><a href="#将对象直接存入文件中—–对象流" class="headerlink" title="将对象直接存入文件中—–对象流"></a>将对象直接存入文件中—–对象流</h2><h1 id="为什么要重写toString方法"><a href="#为什么要重写toString方法" class="headerlink" title="为什么要重写toString方法"></a>为什么要重写toString方法</h1><h2 id="toString-方法默认是打印对象和hashcode码"><a href="#toString-方法默认是打印对象和hashcode码" class="headerlink" title="toString 方法默认是打印对象和hashcode码"></a>toString 方法默认是打印对象和hashcode码</h2><h2 id="当输出为一个对象名的时候"><a href="#当输出为一个对象名的时候" class="headerlink" title="当输出为一个对象名的时候"></a>当输出为一个对象名的时候</h2><h2 id="重写toString方法可以打印对象的值"><a href="#重写toString方法可以打印对象的值" class="headerlink" title="重写toString方法可以打印对象的值"></a>重写toString方法可以打印对象的值</h2><h1 id="对象序列化与反序列化"><a href="#对象序列化与反序列化" class="headerlink" title="对象序列化与反序列化"></a>对象序列化与反序列化</h1><h2 id="对象的序列化指的是"><a href="#对象的序列化指的是" class="headerlink" title="对象的序列化指的是"></a>对象的序列化指的是</h2><h3 id="将一个完整的对象-拆分成字节碎片-记录在文件中"><a href="#将一个完整的对象-拆分成字节碎片-记录在文件中" class="headerlink" title="将一个完整的对象 拆分成字节碎片 记录在文件中"></a>将一个完整的对象 拆分成字节碎片 记录在文件中</h3><h2 id="对象的反序列化指的是"><a href="#对象的反序列化指的是" class="headerlink" title="对象的反序列化指的是"></a>对象的反序列化指的是</h2><h3 id="将文件中记录的对象随便-反过来组合一个完整的对象"><a href="#将文件中记录的对象随便-反过来组合一个完整的对象" class="headerlink" title="将文件中记录的对象随便 反过来组合一个完整的对象"></a>将文件中记录的对象随便 反过来组合一个完整的对象</h3><h2 id="如果想要将对象序列化到文件中"><a href="#如果想要将对象序列化到文件中" class="headerlink" title="如果想要将对象序列化到文件中"></a>如果想要将对象序列化到文件中</h2><h3 id="需要对象实现Serializable接口"><a href="#需要对象实现Serializable接口" class="headerlink" title="需要对象实现Serializable接口"></a>需要对象实现Serializable接口</h3><h3 id="是一个示意性的接口"><a href="#是一个示意性的接口" class="headerlink" title="是一个示意性的接口"></a>是一个示意性的接口</h3><h2 id="如果要实现反序列化"><a href="#如果要实现反序列化" class="headerlink" title="如果要实现反序列化"></a>如果要实现反序列化</h2><h3 id="需要给对象提供一个序列化的版本号-1-7版本—-gt-String-1-8—-gt-String"><a href="#需要给对象提供一个序列化的版本号-1-7版本—-gt-String-1-8—-gt-String" class="headerlink" title="需要给对象提供一个序列化的版本号 1.7版本—&gt;String 1.8—&gt;String"></a>需要给对象提供一个序列化的版本号 1.7版本—&gt;String 1.8—&gt;String</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/26/JavaSE基础-（三十）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我与我周旋">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一轮明月照九洲">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/26/JavaSE基础-（三十）/" itemprop="url">JavaSE基础  （三十）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-26T22:28:17+08:00">
                2020-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="I-O相关-输入-输出-流（数据流动）"><a href="#I-O相关-输入-输出-流（数据流动）" class="headerlink" title="I/O相关 输入/输出 流（数据流动）"></a>I/O相关 输入/输出 流（数据流动）</h1><h2 id="数据流动的方向-读数据-输入input-写数据（输出output）"><a href="#数据流动的方向-读数据-输入input-写数据（输出output）" class="headerlink" title="数据流动的方向 读数据(输入input) 写数据（输出output）"></a>数据流动的方向 读数据(输入input) 写数据（输出output）</h2><h2 id="文件流-字符流-数组流-对象流-网络流"><a href="#文件流-字符流-数组流-对象流-网络流" class="headerlink" title="文件流 字符流 数组流 对象流 网络流"></a>文件流 字符流 数组流 对象流 网络流</h2><h1 id="什么叫文件"><a href="#什么叫文件" class="headerlink" title="什么叫文件"></a>什么叫文件</h1><h2 id="一种电脑的存储形式"><a href="#一种电脑的存储形式" class="headerlink" title="一种电脑的存储形式"></a>一种电脑的存储形式</h2><h2 id="文件有不同的格式-txt-doc-ppt-mp4-rar-…"><a href="#文件有不同的格式-txt-doc-ppt-mp4-rar-…" class="headerlink" title="文件有不同的格式 .txt .doc .ppt .mp4 .rar …"></a>文件有不同的格式 .txt .doc .ppt .mp4 .rar …</h2><h2 id="文件夹—–目录路径"><a href="#文件夹—–目录路径" class="headerlink" title="文件夹—–目录路径"></a>文件夹—–目录路径</h2><h2 id="File—–-gt-与电脑上的文件夹产生一一对应的映射关系"><a href="#File—–-gt-与电脑上的文件夹产生一一对应的映射关系" class="headerlink" title="File—–&gt;与电脑上的文件夹产生一一对应的映射关系"></a>File—–&gt;与电脑上的文件夹产生一一对应的映射关系</h2><h2 id="File是一个类"><a href="#File是一个类" class="headerlink" title="File是一个类"></a>File是一个类</h2><h2 id="java-io包"><a href="#java-io包" class="headerlink" title="java.io包"></a>java.io包</h2><h2 id="文件或目录路径名的抽象形式"><a href="#文件或目录路径名的抽象形式" class="headerlink" title="文件或目录路径名的抽象形式"></a>文件或目录路径名的抽象形式</h2><h2 id="File与真实硬盘中的文件或文件夹-不是同一个东西"><a href="#File与真实硬盘中的文件或文件夹-不是同一个东西" class="headerlink" title="File与真实硬盘中的文件或文件夹 不是同一个东西"></a>File与真实硬盘中的文件或文件夹 不是同一个东西</h2><h2 id="File是内存中的一个对象-lt-—–映射—-gt-磁盘上的文件或文件夹"><a href="#File是内存中的一个对象-lt-—–映射—-gt-磁盘上的文件或文件夹" class="headerlink" title="File是内存中的一个对象&lt;—–映射—-&gt;磁盘上的文件或文件夹"></a>File是内存中的一个对象&lt;—–映射—-&gt;磁盘上的文件或文件夹</h2><h2 id="File类中的常用方法"><a href="#File类中的常用方法" class="headerlink" title="File类中的常用方法"></a>File类中的常用方法</h2><pre><code>canRead() canWrite() isHidden() isFile() isDirectory()
length() 获取文件中的字节数
lastModified()获取文件最后的修改时间----&gt;毫秒值
*String path = getAbstractPath() 获取文件的绝对路径 D://test//Test.txt
绝对路径&lt;---&gt;相对路径
绝对路径可以通过完整字符串 定位盘符 文件夹 文件
相对路径没有盘符的写法 当前工程（项目）所在的位置寻找
              C：\Users\Administator\ideaProjects\TestFile\src
*String name = getName()获取文件名字 Test.txt
*creatNewFile() 创建新的文件
*mkdir 创建新的文件夹 外层没有 不能创建
*mkdirs 创建新的文件夹 外层没有 自动创建
String pname = getParent() 获取当前file的父亲file名字
*File file = getParent() 获取当前file父亲的对象
String[] names = list() 获取当前file所有儿子的名字
*File[]files = listFiles() 获取当前file所有儿子对象
*boolean = delete() 删除文件或空的文件及 不能删除带元素的文件夹</code></pre><h2 id><a href="#" class="headerlink" title=" "></a> </h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/25/JavaSE基础-（二十八）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我与我周旋">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一轮明月照九洲">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/25/JavaSE基础-（二十八）/" itemprop="url">JavaSE基础 （二十八）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-25T22:41:32+08:00">
                2020-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Map-映射"><a href="#Map-映射" class="headerlink" title="Map 映射"></a>Map 映射</h1><h2 id="通过某一个key键可以直接定位到一个Value值"><a href="#通过某一个key键可以直接定位到一个Value值" class="headerlink" title="通过某一个key键可以直接定位到一个Value值"></a>通过某一个key键可以直接定位到一个Value值</h2><h2 id="存储方式以-键值对-存储-Key-Value"><a href="#存储方式以-键值对-存储-Key-Value" class="headerlink" title="存储方式以 键值对 存储 Key-Value"></a>存储方式以 键值对 存储 Key-Value</h2><h2 id="key无序还是一样-指的是存入顺序与取得顺序不一致"><a href="#key无序还是一样-指的是存入顺序与取得顺序不一致" class="headerlink" title="key无序还是一样,指的是存入顺序与取得顺序不一致"></a>key无序还是一样,指的是存入顺序与取得顺序不一致</h2><h2 id="key无重复当然指的是-元素不能一致"><a href="#key无重复当然指的是-元素不能一致" class="headerlink" title="key无重复当然指的是 元素不能一致"></a>key无重复当然指的是 元素不能一致</h2><h1 id="Map基本使用"><a href="#Map基本使用" class="headerlink" title="Map基本使用"></a>Map基本使用</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><h1 id="HashMap-1"><a href="#HashMap-1" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="包-java-util"><a href="#包-java-util" class="headerlink" title="包 java.util"></a>包 java.util</h2><h2 id="如何创建对象"><a href="#如何创建对象" class="headerlink" title="如何创建对象"></a>如何创建对象</h2><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><pre><code>增删改查
增put(key,value)   存放一组映射关系 key-value
          1.key存储的顺序与取得的顺序不同
          2.不同的key可以存储相同的value
          3.key若有相同的 则将原有的key覆盖而不是拒绝存入(跟Set刚好相反)
删 E = remove(key);
改 put = (key,value1) put（key,value2）
  replace（key,newValue）
查 E = get(key)
遍历Map集合   key不一定什么样
//获取map集合的全部key
Set&lt;Integer&gt; it = map.keySet();
//通过迭代器遍历
Iterator&lt;Integer&gt; it = keys.iterator();
while(it.hashNext()){
   Integer key = it.next;
   String value = map.get(key);
   System.out.println(key+&quot;-&quot;value);
}</code></pre><h2 id="API提供的其他方法"><a href="#API提供的其他方法" class="headerlink" title="API提供的其他方法"></a>API提供的其他方法</h2><pre><code>char containsKey(key) containsValue(value)
getOrDfault(key.defaultValue)如果key存在就返回对象对应的Value 若没有找到则返回默认返回值
isEmpty()
putAll(map)
putlfAbsent(key.value);//如果key不存在才向集合添加 如果key值不存在就不添加了</code></pre><h2 id="HashMap在什么情形下用"><a href="#HashMap在什么情形下用" class="headerlink" title="HashMap在什么情形下用?"></a>HashMap在什么情形下用?</h2><h3 id="想要存一组元素"><a href="#想要存一组元素" class="headerlink" title="想要存一组元素"></a>想要存一组元素</h3><h4 id="数组-or-集合-如果存储的元素以后长度不变用数组-如果数组长度以后不确定用集合"><a href="#数组-or-集合-如果存储的元素以后长度不变用数组-如果数组长度以后不确定用集合" class="headerlink" title="数组 or 集合 如果存储的元素以后长度不变用数组 如果数组长度以后不确定用集合"></a>数组 or 集合 如果存储的元素以后长度不变用数组 如果数组长度以后不确定用集合</h4><h4 id="如果发现长度以后不确定——————-gt-集合"><a href="#如果发现长度以后不确定——————-gt-集合" class="headerlink" title="如果发现长度以后不确定——————&gt;集合"></a>如果发现长度以后不确定——————&gt;集合</h4><pre><code>List Set Map
List家族有序的  存储有顺序用这个
       ArrayList       更适合遍历轮循
       LinkList        更适合插入删除
       Stack          LIFO      
Set家族无重复   存储元素希望自动去掉重复元用这个
       Hash            性能更高
       Tree            希望存进去的元素自动去重复 同时还自动排序按(A-Z)字典顺序

Map家族k-v      通过唯一的K快速找寻v用这个
       Hash            性能更高
       Tree            希望存进去的元素能自动排序</code></pre><h2 id="Hash底层的数据结构"><a href="#Hash底层的数据结构" class="headerlink" title="Hash底层的数据结构"></a>Hash底层的数据结构</h2><pre><code>散列表形式      数组加链表
Person对象存入HashMap中  可以
HashCode方法   —&gt;不同的对象可以产生相同的hashCode码
不同的hashCode码  不同的对象
//hashcode码
static fial int hash(Object obj){
  int h;
  return(key == null)?0:(h = key.hashCode())^(h &gt;&gt;&gt;16);
}
数组：对象的hashCode码
    发现hashCode码一致
    当前数组后面串一个Node

    先扫描数组(位置 )
    继续扫描链表
    数组中存储的是hash值
    （key+value）包装成一个对象Entry
    Map.entry</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/25/javaSE基础-（二十七）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我与我周旋">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一轮明月照九洲">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/25/javaSE基础-（二十七）/" itemprop="url">javaSE基础   （二十七）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-25T21:58:13+08:00">
                2020-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><h2 id="以value形式存在"><a href="#以value形式存在" class="headerlink" title="以value形式存在"></a>以value形式存在</h2><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="无序无重复"><a href="#无序无重复" class="headerlink" title="无序无重复"></a>无序无重复</h2><h2 id="具体实现的类"><a href="#具体实现的类" class="headerlink" title="具体实现的类"></a>具体实现的类</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><h2 id="基本的使用"><a href="#基本的使用" class="headerlink" title="基本的使用"></a>基本的使用</h2><h2 id="无序-无重复"><a href="#无序-无重复" class="headerlink" title="无序 无重复"></a>无序 无重复</h2><h3 id="无序-：-我们使用的集合存放元素的顺序-集合内取出来的顺序不一致-（不是集合本身是否有序-Tree自然有序）"><a href="#无序-：-我们使用的集合存放元素的顺序-集合内取出来的顺序不一致-（不是集合本身是否有序-Tree自然有序）" class="headerlink" title="无序 ： 我们使用的集合存放元素的顺序 集合内取出来的顺序不一致 （不是集合本身是否有序 Tree自然有序）"></a>无序 ： 我们使用的集合存放元素的顺序 集合内取出来的顺序不一致 （不是集合本身是否有序 Tree自然有序）</h3><h3 id="无重复-：添加的元素不能一致（如果出现重复元素-只存第一个-不再存入）"><a href="#无重复-：添加的元素不能一致（如果出现重复元素-只存第一个-不再存入）" class="headerlink" title="无重复 ：添加的元素不能一致（如果出现重复元素 只存第一个 不再存入）"></a>无重复 ：添加的元素不能一致（如果出现重复元素 只存第一个 不再存入）</h3><h3 id="集合本身是有自己的算法排布顺序-hash算法"><a href="#集合本身是有自己的算法排布顺序-hash算法" class="headerlink" title="集合本身是有自己的算法排布顺序 hash算法"></a>集合本身是有自己的算法排布顺序 hash算法</h3><h1 id="HashSet——-gt-（HashMap（数组-链表）散列表-邻接表）"><a href="#HashSet——-gt-（HashMap（数组-链表）散列表-邻接表）" class="headerlink" title="HashSet——-&gt;（HashMap（数组+链表）散列表 邻接表）"></a>HashSet——-&gt;（HashMap（数组+链表）散列表 邻接表）</h1><h2 id="java-util包"><a href="#java-util包" class="headerlink" title="java.util包"></a>java.util包</h2><h2 id="如何创建对象"><a href="#如何创建对象" class="headerlink" title="如何创建对象"></a>如何创建对象</h2><h3 id="无参数"><a href="#无参数" class="headerlink" title="无参数"></a>无参数</h3><h3 id="有参数"><a href="#有参数" class="headerlink" title="有参数"></a>有参数</h3><h2 id="集合容器的基本使用"><a href="#集合容器的基本使用" class="headerlink" title="集合容器的基本使用"></a>集合容器的基本使用</h2><pre><code>增删改差
boolean = add(value) addAll(collection c) retainAll removeAll
boolean = remove(Object)
没有修改方法
size()</code></pre><h3 id="关于迭代器iterator"><a href="#关于迭代器iterator" class="headerlink" title="关于迭代器iterator"></a>关于迭代器iterator</h3><pre><code>//获取一个迭代器对象 通过set集合获取
Iterator &lt;String&gt; it = set.iterator();// Iterator 接口 多态效果 父类引用子类对象
//判断下一个位置是否有元素
if（it.hashNext）{
 String value = it.next();
 System.out.println(Value);
}</code></pre><h2 id="无重复原则"><a href="#无重复原则" class="headerlink" title="无重复原则"></a>无重复原则</h2><pre><code>首先通过String类和Person类型存储
大概猜测 无重复原则 利用equals方法进行比较
如果我们让Person对象的name一致 认为是同一个对象
我们可以重写equals方法
重写了equals方法 发现还没有产生无重复的效果
证明可能原则不止equals方法这么简单
还有另一个规则同时起着作用 hashcode方法</code></pre><h3 id="为什么要重写equals（）方法？"><a href="#为什么要重写equals（）方法？" class="headerlink" title="为什么要重写equals（）方法？"></a>为什么要重写equals（）方法？</h3><pre><code>  因为默认equals在比较两个对象时，是看他们是否指向同一个地址的。但有时，我们需要两个不同对象只要是某些属性相同就认为它们equals（）的结果为true。比如：

 person p1 = new person(1,&quot;name&quot;);
 person p2 = new person(1,&quot;name&quot;);
 如果不重写equals的话，他们是不相同的，所以我们要重些equals，判断只要他们的id和名字相同equals就为true，在一些集合里有时也这样用，集合里的contain也是用equals来比较

   先来看Object关于equals()的源码：

   public boolean equals(Object obj) {
   return (this == obj);
   }


 //String 就重写了equals方法
public boolean equals(Object obj){
    if(this==obj){
        return true;
    }
    if(obj instanceof Question) {
        Question anotherQuestion = (Question)obj;
       //this.title 按照？截取 与anotherQuestion.title截取之前的部分比较
        if(this.title.equals(anotherQuestion.title)){
            return true;
        }
    }
    return false;
}</code></pre><h3 id="当重写equals方法时，同时也要重写hashCode方法。"><a href="#当重写equals方法时，同时也要重写hashCode方法。" class="headerlink" title="当重写equals方法时，同时也要重写hashCode方法。"></a>当重写equals方法时，同时也要重写hashCode方法。</h3><pre><code>//修改equals 方法一定要修改hashcode方法 因为底层用hashCode比较
public int hash(){
   return this.title.hashCode();
}</code></pre><h1 id="TreeSet—–-gt-（TreeMap-二叉树利用Node（Left-item-right））"><a href="#TreeSet—–-gt-（TreeMap-二叉树利用Node（Left-item-right））" class="headerlink" title="TreeSet—–&gt;（TreeMap 二叉树利用Node（Left item right））"></a>TreeSet—–&gt;（TreeMap 二叉树利用Node（Left item right））</h1><h2 id="无序无重复-java-util"><a href="#无序无重复-java-util" class="headerlink" title="无序无重复 java.util"></a>无序无重复 java.util</h2><h2 id="无参构造方法-带Collection构造方法"><a href="#无参构造方法-带Collection构造方法" class="headerlink" title="无参构造方法 带Collection构造方法"></a>无参构造方法 带Collection构造方法</h2><h2 id="基本常用方法"><a href="#基本常用方法" class="headerlink" title="基本常用方法"></a>基本常用方法</h2><pre><code>add(E e)  iterator() remove(E e) 没有修改 size()</code></pre><h2 id="无序无重复规则是如何实现的"><a href="#无序无重复规则是如何实现的" class="headerlink" title="无序无重复规则是如何实现的"></a>无序无重复规则是如何实现的</h2><pre><code>treeSet集合本身是有顺序的  我们指的无序是存入和取出不一致
CompaerTo------&gt;String类 按照字母的自然顺序排列
//如果想让Person对象存入TeeSet集合内  必须实现Comapareable接口 重写这个方法
piublic int compareTo（o.name）{//当前对象name与另一个对象CompareTo结果
return this.name.compareTo(o.name);//当前对象name和另一对象name的CompareTO结果
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/25/avaSE基础-（二十六）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我与我周旋">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一轮明月照九洲">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/25/avaSE基础-（二十六）/" itemprop="url">JavaSE基础         (二十六）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-25T21:30:11+08:00">
                2020-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h1 id="Vector-类"><a href="#Vector-类" class="headerlink" title="Vector 类"></a>Vector 类</h1><h2 id="java-util包"><a href="#java-util包" class="headerlink" title="java.util包"></a>java.util包</h2><h2 id="是ArrayList集合-早期版本"><a href="#是ArrayList集合-早期版本" class="headerlink" title="是ArrayList集合 早期版本"></a>是ArrayList集合 早期版本</h2><pre><code>(StringBuffer类早期 Stringbuilder后来)
 vector底层也是用动态数组来存储
 vector是线程同步的 安全性高 效率低</code></pre><h2 id="扩容方式与ArrayList不同"><a href="#扩容方式与ArrayList不同" class="headerlink" title="扩容方式与ArrayList不同"></a>扩容方式与ArrayList不同</h2><pre><code>默认是扩容两倍  可以通过构造方法创建对象时修改这一机制</code></pre><h1 id="Stack类-栈"><a href="#Stack类-栈" class="headerlink" title="Stack类 栈"></a>Stack类 栈</h1><h2 id="java-util包-1"><a href="#java-util包-1" class="headerlink" title="java.util包"></a>java.util包</h2><h2 id="构造方法只有一个无参数"><a href="#构造方法只有一个无参数" class="headerlink" title="构造方法只有一个无参数"></a>构造方法只有一个无参数</h2><h2 id="只有几个特殊的方法"><a href="#只有几个特殊的方法" class="headerlink" title="只有几个特殊的方法"></a>只有几个特殊的方法</h2><pre><code>push(E e)将某个元素压入栈顶（add()）
E = pop()将某一个元素从栈顶取出并删掉(E = remove())
E = peek()将某一个元素从栈顶取出并删除掉(E = remove())
boolean = empty()判断栈顶元素是否为空(isEmpty)
int = search()查找给定元素在栈中的位置(indexof())</code></pre><h2 id="中国象棋-悔棋"><a href="#中国象棋-悔棋" class="headerlink" title="中国象棋 悔棋"></a>中国象棋 悔棋</h2><pre><code>栈中存储每一次的操作步骤
撤销功能</code></pre><h1 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h1><h2 id="java-util"><a href="#java-util" class="headerlink" title="java.util"></a>java.util</h2><h3 id="通常子类-Linklist-ArrayQueque"><a href="#通常子类-Linklist-ArrayQueque" class="headerlink" title="通常子类 Linklist ArrayQueque"></a>通常子类 Linklist ArrayQueque</h3><h2 id="通常用无参构造方法实现"><a href="#通常用无参构造方法实现" class="headerlink" title="通常用无参构造方法实现"></a>通常用无参构造方法实现</h2><h2 id="一般方法"><a href="#一般方法" class="headerlink" title="一般方法"></a>一般方法</h2><pre><code>add()
element()-----&gt;get()
remove()
boolean = offer(E e);//相当于add  不会抛出异常
E = peek();//相当于element方法
E =poll; 剪短//相当于remove()</code></pre><h2 id="双十一秒杀"><a href="#双十一秒杀" class="headerlink" title="双十一秒杀"></a>双十一秒杀</h2><pre><code>所有进入秒杀系统的人存入队列</code></pre><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h1 id="Linklist类"><a href="#Linklist类" class="headerlink" title="Linklist类"></a>Linklist类</h1><h2 id="java-util包-2"><a href="#java-util包-2" class="headerlink" title="java.util包"></a>java.util包</h2><h3 id="自己封装过LinkBox-内部类Node-LT-T-GT-对象（节点-prev-item-next）"><a href="#自己封装过LinkBox-内部类Node-LT-T-GT-对象（节点-prev-item-next）" class="headerlink" title="自己封装过LinkBox 内部类Node&LT;T&GT;对象（节点 prev item next）"></a>自己封装过LinkBox 内部类Node&LT;T&GT;对象（节点 prev item next）</h3><h2 id="底层就是使用双向链表的数据结构形式来存储"><a href="#底层就是使用双向链表的数据结构形式来存储" class="headerlink" title="底层就是使用双向链表的数据结构形式来存储"></a>底层就是使用双向链表的数据结构形式来存储</h2><h3 id="适合插入或删除不适合遍历轮循"><a href="#适合插入或删除不适合遍历轮循" class="headerlink" title="适合插入或删除不适合遍历轮循"></a>适合插入或删除不适合遍历轮循</h3><h2 id="构建对象"><a href="#构建对象" class="headerlink" title="构建对象"></a>构建对象</h2><pre><code>无参构造方法 带参数的构造方法（collection）</code></pre><h2 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h2><pre><code>增删改查 add() remove() set() get() size()
手册中提供其他常用方法
addAll() addFirst() clear() contains()
element() getFirst() getLast() indexOf() lastindex()
....</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/24/JavaSE基础-（二十五）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我与我周旋">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一轮明月照九洲">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/24/JavaSE基础-（二十五）/" itemprop="url">JavaSE基础 （二十五）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-24T22:23:31+08:00">
                2020-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="集合相关"><a href="#集合相关" class="headerlink" title="集合相关"></a>集合相关</h1><h2 id="变量–容器"><a href="#变量–容器" class="headerlink" title="变量–容器"></a>变量–容器</h2><pre><code>存取一个元素</code></pre><h2 id="数组–容器"><a href="#数组–容器" class="headerlink" title="数组–容器"></a>数组–容器</h2><pre><code>一组具有某种特性的数据存放在一起
       存储一组元素（数据类型一致）  长度固定</code></pre><h2 id="集合–容器"><a href="#集合–容器" class="headerlink" title="集合–容器"></a>集合–容器</h2><pre><code>与数组类似 集合的长度存储之后还能改变
集合用来存储一组元素</code></pre><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><pre><code>存的都是value</code></pre><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><pre><code>有序可重复</code></pre><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><pre><code>无序无重复</code></pre><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><pre><code>存储的是以key-value形式存在
key无序无重复  value无序可重复</code></pre><h3 id="序：顺序"><a href="#序：顺序" class="headerlink" title="序：顺序"></a>序：顺序</h3><pre><code>添加进去的元素 取得元素的顺序一致 注意指的不是集合自己的顺序</code></pre><h3 id="重复：两个对象一致"><a href="#重复：两个对象一致" class="headerlink" title="重复：两个对象一致"></a>重复：两个对象一致</h3><h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><p>   1.ArrayList 2.LinkList 3.Vector</p>
<h3 id="ArrayList——-底层就是一个数组"><a href="#ArrayList——-底层就是一个数组" class="headerlink" title="ArrayList——-底层就是一个数组"></a>ArrayList——-底层就是一个数组</h3><h3 id="所属的包-java-util"><a href="#所属的包-java-util" class="headerlink" title="所属的包 java.util"></a>所属的包 java.util</h3><h3 id="如何创建对象"><a href="#如何创建对象" class="headerlink" title="如何创建对象"></a>如何创建对象</h3><pre><code>无参数构造方法 带默认参数的都构造方法 带collection参数的构造方法</code></pre><h3 id="常用的方法-—小容器"><a href="#常用的方法-—小容器" class="headerlink" title="常用的方法 —小容器"></a>常用的方法 —小容器</h3><pre><code>   存 add
   取 get
   删 remove
   改
   个数 size

add(E e) add(int index,E e)
addAll(Collection c); add(int index,Collection c)
clear();将集合内的元素全部清除
boolean = contains(Object);找寻一个给定元素集合中是否拥有
ensureCapacity(int minCapacity);
E = get(int index);
int = indexOf(Object obj); lastindexOf();
isEmpty();
iterator;//迭代器 1.5之后增强for
removeAll 差集 retainAll()交集
addAll()并集
E = set(int index,E value)
int size();
List = subList(int index,E value)
toArray();集合变成数组
toArray(T[]);
trimToSize();//变成有效元素个数那么长</code></pre><h3 id="arryList底层是一个Object"><a href="#arryList底层是一个Object" class="headerlink" title="arryList底层是一个Object[]"></a>arryList底层是一个Object[]</h3><pre><code>什么类型都可以存进去
取出来的时候多态效果 需要自己造型 显得用起来非常麻烦</code></pre><h3 id="JDK1-5之后—-gt-泛型"><a href="#JDK1-5之后—-gt-泛型" class="headerlink" title="JDK1.5之后—-&gt;泛型"></a>JDK1.5之后—-&gt;泛型</h3><pre><code>用来规定数据类型的,定义的时候用一个符号代替某种类型
在使用的时候具体的数据类型 将定义的那个符号替换掉
ArrayBox&lt;T&gt;</code></pre><h3 id="泛型可以用在哪里？"><a href="#泛型可以用在哪里？" class="headerlink" title="泛型可以用在哪里？"></a>泛型可以用在哪里？</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><pre><code>类定义的时候描述某种数据类型 集合就是这样使用</code></pre><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><pre><code>与泛型类的使用基本一致 子类实现接口时必须添加泛型
public interface Text&lt;X&gt;{
     public X value;
}
public class Son&lt;X&gt;implements Test&lt;X&gt;</code></pre><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><pre><code>方法调用时传参数 方法的泛型与类无关 带有泛型的方法可以不放在带有泛型的类中</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="我与我周旋">
            
              <p class="site-author-name" itemprop="name">我与我周旋</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/BydHorizon" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="921742277@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-globe"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">我与我周旋</span>

  
</div>

<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>

-->

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


<!--
  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>



-->

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共27.2k字</span>
</div>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  



  










  





  

  

  

  
  

  

  

  

  <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
<!-- 背景动画 -->
<script type="text/javascript" src="/js/src/particle.js"></script>

</body>
</html>
