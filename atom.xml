<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一轮明月照九洲</title>
  
  <subtitle>长将静趣观天地，自有幽怀契古今</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-09T10:00:08.702Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>我与我周旋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用户指南</title>
    <link href="http://yoursite.com/2020/07/09/%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2020/07/09/用户指南/</id>
    <published>2020-07-09T09:59:54.000Z</published>
    <updated>2020-07-09T10:00:08.702Z</updated>
    
    <content type="html"><![CDATA[<p>用户指南</p><p>一．系统说明：</p><p> “船舶靠港选择系统”旨在为船舶提供最优靠港方案。航运行业的迅速发展让航运公司与船舶之间的竞争日夜激烈，用户需求的多样化也直接影响着船舶靠港选择，在一定区域范围内的港口可以根据需求不同选择最合适的停靠港口。该系统可以根据用户输入的不同权重信息为船舶规划出三条航线，船长根据需求从中选择最佳的靠港方案。该系统主要功能就在于根据不同权重因子为船舶提供有选择性的最佳靠港方案，为船舶提供信息服务，也为部分港口增加收益。包括三个模块用户信息管理功能、港口收费计费功能和显示页面功能。</p><p>二．使用说明</p><p>（1）  登录界面</p><p>用户进入登录界面以后，首先需要注册用户名与输入密码，每个用户拥有唯一的登录账号，便于开发人员信息的管理与维护。拥有账号以后可选择登录进入系统也可选择取消退出系统。</p><p>（2）  收费计费系统</p><p>用户通过账号进入系统后，进入收费计费系统。收费计费系统具有三个子模块，三个子模块的功能分别是工具箱、数据编辑与货物信息。</p><ol><li><p>工具箱具有基本操作模块、专业功能模块、主题模块、用户管理模块和开发者选项模块。基本操作模块具体包括：放大（点击放大按钮系统会按比例相应的放大地图）、缩小（点击缩小按钮系统按比例缩小地图）、漫游（点击漫游按钮移动鼠标时地图会与鼠标联动）、全图显示（点击全图显示按钮系统恢复初始页面）、地图刷新（点击地图刷新按钮系统会将地图更新）、前一视图（点击按钮系统会返回上一视图）、后一视图（点击后一视图按钮系统会回到相对的下一视图）、打开地图（点击按钮可以打开新的地图）、识别查询（点击按钮系统会跳出相应港口的具体信息）、比例尺（显示当前地图的比例尺信息）。专业功能模块具体包括：信息查询（根据输入的信息查询港口）、鹰眼图（在显示系统的右上角显示鹰眼图，鹰眼图包括整个地图可以与鼠标联动）。用户根据喜好手动选择主题形式，有经典模式、商务模式、时尚模式三种类型。用户管理中，用户可以修改密码和注销当前账户。开发者选项具体包括帮助指南（用户使用系统的指南）、可以给开发者打赏、可以检测当前系统版本、可以升级系统更新版本。</p></li><li><p>数据编辑页面</p></li><li><p>货物信息页面具有两个子功能，分别为创建新的订单与货物信息。点击创建新的订单，系统会跳出建立货运订单窗口，用户根据要求输入相应的新订单信息点击完成即可创建成功，成功以后的订单信息会自动导入数据库与货物信息中。</p></li></ol><p>（3）  显示系统</p><p>系统根据用户输入的权重因子为船舶提供三种靠港方案。用户根据需求选择一种最佳方案与航线并显示在当前屏幕上。</p><p>三．系统维护</p><p>开发者按时按需对系统进行维护与更新，保证数据库的维护更新系统的运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用户指南&lt;/p&gt;
&lt;p&gt;一．系统说明：&lt;/p&gt;
&lt;p&gt; “船舶靠港选择系统”旨在为船舶提供最优靠港方案。航运行业的迅速发展让航运公司与船舶之间的竞争日夜激烈，用户需求的多样化也直接影响着船舶靠港选择，在一定区域范围内的港口可以根据需求不同选择最合适的停靠港口。该系统可以根据
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL连接VS 2010</title>
    <link href="http://yoursite.com/2020/06/30/MySQL%E8%BF%9E%E6%8E%A5VS-2010/"/>
    <id>http://yoursite.com/2020/06/30/MySQL连接VS-2010/</id>
    <published>2020-06-30T11:38:04.000Z</published>
    <updated>2020-06-30T12:20:11.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-中出现Unable-to-connect-to-any-of-the-specified-MySQL-hosts-这样的问题主要是因为server的值"><a href="#C-中出现Unable-to-connect-to-any-of-the-specified-MySQL-hosts-这样的问题主要是因为server的值" class="headerlink" title="C#中出现Unable to connect to any of the specified MySQL hosts.这样的问题主要是因为server的值"></a>C#中出现Unable to connect to any of the specified MySQL hosts.这样的问题主要是因为server的值</h2><h2 id="server的值应该是localhost而不是-local"><a href="#server的值应该是localhost而不是-local" class="headerlink" title="server的值应该是localhost而不是(local)"></a>server的值应该是localhost而不是(local)</h2><h1 id="首先需要安装-net连接mysql的驱动，去http-www-mysql-com-downloads-connector-net-下载并安装1-8版本以下的。"><a href="#首先需要安装-net连接mysql的驱动，去http-www-mysql-com-downloads-connector-net-下载并安装1-8版本以下的。" class="headerlink" title="首先需要安装.net连接mysql的驱动，去http://www.mysql.com/downloads/connector/net/下载并安装1.8版本以下的。"></a>首先需要安装.net连接mysql的驱动，去<a href="http://www.mysql.com/downloads/connector/net/下载并安装1.8版本以下的。" target="_blank" rel="noopener">http://www.mysql.com/downloads/connector/net/下载并安装1.8版本以下的。</a></h1><h2 id="然后你就可以在vs的server-explorer添加连接了。"><a href="#然后你就可以在vs的server-explorer添加连接了。" class="headerlink" title="然后你就可以在vs的server explorer添加连接了。"></a>然后你就可以在vs的server explorer添加连接了。</h2><h2 id="然后连接上数据库后一定要添加引用啊"><a href="#然后连接上数据库后一定要添加引用啊" class="headerlink" title="然后连接上数据库后一定要添加引用啊"></a>然后连接上数据库后一定要添加引用啊</h2><h2 id="首先还要在刚才的网站下载zip文件-进行把mysql-data-dll-添加到引用"><a href="#首先还要在刚才的网站下载zip文件-进行把mysql-data-dll-添加到引用" class="headerlink" title="首先还要在刚才的网站下载zip文件 进行把mysql.data.dll 添加到引用"></a>首先还要在刚才的网站下载zip文件 进行把mysql.data.dll 添加到引用</h2><h2 id="最后-直接引用-using-MySql-Data-MySqlClient"><a href="#最后-直接引用-using-MySql-Data-MySqlClient" class="headerlink" title="最后 直接引用 using MySql.Data.MySqlClient;"></a>最后 直接引用 using MySql.Data.MySqlClient;</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;C-中出现Unable-to-connect-to-any-of-the-specified-MySQL-hosts-这样的问题主要是因为server的值&quot;&gt;&lt;a href=&quot;#C-中出现Unable-to-connect-to-any-of-the-specif
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL (四)</title>
    <link href="http://yoursite.com/2020/04/22/MySQL-%E5%9B%9B/"/>
    <id>http://yoursite.com/2020/04/22/MySQL-四/</id>
    <published>2020-04-22T13:12:25.000Z</published>
    <updated>2020-04-22T13:14:08.032Z</updated>
    
    <content type="html"><![CDATA[<p> 多表查询</p><p> 事务</p><p> DCL</p><h2 id="多表查询："><a href="#多表查询：" class="headerlink" title="多表查询："></a>多表查询：</h2><pre><code>* 查询语法：    select        列名列表    from        表名列表    where....* 准备sql    # 创建部门表    CREATE TABLE dept(        id INT PRIMARY KEY AUTO_INCREMENT,        NAME VARCHAR(20)    );    INSERT INTO dept (NAME) VALUES (&apos;开发部&apos;),(&apos;市场部&apos;),(&apos;财务部&apos;);    # 创建员工表    CREATE TABLE emp (        id INT PRIMARY KEY AUTO_INCREMENT,        NAME VARCHAR(10),        gender CHAR(1), -- 性别        salary DOUBLE, -- 工资        join_date DATE, -- 入职日期        dept_id INT,        FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键)    );    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;孙悟空&apos;,&apos;男&apos;,7200,&apos;2013-02-24&apos;,1);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;猪八戒&apos;,&apos;男&apos;,3600,&apos;2010-12-02&apos;,2);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;唐僧&apos;,&apos;男&apos;,9000,&apos;2008-08-08&apos;,2);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;白骨精&apos;,&apos;女&apos;,5000,&apos;2015-10-07&apos;,3);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;蜘蛛精&apos;,&apos;女&apos;,4500,&apos;2011-03-14&apos;,1);* 笛卡尔积：    * 有两个集合A,B .取这两个集合的所有组成情况。    * 要完成多表查询，需要消除无用的数据* 多表查询的分类：    1. 内连接查询：        1. 隐式内连接：使用where条件消除无用数据            * 例子：            -- 查询所有员工信息和对应的部门信息            SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;            -- 查询员工表的名称，性别。部门表的名称            SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;            SELECT                 t1.name, -- 员工表的姓名                t1.gender,-- 员工表的性别                t2.name -- 部门表的名称            FROM                emp t1,                dept t2            WHERE                 t1.`dept_id` = t2.`id`;        2. 显式内连接：            * 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件            * 例如：                * SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;                    * SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`;            3. 内连接查询：            1. 从哪些表中查询数据            2. 条件是什么            3. 查询哪些字段    2. 外链接查询：        1. 左外连接：            * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；            * 查询的是左表所有数据以及其交集部分。            * 例子：                -- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称                SELECT     t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`;        2. 右外连接：            * 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；            * 查询的是右表所有数据以及其交集部分。            * 例子：                SELECT     * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`;    3. 子查询：        * 概念：查询中嵌套查询，称嵌套查询为子查询。            -- 查询工资最高的员工信息            -- 1 查询最高的工资是多少 9000            SELECT MAX(salary) FROM emp;            -- 2 查询员工信息，并且工资等于9000的            SELECT * FROM emp WHERE emp.`salary` = 9000;            -- 一条sql就完成这个操作。子查询            SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);        * 子查询不同情况            1. 子查询的结果是单行单列的：                * 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =                *                 -- 查询员工工资小于平均工资的人                SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);            2. 子查询的结果是多行单列的：                * 子查询可以作为条件，使用运算符in来判断                -- 查询&apos;财务部&apos;和&apos;市场部&apos;所有的员工信息                SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;;                SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;                -- 子查询                SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;);            3. 子查询的结果是多行多列的：                * 子查询可以作为一张虚拟表参与查询                -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息                -- 子查询                SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &apos;2011-11-11&apos;) t2                WHERE t1.id = t2.dept_id;                -- 普通内连接                SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt;  &apos;2011-11-11&apos;    * 多表查询练习            -- 部门表            CREATE TABLE dept (              id INT PRIMARY KEY PRIMARY KEY, -- 部门id              dname VARCHAR(50), -- 部门名称              loc VARCHAR(50) -- 部门所在地            );            -- 添加4个部门            INSERT INTO dept(id,dname,loc) VALUES             (10,&apos;教研部&apos;,&apos;北京&apos;),            (20,&apos;学工部&apos;,&apos;上海&apos;),            (30,&apos;销售部&apos;,&apos;广州&apos;),            (40,&apos;财务部&apos;,&apos;深圳&apos;);            -- 职务表，职务名称，职务描述            CREATE TABLE job (              id INT PRIMARY KEY,              jname VARCHAR(20),              description VARCHAR(50)            );            -- 添加4个职务            INSERT INTO job (id, jname, description) VALUES            (1, &apos;董事长&apos;, &apos;管理整个公司，接单&apos;),            (2, &apos;经理&apos;, &apos;管理部门员工&apos;),            (3, &apos;销售员&apos;, &apos;向客人推销产品&apos;),            (4, &apos;文员&apos;, &apos;使用办公软件&apos;);            -- 员工表            CREATE TABLE emp (              id INT PRIMARY KEY, -- 员工id              ename VARCHAR(50), -- 员工姓名              job_id INT, -- 职务id              mgr INT , -- 上级领导              joindate DATE, -- 入职日期              salary DECIMAL(7,2), -- 工资              bonus DECIMAL(7,2), -- 奖金              dept_id INT, -- 所在部门编号              CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),              CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)            );            -- 添加员工            INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES             (1001,&apos;孙悟空&apos;,4,1004,&apos;2000-12-17&apos;,&apos;8000.00&apos;,NULL,20),            (1002,&apos;卢俊义&apos;,3,1006,&apos;2001-02-20&apos;,&apos;16000.00&apos;,&apos;3000.00&apos;,30),            (1003,&apos;林冲&apos;,3,1006,&apos;2001-02-22&apos;,&apos;12500.00&apos;,&apos;5000.00&apos;,30),            (1004,&apos;唐僧&apos;,2,1009,&apos;2001-04-02&apos;,&apos;29750.00&apos;,NULL,20),            (1005,&apos;李逵&apos;,4,1006,&apos;2001-09-28&apos;,&apos;12500.00&apos;,&apos;14000.00&apos;,30),            (1006,&apos;宋江&apos;,2,1009,&apos;2001-05-01&apos;,&apos;28500.00&apos;,NULL,30),            (1007,&apos;刘备&apos;,2,1009,&apos;2001-09-01&apos;,&apos;24500.00&apos;,NULL,10),            (1008,&apos;猪八戒&apos;,4,1004,&apos;2007-04-19&apos;,&apos;30000.00&apos;,NULL,20),            (1009,&apos;罗贯中&apos;,1,NULL,&apos;2001-11-17&apos;,&apos;50000.00&apos;,NULL,10),            (1010,&apos;吴用&apos;,3,1006,&apos;2001-09-08&apos;,&apos;15000.00&apos;,&apos;0.00&apos;,30),            (1011,&apos;沙僧&apos;,4,1004,&apos;2007-05-23&apos;,&apos;11000.00&apos;,NULL,20),            (1012,&apos;李逵&apos;,4,1006,&apos;2001-12-03&apos;,&apos;9500.00&apos;,NULL,30),            (1013,&apos;小白龙&apos;,4,1004,&apos;2001-12-03&apos;,&apos;30000.00&apos;,NULL,20),            (1014,&apos;关羽&apos;,4,1007,&apos;2002-01-23&apos;,&apos;13000.00&apos;,NULL,10);            -- 工资等级表            CREATE TABLE salarygrade (              grade INT PRIMARY KEY,   -- 级别              losalary INT,  -- 最低工资              hisalary INT -- 最高工资            );            -- 添加5个工资等级            INSERT INTO salarygrade(grade,losalary,hisalary) VALUES             (1,7000,12000),            (2,12010,14000),            (3,14010,20000),            (4,20010,30000),            (5,30010,99990);            -- 需求：            -- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述            /*                分析：                    1.员工编号，员工姓名，工资，需要查询emp表  职务名称，职务描述 需要查询job表                    2.查询条件 emp.job_id = job.id            */            SELECT                 t1.`id`, -- 员工编号                t1.`ename`, -- 员工姓名                t1.`salary`,-- 工资                t2.`jname`, -- 职务名称                t2.`description` -- 职务描述            FROM                 emp t1, job t2            WHERE                 t1.`job_id` = t2.`id`;            -- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置            /*                分析：                    1. 员工编号，员工姓名，工资 emp  职务名称，职务描述 job  部门名称，部门位置 dept                    2. 条件： emp.job_id = job.id and emp.dept_id = dept.id            */            SELECT                 t1.`id`, -- 员工编号                t1.`ename`, -- 员工姓名                t1.`salary`,-- 工资                t2.`jname`, -- 职务名称                t2.`description`, -- 职务描述                t3.`dname`, -- 部门名称                t3.`loc` -- 部门位置            FROM                 emp t1, job t2,dept t3            WHERE                 t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`;            -- 3.查询员工姓名，工资，工资等级            /*                分析：                    1.员工姓名，工资 emp  工资等级 salarygrade                    2.条件 emp.salary &gt;= salarygrade.losalary and emp.salary &lt;= salarygrade.hisalary                        emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary            */            SELECT                 t1.ename ,                t1.`salary`,                t2.*            FROM emp t1, salarygrade t2            WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;            -- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级            /*                分析：                    1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept  工资等级 salarygrade                    2. 条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary            */            SELECT                 t1.`ename`,                t1.`salary`,                t2.`jname`,                t2.`description`,                t3.`dname`,                t3.`loc`,                t4.`grade`            FROM                 emp t1,job t2,dept t3,salarygrade t4            WHERE                 t1.`job_id` = t2.`id`                 AND t1.`dept_id` = t3.`id`                AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`;            -- 5.查询出部门编号、部门名称、部门位置、部门人数            /*                分析：                    1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表                    2.使用分组查询。按照emp.dept_id完成分组，查询count(id)                    3.使用子查询将第2步的查询结果和dept表进行关联查询            */            SELECT                 t1.`id`,t1.`dname`,t1.`loc` , t2.total            FROM                 dept t1,                (SELECT                    dept_id,COUNT(id) total                FROM                     emp                GROUP BY dept_id) t2            WHERE t1.`id` = t2.dept_id;            -- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询            /*                分析：                    1.姓名 emp， 直接上级的姓名 emp                        * emp表的id 和 mgr 是自关联                    2.条件 emp.id = emp.mgr                    3.查询左表的所有数据，和 交集数据                        * 使用左外连接查询            */            /*            select                t1.ename,                t1.mgr,                t2.`id`,                t2.ename            from emp t1, emp t2            where t1.mgr = t2.`id`;            */            SELECT                 t1.ename,                t1.mgr,                t2.`id`,                t2.`ename`            FROM emp t1            LEFT JOIN emp t2            ON t1.`mgr` = t2.`id`;</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><pre><code>1. 事务的基本介绍    1. 概念：        *  如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。    2. 操作：        1. 开启事务： start transaction;        2. 回滚：rollback;        3. 提交：commit;    3. 例子：        CREATE TABLE account (            id INT PRIMARY KEY AUTO_INCREMENT,            NAME VARCHAR(10),            balance DOUBLE        );        -- 添加数据        INSERT INTO account (NAME, balance) VALUES (&apos;zhangsan&apos;, 1000), (&apos;lisi&apos;, 1000);        SELECT * FROM account;        UPDATE account SET balance = 1000;        -- 张三给李四转账 500 元        -- 0. 开启事务        START TRANSACTION;        -- 1. 张三账户 -500        UPDATE account SET balance = balance - 500 WHERE NAME = &apos;zhangsan&apos;;        -- 2. 李四账户 +500        -- 出错了...        UPDATE account SET balance = balance + 500 WHERE NAME = &apos;lisi&apos;;        -- 发现执行没有问题，提交事务        COMMIT;        -- 发现出问题了，回滚事务        ROLLBACK;    4. MySQL数据库中事务默认自动提交        * 事务提交的两种方式：            * 自动提交：                * mysql就是自动提交的                * 一条DML(增删改)语句会自动提交一次事务。            * 手动提交：                * Oracle 数据库默认是手动提交事务                * 需要先开启事务，再提交        * 修改事务的默认提交方式：            * 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交            * 修改默认提交方式： set @@autocommit = 0;2. 事务的四大特征：    1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。    2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。    3. 隔离性：多个事务之间。相互独立。    4. 一致性：事务操作前后，数据总量不变3. 事务的隔离级别（了解）    * 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。    * 存在问题：        1. 脏读：一个事务，读取到另一个事务中没有提交的数据        2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。        3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。    * 隔离级别：        1. read uncommitted：读未提交            * 产生的问题：脏读、不可重复读、幻读        2. read committed：读已提交 （Oracle）            * 产生的问题：不可重复读、幻读        3. repeatable read：可重复读 （MySQL默认）            * 产生的问题：幻读        4. serializable：串行化            * 可以解决所有的问题        * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低        * 数据库查询隔离级别：            * select @@tx_isolation;        * 数据库设置隔离级别：            * set global transaction isolation level  级别字符串;    * 演示：        set global transaction isolation level read uncommitted;        start transaction;        -- 转账操作        update account set balance = balance - 500 where id = 1;        update account set balance = balance + 500 where id = 2;</code></pre><h2 id="DCL："><a href="#DCL：" class="headerlink" title="DCL："></a>DCL：</h2><pre><code>* SQL分类：    1. DDL：操作数据库和表    2. DML：增删改表中数据    3. DQL：查询表中数据    4. DCL：管理用户，授权* DBA：数据库管理员* DCL：管理用户，授权    1. 管理用户        1. 添加用户：            * 语法：CREATE USER &apos;用户名&apos;@&apos;主机名&apos; IDENTIFIED BY &apos;密码&apos;;        2. 删除用户：            * 语法：DROP USER &apos;用户名&apos;@&apos;主机名&apos;;        3. 修改用户密码：            UPDATE USER SET PASSWORD = PASSWORD(&apos;新密码&apos;) WHERE USER = &apos;用户名&apos;;            UPDATE USER SET PASSWORD = PASSWORD(&apos;abc&apos;) WHERE USER = &apos;lisi&apos;;            SET PASSWORD FOR &apos;用户名&apos;@&apos;主机名&apos; = PASSWORD(&apos;新密码&apos;);            SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;123&apos;);            * mysql中忘记了root用户的密码？                1. cmd -- &gt; net stop mysql 停止mysql服务                    * 需要管理员运行该cmd                2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables                3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功                4. use mysql;                5. update user set password = password(&apos;你的新密码&apos;) where user = &apos;root&apos;;                6. 关闭两个窗口                7. 打开任务管理器，手动结束mysqld.exe 的进程                8. 启动mysql服务                9. 使用新密码登录。        4. 查询用户：            -- 1. 切换到mysql数据库            USE myql;            -- 2. 查询user表            SELECT * FROM USER;            * 通配符： % 表示可以在任意主机使用用户登录数据库    2. 权限管理：        1. 查询权限：            -- 查询权限            SHOW GRANTS FOR &apos;用户名&apos;@&apos;主机名&apos;;            SHOW GRANTS FOR &apos;lisi&apos;@&apos;%&apos;;        2. 授予权限：            -- 授予权限            grant 权限列表 on 数据库名.表名 to &apos;用户名&apos;@&apos;主机名&apos;;            -- 给张三用户授予所有权限，在任意数据库任意表上            GRANT ALL ON *.* TO &apos;zhangsan&apos;@&apos;localhost&apos;;        3. 撤销权限：            -- 撤销权限：            revoke 权限列表 on 数据库名.表名 from &apos;用户名&apos;@&apos;主机名&apos;;            REVOKE UPDATE ON db3.`account` FROM &apos;lisi&apos;@&apos;%&apos;;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 多表查询&lt;/p&gt;
&lt;p&gt; 事务&lt;/p&gt;
&lt;p&gt; DCL&lt;/p&gt;
&lt;h2 id=&quot;多表查询：&quot;&gt;&lt;a href=&quot;#多表查询：&quot; class=&quot;headerlink&quot; title=&quot;多表查询：&quot;&gt;&lt;/a&gt;多表查询：&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;* 查询语法：
    se
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL (三)</title>
    <link href="http://yoursite.com/2020/04/16/MySQL-%E4%B8%89/"/>
    <id>http://yoursite.com/2020/04/16/MySQL-三/</id>
    <published>2020-04-16T13:46:59.000Z</published>
    <updated>2020-04-16T13:51:29.809Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>DQL:查询语句</p><pre><code>1. 排序查询2. 聚合函数3. 分组查询4. 分页查询</code></pre><ol start="2"><li>约束</li><li>多表之间的关系</li><li>范式</li><li>数据库的备份和还原</li></ol></li></ol><h1 id="DQL-查询语句"><a href="#DQL-查询语句" class="headerlink" title="DQL:查询语句"></a>DQL:查询语句</h1><pre><code>1. 排序查询    * 语法：order by 子句        * order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...    * 排序方式：        * ASC：升序，默认的。        * DESC：降序。    * 注意：        * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。2. 聚合函数：将一列数据作为一个整体，进行纵向的计算。    1. count：计算个数        1. 一般选择非空的列：主键        2. count(*)    2. max：计算最大值    3. min：计算最小值    4. sum：计算和    5. avg：计算平均值    * 注意：聚合函数的计算，排除null值。        解决方案：            1. 选择不包含非空的列进行计算            2. IFNULL函数3. 分组查询:    1. 语法：group by 分组字段；    2. 注意：        1. 分组之后查询的字段：分组字段、聚合函数        2. where 和 having 的区别？            1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来            2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。        -- 按照性别分组。分别查询男、女同学的平均分        SELECT sex , AVG(math) FROM student GROUP BY sex;        -- 按照性别分组。分别查询男、女同学的平均分,人数        SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;        --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;        --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;        SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2;4. 分页查询    1. 语法：limit 开始的索引,每页查询的条数;    2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数        -- 每页显示3条记录         SELECT * FROM student LIMIT 0,3; -- 第1页        SELECT * FROM student LIMIT 3,3; -- 第2页        SELECT * FROM student LIMIT 6,3; -- 第3页    3. limit 是一个MySQL&quot;方言&quot;</code></pre><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><pre><code>* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。    * 分类：    1. 主键约束：primary key    2. 非空约束：not null    3. 唯一约束：unique    4. 外键约束：foreign key* 非空约束：not null，值不能为null    1. 创建表时添加约束        CREATE TABLE stu(            id INT,            NAME VARCHAR(20) NOT NULL -- name为非空        );    2. 创建表完后，添加非空约束        ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;    3. 删除name的非空约束        ALTER TABLE stu MODIFY NAME VARCHAR(20);* 唯一约束：unique，值不能重复    1. 创建表时，添加唯一约束        CREATE TABLE stu(            id INT,            phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束        );        * 注意mysql中，唯一约束限定的列的值可以有多个null    2. 删除唯一约束        ALTER TABLE stu DROP INDEX phone_number;    3. 在创建表后，添加唯一约束        ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;* 主键约束：primary key。    1. 注意：        1. 含义：非空且唯一        2. 一张表只能有一个字段为主键        3. 主键就是表中记录的唯一标识    2. 在创建表时，添加主键约束        create table stu(            id int primary key,-- 给id添加主键约束            name varchar(20)        );    3. 删除主键        -- 错误 alter table stu modify id int ;        ALTER TABLE stu DROP PRIMARY KEY;    4. 创建完表后，添加主键        ALTER TABLE stu MODIFY id INT PRIMARY KEY;    5. 自动增长：        1.  概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长        2. 在创建表时，添加主键约束，并且完成主键自增长        create table stu(            id int primary key auto_increment,-- 给id添加主键约束            name varchar(20)        );        3. 删除自动增长        ALTER TABLE stu MODIFY id INT;        4. 添加自动增长        ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。    1. 在创建表时，可以添加外键        * 语法：            create table 表名(                ....                外键列                constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)            );    2. 删除外键        ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;    3. 创建表之后，添加外键        ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);    4. 级联操作        1. 添加级联操作            语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称                     FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;        2. 分类：            1. 级联更新：ON UPDATE CASCADE             2. 级联删除：ON DELETE CASCADE </code></pre><h2 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h2><pre><code>1. 多表之间的关系    1. 分类：        1. 一对一(了解)：            * 如：人和身份证            * 分析：一个人只有一个身份证，一个身份证只能对应一个人        2. 一对多(多对一)：            * 如：部门和员工            * 分析：一个部门有多个员工，一个员工只能对应一个部门        3. 多对多：            * 如：学生和课程            * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择    2. 实现关系：        1. 一对多(多对一)：            * 如：部门和员工            * 实现方式：在多的一方建立外键，指向一的一方的主键。        2. 多对多：            * 如：学生和课程            * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键        3. 一对一(了解)：            * 如：人和身份证            * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。    3. 案例        -- 创建旅游线路分类表 tab_category        -- cid 旅游线路分类主键，自动增长        -- cname 旅游线路分类名称非空，唯一，字符串 100        CREATE TABLE tab_category (            cid INT PRIMARY KEY AUTO_INCREMENT,            cname VARCHAR(100) NOT NULL UNIQUE        );        -- 创建旅游线路表 tab_route        /*        rid 旅游线路主键，自动增长        rname 旅游线路名称非空，唯一，字符串 100        price 价格        rdate 上架时间，日期类型        cid 外键，所属分类        */        CREATE TABLE tab_route(            rid INT PRIMARY KEY AUTO_INCREMENT,            rname VARCHAR(100) NOT NULL UNIQUE,            price DOUBLE,            rdate DATE,            cid INT,            FOREIGN KEY (cid) REFERENCES tab_category(cid)        );        /*创建用户表 tab_user        uid 用户主键，自增长        username 用户名长度 100，唯一，非空        password 密码长度 30，非空        name 真实姓名长度 100        birthday 生日        sex 性别，定长字符串 1        telephone 手机号，字符串 11        email 邮箱，字符串长度 100        */        CREATE TABLE tab_user (            uid INT PRIMARY KEY AUTO_INCREMENT,            username VARCHAR(100) UNIQUE NOT NULL,            PASSWORD VARCHAR(30) NOT NULL,            NAME VARCHAR(100),            birthday DATE,            sex CHAR(1) DEFAULT &apos;男&apos;,            telephone VARCHAR(11),            email VARCHAR(100)        );        /*        创建收藏表 tab_favorite        rid 旅游线路 id，外键        date 收藏时间        uid 用户 id，外键        rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次        */        CREATE TABLE tab_favorite (            rid INT, -- 线路id            DATE DATETIME,            uid INT, -- 用户id            -- 创建复合主键            PRIMARY KEY(rid,uid), -- 联合主键            FOREIGN KEY (rid) REFERENCES tab_route(rid),            FOREIGN KEY(uid) REFERENCES tab_user(uid)        );2. 数据库设计的范式    * 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求        设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。        目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。    * 分类：        1. 第一范式（1NF）：每一列都是不可分割的原子数据项        2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）            * 几个概念：                1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A                    例如：学号--&gt;姓名。  （学号，课程名称） --&gt; 分数                2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。                    例如：（学号，课程名称） --&gt; 分数                3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。                    例如：（学号，课程名称） -- &gt; 姓名                4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A                    例如：学号--&gt;系名，系名--&gt;系主任                5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码                    例如：该表中码为：（学号，课程名称）                    * 主属性：码属性组中的所有属性                    * 非主属性：除过码属性组的属性        3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</code></pre><h2 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h2><pre><code>1. 命令行：    * 语法：        * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径        * 还原：            1. 登录数据库            2. 创建数据库            3. 使用数据库            4. 执行文件。source 文件路径2. 图形化工具：</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;DQL:查询语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 排序查询
2. 聚合函数
3. 分组查询
4. 分页查询&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;约束&lt;/li&gt;
&lt;li&gt;多表之间的关系&lt;/li&gt;
&lt;li&gt;范式&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL   (二)</title>
    <link href="http://yoursite.com/2020/04/10/MySQL-%E4%BA%8C/"/>
    <id>http://yoursite.com/2020/04/10/MySQL-二/</id>
    <published>2020-04-10T06:17:35.000Z</published>
    <updated>2020-04-10T06:20:11.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DQL：查询表中的记录"><a href="#DQL：查询表中的记录" class="headerlink" title="DQL：查询表中的记录"></a>DQL：查询表中的记录</h1><pre><code>* select * from 表名;</code></pre><h1 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h1><pre><code>select    字段列表from    表名列表where    条件列表group by    分组字段having    分组之后的条件order by    排序limit    分页限定</code></pre><h1 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h1><pre><code>1. 多个字段的查询    select 字段名1，字段名2... from 表名；    * 注意：        * 如果查询所有字段，则可以使用*来替代字段列表。2. 去除重复：    * distinct3. 计算列    * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）    * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null        * 表达式1：哪个字段需要判断是否为null        * 如果该字段为null后的替换值。4. 起别名：    * as：as也可以省略</code></pre><h1 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h1><pre><code>1. where子句后跟条件2. 运算符    * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;    * BETWEEN...AND      * IN( 集合)     * LIKE：模糊查询        * 占位符：            * _:单个任意字符            * %：多个任意字符    * IS NULL      * and  或 &amp;&amp;    * or  或 ||     * not  或 !        -- 查询年龄大于20岁        SELECT * FROM student WHERE age &gt; 20;        SELECT * FROM student WHERE age &gt;= 20;        -- 查询年龄等于20岁        SELECT * FROM student WHERE age = 20;        -- 查询年龄不等于20岁        SELECT * FROM student WHERE age != 20;        SELECT * FROM student WHERE age &lt;&gt; 20;        -- 查询年龄大于等于20 小于等于30        SELECT * FROM student WHERE age &gt;= 20 &amp;&amp;  age &lt;=30;        SELECT * FROM student WHERE age &gt;= 20 AND  age &lt;=30;        SELECT * FROM student WHERE age BETWEEN 20 AND 30;        -- 查询年龄22岁，18岁，25岁的信息        SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25        SELECT * FROM student WHERE age IN (22,18,25);        -- 查询英语成绩为null        SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断        SELECT * FROM student WHERE english IS NULL;        -- 查询英语成绩不为null        SELECT * FROM student WHERE english  IS NOT NULL;        -- 查询姓马的有哪些？ like        SELECT * FROM student WHERE NAME LIKE &apos;马%&apos;;        -- 查询姓名第二个字是化的人        SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;        -- 查询姓名是3个字的人        SELECT * FROM student WHERE NAME LIKE &apos;___&apos;;        -- 查询姓名中包含德的人        SELECT * FROM student WHERE NAME LIKE &apos;%德%&apos;;</code></pre><h1 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h1><pre><code>* 语法：order by 子句    * order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...* 排序方式：    * ASC：升序，默认的。    * DESC：降序。* 注意：    * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。</code></pre><h1 id="聚合函数：将一列数据作为一个整体，进行纵向的计算。"><a href="#聚合函数：将一列数据作为一个整体，进行纵向的计算。" class="headerlink" title="聚合函数：将一列数据作为一个整体，进行纵向的计算。"></a>聚合函数：将一列数据作为一个整体，进行纵向的计算。</h1><pre><code>1. count：计算个数    1. 一般选择非空的列：主键    2. count(*)2. max：计算最大值3. min：计算最小值4. sum：计算和5. avg：计算平均值* 注意：聚合函数的计算，排除null值。    解决方案：        1. 选择不包含非空的列进行计算        2. IFNULL函数</code></pre><h1 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询:"></a>分组查询:</h1><pre><code>1. 语法：group by 分组字段；2. 注意：    1. 分组之后查询的字段：分组字段、聚合函数    2. where 和 having 的区别？        1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来        2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。    -- 按照性别分组。分别查询男、女同学的平均分    SELECT sex , AVG(math) FROM student GROUP BY sex;    -- 按照性别分组。分别查询男、女同学的平均分,人数    SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;    --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组    SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;    --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人    SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;    SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2;</code></pre><h1 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h1><pre><code>1. 语法：limit 开始的索引,每页查询的条数;2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数    -- 每页显示3条记录     SELECT * FROM student LIMIT 0,3; -- 第1页    SELECT * FROM student LIMIT 3,3; -- 第2页    SELECT * FROM student LIMIT 6,3; -- 第3页3. limit 是一个MySQL&quot;方言&quot;                </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DQL：查询表中的记录&quot;&gt;&lt;a href=&quot;#DQL：查询表中的记录&quot; class=&quot;headerlink&quot; title=&quot;DQL：查询表中的记录&quot;&gt;&lt;/a&gt;DQL：查询表中的记录&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;* select * from 表名;&lt;/code&gt;
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL（一）</title>
    <link href="http://yoursite.com/2020/04/01/MySQL%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/04/01/MySQL（一）/</id>
    <published>2020-04-01T00:30:35.000Z</published>
    <updated>2020-04-01T00:35:22.192Z</updated>
    
    <content type="html"><![CDATA[<ol><li>数据库的基本概念</li></ol><ol start="2"><li><p>MySQL数据库软件</p><ol><li>安装</li><li>卸载</li><li>配置</li></ol></li><li><p>SQL</p></li></ol><h2 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h2><pre><code>1. 数据库的英文单词： DataBase 简称 ： DB2. 什么数据库？    * 用于存储和管理数据的仓库。3. 数据库的特点：    1. 持久化存储数据的。其实数据库就是一个文件系统    2. 方便存储和管理数据    3. 使用了统一的方式操作数据库 -- SQL4. 常见的数据库软件    * 参见《MySQL基础.pdf》</code></pre><h1 id="MySQL数据库软件"><a href="#MySQL数据库软件" class="headerlink" title="MySQL数据库软件"></a>MySQL数据库软件</h1><pre><code>1. 安装    * 参见《MySQL基础.pdf》2. 卸载    1. 去mysql的安装目录找到my.ini文件        * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;    2. 卸载MySQL    3. 删除C:/ProgramData目录下的MySQL文件夹。3. 配置    * MySQL服务启动        1. 手动。        2. cmd--&gt; services.msc 打开服务的窗口        3. 使用管理员打开cmd            * net start mysql : 启动mysql的服务            * net stop mysql:关闭mysql服务    * MySQL登录        1. mysql -uroot -p密码        2. mysql -hip -uroot -p连接目标的密码        3. mysql --host=ip --user=root --password=连接目标的密码    * MySQL退出        1. exit        2. quit    * MySQL目录结构        1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot;            * 配置文件 my.ini        2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;            * 几个概念                * 数据库：文件夹                * 表：文件                * 数据：数据</code></pre><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><pre><code>1.什么是SQL？    Structured Query Language：结构化查询语言    其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。2.SQL通用语法    1. SQL 语句可以单行或多行书写，以分号结尾。    2. 可使用空格和缩进来增强语句的可读性。    3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。    4. 3 种注释        * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有)         * 多行注释: /* 注释 */3. SQL分类    1) DDL(Data Definition Language)数据定义语言        用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等    2) DML(Data Manipulation Language)数据操作语言        用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等    3) DQL(Data Query Language)数据查询语言        用来查询数据库中表的记录(数据)。关键字：select, where 等    4) DCL(Data Control Language)数据控制语言(了解)        用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</code></pre><h2 id="DDL-操作数据库、表"><a href="#DDL-操作数据库、表" class="headerlink" title="DDL:操作数据库、表"></a>DDL:操作数据库、表</h2><pre><code>1. 操作数据库：CRUD    1. C(Create):创建        * 创建数据库：            * create database 数据库名称;        * 创建数据库，判断不存在，再创建：            * create database if not exists 数据库名称;        * 创建数据库，并指定字符集            * create database 数据库名称 character set 字符集名;        * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk            * create database if not exists db4 character set gbk;    2. R(Retrieve)：查询        * 查询所有数据库的名称:            * show databases;        * 查询某个数据库的字符集:查询某个数据库的创建语句            * show create database 数据库名称;    3. U(Update):修改        * 修改数据库的字符集            * alter database 数据库名称 character set 字符集名称;    4. D(Delete):删除        * 删除数据库            * drop database 数据库名称;        * 判断数据库存在，存在再删除            * drop database if exists 数据库名称;    5. 使用数据库        * 查询当前正在使用的数据库名称            * select database();        * 使用数据库            * use 数据库名称;2. 操作表    1. C(Create):创建        1. 语法：            create table 表名(                列名1 数据类型1,                列名2 数据类型2,                ....                列名n 数据类型n            );            * 注意：最后一列，不需要加逗号（,）            * 数据库类型：                1. int：整数类型                    * age int,                2. double:小数类型                    * score double(5,2)                3. date:日期，只包含年月日，yyyy-MM-dd                4. datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss                5. timestamp:时间错类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss                        * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值                6. varchar：字符串                    * name varchar(20):姓名最大20个字符                    * zhangsan 8个字符  张三 2个字符        * 创建表            create table student(                id int,                name varchar(32),                age int ,                score double(4,1),                birthday date,                insert_time timestamp            );        * 复制表：            * create table 表名 like 被复制的表名;              2. R(Retrieve)：查询        * 查询某个数据库中所有的表名称            * show tables;        * 查询表结构            * desc 表名;    3. U(Update):修改        1. 修改表名            alter table 表名 rename to 新的表名;        2. 修改表的字符集            alter table 表名 character set 字符集名称;        3. 添加一列            alter table 表名 add 列名 数据类型;        4. 修改列名称 类型            alter table 表名 change 列名 新列别 新数据类型;            alter table 表名 modify 列名 新数据类型;        5. 删除列            alter table 表名 drop 列名;    4. D(Delete):删除        * drop table 表名;        * drop table  if exists 表名 ;</code></pre><ul><li>客户端图形化工具：SQLYog</li></ul><h2 id="DML：增删改表中数据"><a href="#DML：增删改表中数据" class="headerlink" title="DML：增删改表中数据"></a>DML：增删改表中数据</h2><pre><code>1. 添加数据：    * 语法：        * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);    * 注意：        1. 列名和值要一一对应。        2. 如果表名后，不定义列名，则默认给所有列添加值            insert into 表名 values(值1,值2,...值n);        3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来2. 删除数据：    * 语法：        * delete from 表名 [where 条件]    * 注意：        1. 如果不加条件，则删除表中所有记录。        2. 如果要删除所有记录            1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作            2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。3. 修改数据：    * 语法：        * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];    * 注意：        1. 如果不加任何条件，则会将表中所有记录全部修改。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;数据库的基本概念&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;p&gt;MySQL数据库软件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装&lt;/li&gt;
&lt;li&gt;卸载&lt;/li&gt;
&lt;li&gt;配置&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SQL&lt;/p&gt;
&lt;/li&gt;

      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础  （三十五）</title>
    <link href="http://yoursite.com/2020/03/30/avaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%94%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/30/avaSE基础-（三十五）/</id>
    <published>2020-03-30T12:20:01.000Z</published>
    <updated>2020-03-31T01:03:53.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li>软件架构CS／BS</li><li>网络通信三要素</li><li>TCP通信</li><li>Socket套接字</li><li>ServerSocket</li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><input disabled type="checkbox"> 能够辨别UDP和TCP协议特点</li><li><input disabled type="checkbox"> 能够说出TCP协议下两个常用类名称</li><li><input disabled type="checkbox"> 能够编写TCP协议下字符串数据传输程序</li><li><input disabled type="checkbox"> 能够理解TCP协议下文件上传案例</li><li><input disabled type="checkbox"> 能够理解TCP协议下案例2</li></ul><h1 id="第一章-网络编程入门"><a href="#第一章-网络编程入门" class="headerlink" title="第一章 网络编程入门"></a>第一章 网络编程入门</h1><h2 id="1-1软件结构"><a href="#1-1软件结构" class="headerlink" title="1.1软件结构"></a>1.1软件结构</h2><ul><li><strong>C/S结构</strong> ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。</li></ul><p><img src="/2020/03/30/avaSE基础-（三十五）/1_cs.jpg" alt></p><p><strong>B/S结构</strong> ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</p><p><img src="/2020/03/30/avaSE基础-（三十五）/2_bs.jpg" alt></p><p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p><h2 id="1-2-网络通信协议"><a href="#1-2-网络通信协议" class="headerlink" title="1.2 网络通信协议"></a>1.2 网络通信协议</h2><ul><li><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</li></ul><ul><li><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</li></ul><p><img src="/2020/03/30/avaSE基础-（三十五）/3_tcp_ip.jpg" alt></p><p>上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</p><h2 id="1-3-协议分类"><a href="#1-3-协议分类" class="headerlink" title="1.3 协议分类"></a>1.3 协议分类</h2><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p><p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p><ul><li><p><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p><p>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p><p>但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。</p></li></ul><p><img src="/2020/03/30/avaSE基础-（三十五）/img%5CUDP%E9%80%9A%E4%BF%A1%E5%9B%BE%E8%A7%A3.bmp" alt="UDP通信图解"></p><p>特点:数据被限制在64kb以内，超出这个范围就不能发送了。</p><p>数据报(Datagram):网络传输的基本单位 </p><ul><li><p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p><p>在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p><ul><li>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。<ul><li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。</li><li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。</li><li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。</li></ul></li></ul></li></ul><p><img src="/2020/03/30/avaSE基础-（三十五）/4_tcp.jpg" alt></p><p>​    完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p><h2 id="1-4-网络编程三要素"><a href="#1-4-网络编程三要素" class="headerlink" title="1.4 网络编程三要素"></a>1.4 网络编程三要素</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul><li><strong>协议：</strong>计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。</li></ul><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul><li><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</li></ul><p><strong>IP地址分类</strong></p><ul><li><p>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p></li><li><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。</p><p>为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p></li></ul><p><strong>常用命令</strong></p><ul><li>查看本机IP地址，在控制台输入：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure><ul><li>检查网络是否连通，在控制台输入：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping 空格 IP地址</span><br><span class="line">ping <span class="number">220.181</span>.57.216</span><br></pre></td></tr></table></figure><p><strong>特殊的IP地址</strong></p><ul><li>本机IP地址：<code>127.0.0.1</code>、<code>localhost</code> 。</li></ul><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p><p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p><ul><li><strong>端口号：用两个字节表示的整数，它的取值范围是0~65535</strong>。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</li></ul><p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p><h1 id="第二章-TCP通信程序"><a href="#第二章-TCP通信程序" class="headerlink" title="第二章 TCP通信程序"></a>第二章 TCP通信程序</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。</p><p><strong>两端通信时步骤：</strong></p><ol><li>服务端程序，需要事先启动，等待客户端的连接。</li><li>客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。</li></ol><p><strong>在Java中，提供了两个类用于实现TCP通信程序：</strong></p><ol><li>客户端：<code>java.net.Socket</code> 类表示。创建<code>Socket</code>对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li><li>服务端：<code>java.net.ServerSocket</code> 类表示。创建<code>ServerSocket</code>对象，相当于开启一个服务，并等待客户端的连接。</li></ol><h2 id="2-2-Socket类"><a href="#2-2-Socket类" class="headerlink" title="2.2 Socket类"></a>2.2 Socket类</h2><p><code>Socket</code> 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><p><code>public Socket(String host, int port)</code> :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。  </p><blockquote><p>小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p></blockquote></li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket client = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">6666</span>);</span><br></pre></td></tr></table></figure><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ul><li><p><code>public InputStream getInputStream()</code> ： 返回此套接字的输入流。</p><ul><li>如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。</li><li>关闭生成的InputStream也将关闭相关的Socket。</li></ul></li><li><p><code>public OutputStream getOutputStream()</code> ： 返回此套接字的输出流。</p><ul><li>如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。</li><li>关闭生成的OutputStream也将关闭相关的Socket。</li></ul></li><li><p><code>public void close()</code> ：关闭此套接字。</p><ul><li>一旦一个socket被关闭，它不可再使用。</li><li>关闭此socket也将关闭相关的InputStream和OutputStream 。 </li></ul></li><li><p><code>public void shutdownOutput()</code> ： 禁用此套接字的输出流。   </p><ul><li>任何先前写出的数据将被发送，随后终止输出流。 </li></ul><h2 id="2-3-ServerSocket类"><a href="#2-3-ServerSocket类" class="headerlink" title="2.3 ServerSocket类"></a>2.3 ServerSocket类</h2></li></ul><p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public ServerSocket(int port)</code> ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。</li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure><h3 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h3><ul><li><code>public Socket accept()</code> ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 </li></ul><h2 id="2-4-简单的TCP网络程序"><a href="#2-4-简单的TCP网络程序" class="headerlink" title="2.4 简单的TCP网络程序"></a>2.4 简单的TCP网络程序</h2><h3 id="TCP通信分析图解"><a href="#TCP通信分析图解" class="headerlink" title="TCP通信分析图解"></a>TCP通信分析图解</h3><ol><li>【服务端】启动,创建ServerSocket对象，等待连接。</li><li>【客户端】启动,创建Socket对象，请求连接。</li><li>【服务端】接收连接,调用accept方法，并返回一个Socket对象。</li><li>【客户端】Socket对象，获取OutputStream，向服务端写出数据。</li><li>【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。</li></ol><blockquote><p>到此，客户端向服务端发送数据成功。</p></blockquote><p><img src="/2020/03/30/avaSE基础-（三十五）/5_%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%A1.jpg" alt></p><blockquote><p>自此，服务端向客户端回写数据。</p></blockquote><ol start="6"><li>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</li><li>【客户端】Scoket对象，获取InputStream，解析回写数据。</li><li>【客户端】释放资源，断开连接。</li></ol><h3 id="客户端向服务器发送数据"><a href="#客户端向服务器发送数据" class="headerlink" title="客户端向服务器发送数据"></a>客户端向服务器发送数据</h3><p><strong>服务端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTCP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端启动 , 等待连接 .... "</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        Socket server = ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        InputStream is = server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      <span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      <span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="keyword">int</span> len = is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        String msg = <span class="keyword">new</span> String(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="comment">//5.关闭资源.</span></span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTCP</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"客户端 发送数据"</span>);</span><br><span class="line"><span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">Socket client = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line"><span class="comment">// 2.获取流对象 . 输出流</span></span><br><span class="line">OutputStream os = client.getOutputStream();</span><br><span class="line"><span class="comment">// 3.写出数据.</span></span><br><span class="line">os.write(<span class="string">"你好么? tcp ,我来了"</span>.getBytes());</span><br><span class="line"><span class="comment">// 4. 关闭资源 .</span></span><br><span class="line">os.close();</span><br><span class="line">client.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务器向客户端回写数据"><a href="#服务器向客户端回写数据" class="headerlink" title="服务器向客户端回写数据"></a>服务器向客户端回写数据</h3><p><strong>服务端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTCP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端启动 , 等待连接 .... "</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        Socket server = ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        InputStream is = server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      <span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      <span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="keyword">int</span> len = is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        String msg = <span class="keyword">new</span> String(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">      <span class="comment">// =================回写数据=======================</span></span><br><span class="line">      <span class="comment">// 5. 通过 socket 获取输出流</span></span><br><span class="line">       OutputStream out = server.getOutputStream();</span><br><span class="line">      <span class="comment">// 6. 回写数据</span></span><br><span class="line">       out.write(<span class="string">"我很好,谢谢你"</span>.getBytes());</span><br><span class="line">      <span class="comment">// 7.关闭资源.</span></span><br><span class="line">      out.close();</span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTCP</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"客户端 发送数据"</span>);</span><br><span class="line"><span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">Socket client = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line"><span class="comment">// 2.通过Scoket,获取输出流对象 </span></span><br><span class="line">OutputStream os = client.getOutputStream();</span><br><span class="line"><span class="comment">// 3.写出数据.</span></span><br><span class="line">os.write(<span class="string">"你好么? tcp ,我来了"</span>.getBytes());</span><br><span class="line">      <span class="comment">// ==============解析回写=========================</span></span><br><span class="line">      <span class="comment">// 4. 通过Scoket,获取 输入流对象</span></span><br><span class="line">      InputStream in = client.getInputStream();</span><br><span class="line">      <span class="comment">// 5. 读取数据数据</span></span><br><span class="line">      <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">      <span class="keyword">int</span> len = in.read(b);</span><br><span class="line">      System.out.println(<span class="keyword">new</span> String(b, <span class="number">0</span>, len));</span><br><span class="line"><span class="comment">// 6. 关闭资源 .</span></span><br><span class="line">      in.close();</span><br><span class="line">os.close();</span><br><span class="line">client.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第三章-综合案例"><a href="#第三章-综合案例" class="headerlink" title="第三章 综合案例"></a>第三章 综合案例</h1><h2 id="3-1-文件上传案例"><a href="#3-1-文件上传案例" class="headerlink" title="3.1 文件上传案例"></a>3.1 文件上传案例</h2><h3 id="文件上传分析图解"><a href="#文件上传分析图解" class="headerlink" title="文件上传分析图解"></a>文件上传分析图解</h3><ol><li>【客户端】输入流，从硬盘读取文件数据到程序中。</li><li>【客户端】输出流，写出文件数据到服务端。</li><li>【服务端】输入流，读取文件数据到服务端程序。</li><li>【服务端】输出流，写出文件数据到服务器硬盘中。</li></ol><p><img src="/2020/03/30/avaSE基础-（三十五）/6_upload.jpg" alt>    </p><h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p><strong>服务端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">      ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">  <span class="comment">// 2. 建立连接 </span></span><br><span class="line">        Socket accept = serverSocket.accept();</span><br><span class="line">      <span class="comment">// 3. 创建流对象</span></span><br><span class="line">      <span class="comment">// 3.1 获取输入流,读取文件数据</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">        <span class="comment">// 3.2 创建输出流,保存到本地 .</span></span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"copy.jpg"</span>));</span><br><span class="line"><span class="comment">// 4. 读写数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5. 关闭 资源</span></span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">        accept.close();</span><br><span class="line">        System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUPload_Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 创建输入流,读取本地文件  </span></span><br><span class="line">        BufferedInputStream bis  = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.jpg"</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端 </span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">        BufferedOutputStream   bos   = <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据. </span></span><br><span class="line">        <span class="keyword">byte</span>[] b  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="keyword">int</span> len ; </span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">            bos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"文件发送完毕"</span>);</span><br><span class="line">        <span class="comment">// 3.释放资源</span></span><br><span class="line"></span><br><span class="line">        bos.close(); </span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close(); </span><br><span class="line">        System.out.println(<span class="string">"文件上传完毕 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件上传优化分析"><a href="#文件上传优化分析" class="headerlink" title="文件上传优化分析"></a>文件上传优化分析</h3><ol><li><p><strong>文件名称写死的问题</strong></p><p>服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis()+<span class="string">".jpg"</span>) <span class="comment">// 文件名称</span></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>循环接收的问题</strong></p><p>服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次接收新的连接,创建一个Socket</span></span><br><span class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</span><br><span class="line">    Socket accept = serverSocket.accept();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p><strong>效率问题</strong></p><p>服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</span><br><span class="line">    Socket accept = serverSocket.accept();</span><br><span class="line">    <span class="comment">// accept 交给子线程处理.</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      ......</span><br><span class="line">        InputStream bis = accept.getInputStream();</span><br><span class="line">      ......</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">      <span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">          <span class="comment">/* </span></span><br><span class="line"><span class="comment">          3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="string">".jpg"</span>);</span><br><span class="line">                    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                      bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//4. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信息回写分析图解"><a href="#信息回写分析图解" class="headerlink" title="信息回写分析图解"></a>信息回写分析图解</h3><p>前四步与基本文件上传一致.</p><ol start="5"><li>【服务端】获取输出流，回写数据。</li><li>【客户端】获取输入流，解析回写数据。</li></ol><p><img src="/2020/03/30/avaSE基础-（三十五）/6_upload2.jpg" alt></p><h4 id="回写实现"><a href="#回写实现" class="headerlink" title="回写实现"></a>回写实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="string">".jpg"</span>);</span><br><span class="line">                    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.=======信息回写===========================</span></span><br><span class="line">                    System.out.println(<span class="string">"back ........"</span>);</span><br><span class="line">                    OutputStream out = accept.getOutputStream();</span><br><span class="line">                    out.write(<span class="string">"上传成功"</span>.getBytes());</span><br><span class="line">                    out.close();</span><br><span class="line">                    <span class="comment">//================================</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//5. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 创建输入流,读取本地文件</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.jpg"</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据.</span></span><br><span class="line">        <span class="keyword">byte</span>[] b  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="keyword">int</span> len ;</span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 关闭输出流,通知服务端,写出数据完毕</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        System.out.println(<span class="string">"文件发送完毕"</span>);</span><br><span class="line">        <span class="comment">// 3. =====解析回写============</span></span><br><span class="line">        InputStream in = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] back = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">        in.read(back);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(back));</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="comment">// ============================</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-模拟B-S服务器-扩展知识点"><a href="#3-2-模拟B-S服务器-扩展知识点" class="headerlink" title="3.2 模拟B\S服务器(扩展知识点)"></a>3.2 模拟B\S服务器(扩展知识点)</h2><p>模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。</p><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li><p>准备页面数据，web文件夹。</p><p>复制到我们Module中，比如复制到day08中</p><p><img src="/2020/03/30/avaSE基础-（三十五）/img%5C%E5%A4%8D%E5%88%B6.png" alt></p></li><li><p>我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8000</span>);</span><br><span class="line">    Socket socket = server.accept();</span><br><span class="line">    InputStream in = socket.getInputStream();</span><br><span class="line">       <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len = in.read(bytes);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">    socket.close();</span><br><span class="line">    server.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/30/avaSE基础-（三十五）/img%5C%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE.jpg" alt></p></li><li><p>服务器程序中字节输入流可以读取到浏览器发来的请求信息</p><p><img src="/2020/03/30/avaSE基础-（三十五）/img%5C%E8%AF%BB%E5%8F%96%E8%AE%BF%E9%97%AE%E4%BF%A1%E6%81%AF.jpg" alt></p></li></ol><p>GET/web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转换流,读取浏览器请求第一行</span></span><br><span class="line">BufferedReader readWb = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">String requst = readWb.readLine();</span><br><span class="line"><span class="comment">//取出请求资源的路径</span></span><br><span class="line">String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line"><span class="comment">//去掉web前面的/</span></span><br><span class="line">String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">System.out.println(path);</span><br></pre></td></tr></table></figure><h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>服务端实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端  启动 , 等待连接 .... "</span>);</span><br><span class="line">        <span class="comment">// 创建ServerSocket 对象</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        <span class="comment">// 转换流读取浏览器的请求消息</span></span><br><span class="line">        BufferedReader readWb = <span class="keyword">new</span></span><br><span class="line">        BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">        String requst = readWb.readLine();</span><br><span class="line">        <span class="comment">// 取出请求资源的路径</span></span><br><span class="line">        String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="comment">// 去掉web前面的/</span></span><br><span class="line">        String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 读取客户端请求的资源文件</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line">        <span class="comment">// 字节输出流,将文件写会客户端</span></span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 写入HTTP协议响应头,固定写法</span></span><br><span class="line">        out.write(<span class="string">"HTTP/1.1 200 OK\r\n"</span>.getBytes());</span><br><span class="line">        out.write(<span class="string">"Content-Type:text/html\r\n"</span>.getBytes());</span><br><span class="line">        <span class="comment">// 必须要写入空行,否则浏览器不解析</span></span><br><span class="line">        out.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        out.close();</span><br><span class="line">        readWb.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问效果"><a href="#访问效果" class="headerlink" title="访问效果"></a>访问效果</h3><ul><li><strong>火狐</strong></li></ul><p><img src="/2020/03/30/avaSE基础-（三十五）/%E6%95%88%E6%9E%9C%E5%9B%BE1.png" alt></p><blockquote><p>小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。</p></blockquote><p>发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。</p><p>浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket socket = server.accept();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Web(socket)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Web</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Web</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket=socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//转换流,读取浏览器请求第一行</span></span><br><span class="line">                BufferedReader readWb = <span class="keyword">new</span></span><br><span class="line">                        BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String requst = readWb.readLine();</span><br><span class="line">                <span class="comment">//取出请求资源的路径</span></span><br><span class="line">                String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line">                System.out.println(Arrays.toString(strArr));</span><br><span class="line">                String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">                System.out.println(path);</span><br><span class="line"></span><br><span class="line">                FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">                System.out.println(fis);</span><br><span class="line">                <span class="keyword">byte</span>[] bytes= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line">                <span class="comment">//向浏览器 回写数据</span></span><br><span class="line">                OutputStream out = socket.getOutputStream();</span><br><span class="line">                out.write(<span class="string">"HTTP/1.1 200 OK\r\n"</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">"Content-Type:text/html\r\n"</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">                <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    out.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">                &#125;</span><br><span class="line">                fis.close();</span><br><span class="line">                out.close();</span><br><span class="line">                readWb.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>访问效果：</strong></p><p><img src="/2020/03/30/avaSE基础-（三十五）/%E6%95%88%E6%9E%9C%E5%9B%BE2.png" alt>图解：</p><p><img src="/2020/03/30/avaSE基础-（三十五）/img%5CBS%E9%80%9A%E4%BF%A1.bmp" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络编程&quot;&gt;&lt;a href=&quot;#网络编程&quot; class=&quot;headerlink&quot; title=&quot;网络编程&quot;&gt;&lt;/a&gt;网络编程&lt;/h1&gt;&lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （三十四）</title>
    <link href="http://yoursite.com/2020/03/30/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%B8%89%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/30/JavaSE基础-（三十四）/</id>
    <published>2020-03-30T11:36:48.000Z</published>
    <updated>2020-03-30T12:03:30.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Annocation（注释-注解）"><a href="#Annocation（注释-注解）" class="headerlink" title="Annocation（注释 注解）"></a>Annocation（注释 注解）</h1><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><pre><code>单行注释 //多行注释 /*   */文档注释 /**  */</code></pre><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="注解的写法"><a href="#注解的写法" class="headerlink" title="注解的写法"></a>注解的写法</h2><pre><code>@xxxx[{一些信息}]</code></pre><h2 id="注解放在哪里"><a href="#注解放在哪里" class="headerlink" title="注解放在哪里"></a>注解放在哪里</h2><pre><code>类的上面  属性的上面 方法的上面 构造方法的上面 参数的前面</code></pre><h2 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h2><pre><code>1.用来充当注释的作用（仅仅是一个文字说明）@deprecated2.用来做代码的检测（验证）    @Override3.可以携带一些信息（内容）    文件.properties.xml 注解</code></pre><h2 id="Java中有一些写好的注解给我们使用"><a href="#Java中有一些写好的注解给我们使用" class="headerlink" title="Java中有一些写好的注解给我们使用"></a>Java中有一些写好的注解给我们使用</h2><pre><code>@Deprecated   用来说明方法是废弃的@Override     用来做代码检测 检测此方法是否重写@SuppressWarnings(信息)  String[]  {&quot;&quot;}如果数组内的元素只有一个长度  可以省略()unused   变量定义后未被使用serial   类实现了序列化接口  不添加序列化ID号rawtypes  集合没有定义泛型deprecation 方法以废弃*unchecked  出现了泛型问题 可以不检测all       包含以上所有（不推荐）</code></pre><h2 id="注解中可以携带信息-可以不携带"><a href="#注解中可以携带信息-可以不携带" class="headerlink" title="注解中可以携带信息 可以不携带"></a>注解中可以携带信息 可以不携带</h2><pre><code>信息不能随便写 信息类型只能是如下的类型1.基本数据类型2.String数据类型3.枚举数据类型4.注解类型@5.数组类型[] 数组的内部需要加上的四种类型</code></pre><h2 id="如何自己描述一个注解类型"><a href="#如何自己描述一个注解类型" class="headerlink" title="如何自己描述一个注解类型"></a>如何自己描述一个注解类型</h2><pre><code>1.通过@interface 定义个新的注解类型2.发现写法与接口非常相似  可以描述public static final 的属性 比较少见  可以描述public abstract的方法 方法返回值必须有 返回值类型是如上那些3.我们自己定义的注解拿来使用     光定义还不够还需要做很多细致的说明（需要利用java提供好的注解来说明）     元注解（也是注解 不是拿来使用的 是用来说明注解）     @target 描述当前的注解可以放在哪里写     @retention 描述当前的这个注解存在什么作用域中的            源代码文件----&gt;编译----&gt;字节码文件----&gt;加载---&gt;内存执行            SOURCE                    CLASS                  RUNTIME     @Inherited  描述当前这个注解能否被子类对象继承     @Document   描述这个注解能否生成文档</code></pre><h2 id="我们使用自己描述的注解"><a href="#我们使用自己描述的注解" class="headerlink" title="我们使用自己描述的注解"></a>我们使用自己描述的注解</h2><pre><code>问题1.注解里面描述了一个方法 方法没有参数 方法有返回值String[]     使用注解的时候让我们传递参数     理解为 注解的方法做事 将我们传递的参数 搬运走了给了别人问题2.使用别人写好的注解不用写方法名 我们自己定义的方法必须写名字     如果我们自己定义的注解 只有一个方法名字叫value     在使用的时候可以省略方法名     如果传递的信息是一个数组 数组内只有一个元素 可以省略{}     如果是两个以上 每一个方法必须写名字</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Annocation（注释-注解）&quot;&gt;&lt;a href=&quot;#Annocation（注释-注解）&quot; class=&quot;headerlink&quot; title=&quot;Annocation（注释 注解）&quot;&gt;&lt;/a&gt;Annocation（注释 注解）&lt;/h1&gt;&lt;h1 id=&quot;注释&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （三十三）</title>
    <link href="http://yoursite.com/2020/03/30/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/30/JavaSE基础-（三十三）/</id>
    <published>2020-03-30T00:05:21.000Z</published>
    <updated>2020-03-30T12:03:32.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反射-reflect"><a href="#反射-reflect" class="headerlink" title="反射 reflect"></a>反射 reflect</h1><h2 id="类是用来描述一组类"><a href="#类是用来描述一组类" class="headerlink" title="类是用来描述一组类"></a>类是用来描述一组类</h2><h2 id="反射机制认为是描述一组类"><a href="#反射机制认为是描述一组类" class="headerlink" title="反射机制认为是描述一组类"></a>反射机制认为是描述一组类</h2><pre><code>Class           用来描述类本身Package         用来描述所属类的包Field           用来描述类中的属性Method          用来描述类的方法Constructor     用来描述类中的构造方法Annotation      用来描述类中的注解</code></pre><h1 id="如何获取Class"><a href="#如何获取Class" class="headerlink" title="如何获取Class"></a>如何获取Class</h1><pre><code>如何下三种方式Class    clazz = Class.for.Name(&quot;包名.类名&quot;)Class    clazz = 类名.class;Class    clazz = 对象.getClass();//Object类中的方法</code></pre><h1 id="Class中的常用方法"><a href="#Class中的常用方法" class="headerlink" title="Class中的常用方法"></a>Class中的常用方法</h1><pre><code>int result = getModifiers();   获取类的修饰符（权限 特征）每一个修饰符 用一个整数来进行表示0开始----0-1-2-4-8-16-32--64-128-256-512-10240---默认不写  1---public         2---private    4---protected 8---static16---final    32----sychronized  64---voliate   128---trasnsient256---native  512---interface    1024---abstractString name = getName(); 获取名字String simpleName = getSimpleName();简单名Package p = getPackage();p.getName();Class sclazz = getSuperClass();//获取父类Class[] classes = getModifiers();Object obj = newInstance();//默认调用无参构造方法创建对象Filed f = getField(&quot;属性名&quot;);Field[] fs = getField();如上两个方法只能获取公有属性 但是包含继承过来父类属性getDeclaredField(&quot;属性&quot;)Field[] fs =getDeclaredFields();如上的两个方法能获取公有和私有的属性 但是只能获取本类中的属性</code></pre><h1 id="Filed类中常用方法"><a href="#Filed类中常用方法" class="headerlink" title="Filed类中常用方法"></a>Filed类中常用方法</h1><pre><code>int = getModifers()Class = getType()String = getName()操作属性 向里面存值set(对象，值）操作属性 从里面取值值 = get(对象)对象 =new():// 创建对象空间 当前对象空间有自己的一套元素（属性 方法）    setAccessable（true）可以修改属性设备操作</code></pre><h1 id="如何操作类中的方法"><a href="#如何操作类中的方法" class="headerlink" title="如何操作类中的方法"></a>如何操作类中的方法</h1><pre><code>Class类中的方法Method m = class.getMethod(&quot;方法名&quot;，Class...参数类型);  获取公有方法（自己类+父类）Method[] = clazz.getMethod();获取所有的方法（公有 自己+父类）Method = getDeclaredMethod（&quot;方法名字&quot;，参数类型class...）获取所有的方法（自己类 公有 私有）Method = getDeclaredMethods()   获取全部的方法（自己类 公有加私有）获取构造方法Construct = clazz.getConstructor（class...参数类型）</code></pre><h1 id="Method类中常用的方法"><a href="#Method类中常用的方法" class="headerlink" title="Method类中常用的方法"></a>Method类中常用的方法</h1><pre><code>int mm = m.getModififers()//获取方法的修饰符（权限+特征）Class mrt = m.getReturnType();//获取返回值数据类型String mn= m.getName();//获取方法名字Class[] mpts = m.getParameterTypes();//获取方法参数列表的类型Class[] mets = m.getExceptionTypes();//获取方法抛出异常类型如何操作方法调用方法 让他执行一次Object result = invoke（对象.执行方法需要传递的所有参数）若方法是私有方法 不许与操作可以设置setAccessable（True）设置方法使用权准入</code></pre><h1 id="Constructor类中的常用方法"><a href="#Constructor类中的常用方法" class="headerlink" title="Constructor类中的常用方法"></a>Constructor类中的常用方法</h1><pre><code>con.getModifiers();con.getName();con.getParamenterTyper();con.getExceptionTypers()如何操作构造方法执行一次 创建对象Object = newInstance（执行构造方法时的所有参数）;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;反射-reflect&quot;&gt;&lt;a href=&quot;#反射-reflect&quot; class=&quot;headerlink&quot; title=&quot;反射 reflect&quot;&gt;&lt;/a&gt;反射 reflect&lt;/h1&gt;&lt;h2 id=&quot;类是用来描述一组类&quot;&gt;&lt;a href=&quot;#类是用来描述一组类&quot; c
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （三十二）</title>
    <link href="http://yoursite.com/2020/03/29/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/29/JavaSE基础-（三十二）/</id>
    <published>2020-03-29T13:33:41.000Z</published>
    <updated>2020-03-30T12:03:33.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主线程-系统线程"><a href="#主线程-系统线程" class="headerlink" title="主线程  系统线程"></a>主线程  系统线程</h1><h1 id="用户线程-main"><a href="#用户线程-main" class="headerlink" title="用户线程 main"></a>用户线程 main</h1><h1 id="守护线程-GC"><a href="#守护线程-GC" class="headerlink" title="守护线程 GC"></a>守护线程 GC</h1><h1 id="线程——操作系统级别-CPU"><a href="#线程——操作系统级别-CPU" class="headerlink" title="线程——操作系统级别 CPU"></a>线程——操作系统级别 CPU</h1><h1 id="如何在Java中创建线程-让线程执行-多线程"><a href="#如何在Java中创建线程-让线程执行-多线程" class="headerlink" title="如何在Java中创建线程 让线程执行 多线程"></a>如何在Java中创建线程 让线程执行 多线程</h1><h1 id="掌握线程的几种不同状态以及如何切换"><a href="#掌握线程的几种不同状态以及如何切换" class="headerlink" title="掌握线程的几种不同状态以及如何切换"></a>掌握线程的几种不同状态以及如何切换</h1><pre><code>new      start()     cpu分配run()      wait()       exception over 创建线程----就绪状态---执行状态------等待/挂起----------异常/消亡               |                          |               |__________________________|                      notify/notifyAll唤醒</code></pre><h1 id="实现线程的过程"><a href="#实现线程的过程" class="headerlink" title="实现线程的过程"></a>实现线程的过程</h1><h2 id="自己描述一个类"><a href="#自己描述一个类" class="headerlink" title="自己描述一个类"></a>自己描述一个类</h2><h2 id="基础父类Thead"><a href="#基础父类Thead" class="headerlink" title="基础父类Thead"></a>基础父类Thead</h2><h2 id="重写run方法"><a href="#重写run方法" class="headerlink" title="重写run方法"></a>重写run方法</h2><h2 id="new一个线程对象-调用start方法让线程进入就绪状态"><a href="#new一个线程对象-调用start方法让线程进入就绪状态" class="headerlink" title="new一个线程对象 调用start方法让线程进入就绪状态"></a>new一个线程对象 调用start方法让线程进入就绪状态</h2><h1 id="实现线程的过程-1"><a href="#实现线程的过程-1" class="headerlink" title="实现线程的过程"></a>实现线程的过程</h1><h2 id="自己描述一个类-1"><a href="#自己描述一个类-1" class="headerlink" title="自己描述一个类"></a>自己描述一个类</h2><h2 id="实现一个父类接口Runnerable"><a href="#实现一个父类接口Runnerable" class="headerlink" title="实现一个父类接口Runnerable"></a>实现一个父类接口Runnerable</h2><h2 id="重写run方法-1"><a href="#重写run方法-1" class="headerlink" title="重写run方法"></a>重写run方法</h2><h2 id="new一个线程对象-需要创建Thead将自己包起来-然后调用Start"><a href="#new一个线程对象-需要创建Thead将自己包起来-然后调用Start" class="headerlink" title="new一个线程对象 需要创建Thead将自己包起来 然后调用Start()"></a>new一个线程对象 需要创建Thead将自己包起来 然后调用Start()</h2><h1 id="生产者和消费者模型"><a href="#生产者和消费者模型" class="headerlink" title="生产者和消费者模型"></a>生产者和消费者模型</h1><h2 id="通过这个模型-成功演示出-线程的安全问题"><a href="#通过这个模型-成功演示出-线程的安全问题" class="headerlink" title="通过这个模型 成功演示出 线程的安全问题"></a>通过这个模型 成功演示出 线程的安全问题</h2><pre><code>两个消费者 同时访问一个仓库对象 仓库内只有一个元素的时候两个消费者 并发访问 会有可能产生抢夺资源的问题</code></pre><h2 id="自己解决一下线程安全的问题"><a href="#自己解决一下线程安全的问题" class="headerlink" title="自己解决一下线程安全的问题"></a>自己解决一下线程安全的问题</h2><pre><code>让仓库对象被线程访问的时候 仓库对象被锁定仓库对象只能被一个线程所访问 其他对象处于等待状态特征修饰符synchronized 同步 一个时间段只有一个线程能访问</code></pre><h2 id="线程安全锁两种写法"><a href="#线程安全锁两种写法" class="headerlink" title="线程安全锁两种写法"></a>线程安全锁两种写法</h2><h3 id="将synchronized关键字-放在方法结构上"><a href="#将synchronized关键字-放在方法结构上" class="headerlink" title="将synchronized关键字 放在方法结构上"></a>将synchronized关键字 放在方法结构上</h3><pre><code>public synchronized void get(){}锁定的是调用方法时的那个对象</code></pre><h3 id="将synchronized关键字-方法在（构造方法内部）的内部"><a href="#将synchronized关键字-方法在（构造方法内部）的内部" class="headerlink" title="将synchronized关键字 方法在（构造方法内部）的内部"></a>将synchronized关键字 方法在（构造方法内部）的内部</h3><pre><code>public void get(){     好多代码     synchronzied（对象）{     好多代码     }     好多代码}</code></pre><h2 id="我们觉得return-不是很好"><a href="#我们觉得return-不是很好" class="headerlink" title="我们觉得return 不是很好"></a>我们觉得return 不是很好</h2><pre><code>应该让线程的不同状态来回切换执行 等待 执行 等待wait() Object类中的方法对象.wait();对象.wait();不是当前对象wait              访问当前这个对象的线程wait notify notifyAll p.setPriority(10);   p.getPriorty(); 产生一个类似假死的状态 所有的线程进入等待状态 没有线程做事</code></pre><h1 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h1><h2 id="程序-进程-线程-概念的区别"><a href="#程序-进程-线程-概念的区别" class="headerlink" title="程序 进程 线程 概念的区别"></a>程序 进程 线程 概念的区别</h2><h2 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h2><h2 id="线程的几种状态-如何切换"><a href="#线程的几种状态-如何切换" class="headerlink" title="线程的几种状态 如何切换"></a>线程的几种状态 如何切换</h2><h2 id="sleep方法-和-wait方法区别"><a href="#sleep方法-和-wait方法区别" class="headerlink" title="sleep方法 和  wait方法区别"></a>sleep方法 和  wait方法区别</h2><pre><code>1.类    Thead类                       Object类2.调用  静态 类名                       对象3，理解  那个位置调用                    对象调用的方法      那个线程等待                    访问对象的其他线程等待4.唤醒   不需要别人                     需要其他对象调用notiy唤醒5.锁    不会释放锁                      等会会释放锁</code></pre><h1 id="比较重要的方法-join"><a href="#比较重要的方法-join" class="headerlink" title="比较重要的方法 join"></a>比较重要的方法 join</h1><pre><code>设计一个模型1.有两个线程 One   Two  Two加入到One里面2.设计模型的时候  two线程在one的run里面创建 保证两个先后顺序3.Two.join();  无参数==0; 有参数==2000         two.join(0){         while(two.isAlive()){                    Two.wait（0）；//访问Two的线程进入等待状态         }</code></pre><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="一旦对象锁定-不释放的情况下其他对象都需要等待-有可能会产生死锁的效果"><a href="#一旦对象锁定-不释放的情况下其他对象都需要等待-有可能会产生死锁的效果" class="headerlink" title="一旦对象锁定 不释放的情况下其他对象都需要等待 有可能会产生死锁的效果"></a>一旦对象锁定 不释放的情况下其他对象都需要等待 有可能会产生死锁的效果</h2><h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><h2 id="解决死锁的问题"><a href="#解决死锁的问题" class="headerlink" title="解决死锁的问题"></a>解决死锁的问题</h2><h3 id="礼让—–-gt-产生时间差"><a href="#礼让—–-gt-产生时间差" class="headerlink" title="礼让—–&gt;产生时间差"></a>礼让—–&gt;产生时间差</h3><h3 id="不要产生公用对象问题"><a href="#不要产生公用对象问题" class="headerlink" title="不要产生公用对象问题"></a>不要产生公用对象问题</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;主线程-系统线程&quot;&gt;&lt;a href=&quot;#主线程-系统线程&quot; class=&quot;headerlink&quot; title=&quot;主线程  系统线程&quot;&gt;&lt;/a&gt;主线程  系统线程&lt;/h1&gt;&lt;h1 id=&quot;用户线程-main&quot;&gt;&lt;a href=&quot;#用户线程-main&quot; class=&quot;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础  （三十一）</title>
    <link href="http://yoursite.com/2020/03/26/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/26/JavaSE基础-（三十一）/</id>
    <published>2020-03-26T15:25:56.000Z</published>
    <updated>2020-03-29T13:24:59.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习文件流"><a href="#学习文件流" class="headerlink" title="学习文件流"></a>学习文件流</h1><h2 id="文件流按照读取或写入的单位（字节数）大小来区分"><a href="#文件流按照读取或写入的单位（字节数）大小来区分" class="headerlink" title="文件流按照读取或写入的单位（字节数）大小来区分"></a>文件流按照读取或写入的单位（字节数）大小来区分</h2><h2 id="字节型文件流（1字节）"><a href="#字节型文件流（1字节）" class="headerlink" title="字节型文件流（1字节）"></a>字节型文件流（1字节）</h2><h3 id="FileInputStream-FileOutputStream"><a href="#FileInputStream-FileOutputStream" class="headerlink" title="FileInputStream/FileOutputStream"></a>FileInputStream/FileOutputStream</h3><h2 id="字符型文件流（2-字节–1字符）"><a href="#字符型文件流（2-字节–1字符）" class="headerlink" title="字符型文件流（2-字节–1字符）"></a>字符型文件流（2-字节–1字符）</h2><h3 id="FileReader-FileWriter"><a href="#FileReader-FileWriter" class="headerlink" title="FileReader/FileWriter"></a>FileReader/FileWriter</h3><h1 id="字节型文件输入流"><a href="#字节型文件输入流" class="headerlink" title="字节型文件输入流"></a>字节型文件输入流</h1><h2 id="了解一下继承关系-inputStream类-字节型输入流的父类"><a href="#了解一下继承关系-inputStream类-字节型输入流的父类" class="headerlink" title="了解一下继承关系 inputStream类 字节型输入流的父类"></a>了解一下继承关系 inputStream类 字节型输入流的父类</h2><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="调用一个带File类型的构造方法"><a href="#调用一个带File类型的构造方法" class="headerlink" title="调用一个带File类型的构造方法"></a>调用一个带File类型的构造方法</h3><h3 id="调用一个带String类型的构造方法"><a href="#调用一个带String类型的构造方法" class="headerlink" title="调用一个带String类型的构造方法"></a>调用一个带String类型的构造方法</h3><h2 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h2><pre><code>int code = read(); 每次从流管道中读取一个字节 返回字节码的code码int count = read(byte[] )每次从流管道中读取若干字节 存入数组内 返回有效元素skip（long n）跳过几个字节 读取多线程————————&gt;利用几个线程同时读取文件*close()   将流管道关闭---必须要做 最好放在fianlly里 注意代码的健壮性 严谨性</code></pre><h1 id="字节型文件输出流"><a href="#字节型文件输出流" class="headerlink" title="字节型文件输出流"></a>字节型文件输出流</h1><h2 id="FileOutput-将数据写入文件中"><a href="#FileOutput-将数据写入文件中" class="headerlink" title="FileOutput 将数据写入文件中"></a>FileOutput 将数据写入文件中</h2><h2 id="java-io"><a href="#java-io" class="headerlink" title="java.io"></a>java.io</h2><h2 id="继承OutputStream-所有字节输出型的父类"><a href="#继承OutputStream-所有字节输出型的父类" class="headerlink" title="继承OutputStream 所有字节输出型的父类"></a>继承OutputStream 所有字节输出型的父类</h2><h2 id="创建对象-1"><a href="#创建对象-1" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="调用一个带file参数-还有file-Boolean重载"><a href="#调用一个带file参数-还有file-Boolean重载" class="headerlink" title="调用一个带file参数 还有file Boolean重载"></a>调用一个带file参数 还有file Boolean重载</h3><h3 id="调用一个带String参数-还有String-boolean-重载"><a href="#调用一个带String参数-还有String-boolean-重载" class="headerlink" title="调用一个带String参数 还有String boolean 重载"></a>调用一个带String参数 还有String boolean 重载</h3><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><pre><code>writr(int code);将给定的code对应的字符写入文件“=”write(byte[]) 将数组中的全部字节写入文集 getByte()flush() 将管道内的字节推入(刷新)文件close() 注意在finaly类中关闭</code></pre><h1 id="字符型文件流"><a href="#字符型文件流" class="headerlink" title="字符型文件流"></a>字符型文件流</h1><h2 id="FileReader-FileWriter-1"><a href="#FileReader-FileWriter-1" class="headerlink" title="FileReader   FileWriter"></a>FileReader   FileWriter</h2><h2 id="只能操作存文本文件（右键打开方式-记事本打开-能看懂）-txt"><a href="#只能操作存文本文件（右键打开方式-记事本打开-能看懂）-txt" class="headerlink" title="只能操作存文本文件（右键打开方式 记事本打开 能看懂）.txt"></a>只能操作存文本文件（右键打开方式 记事本打开 能看懂）.txt</h2><h1 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h1><h2 id="java-io包"><a href="#java-io包" class="headerlink" title="java.io包"></a>java.io包</h2><h2 id="继承-InputStreamReader-Reader"><a href="#继承-InputStreamReader-Reader" class="headerlink" title="继承 InputStreamReader Reader"></a>继承 InputStreamReader Reader</h2><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><h3 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h3><h3 id="read-char"><a href="#read-char" class="headerlink" title="read(char[])"></a>read(char[])</h3><h1 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h1><h2 id="java-io包-1"><a href="#java-io包-1" class="headerlink" title="java.io包"></a>java.io包</h2><h2 id="继承OutputStreamWriter-Writer"><a href="#继承OutputStreamWriter-Writer" class="headerlink" title="继承OutputStreamWriter Writer"></a>继承OutputStreamWriter Writer</h2><h2 id="构造方法-带file参数-带file-boolean参数"><a href="#构造方法-带file参数-带file-boolean参数" class="headerlink" title="构造方法 带file参数 带file,boolean参数"></a>构造方法 带file参数 带file,boolean参数</h2><h2 id="nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-带String参数-带String，boolean参数"><a href="#nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-带String参数-带String，boolean参数" class="headerlink" title="&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;带String参数 带String，boolean参数"></a>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;带String参数 带String，boolean参数</h2><h2 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h2><pre><code>writer（int）writer（char[]）writer（String）int count = read(char[]);close() flush()</code></pre><h1 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h1><h2 id="在管道中内增加缓存的数据"><a href="#在管道中内增加缓存的数据" class="headerlink" title="在管道中内增加缓存的数据"></a>在管道中内增加缓存的数据</h2><h2 id="让我们使用流读取的文字更加流畅"><a href="#让我们使用流读取的文字更加流畅" class="headerlink" title="让我们使用流读取的文字更加流畅"></a>让我们使用流读取的文字更加流畅</h2><h2 id="高级流—–》创建通过低级流"><a href="#高级流—–》创建通过低级流" class="headerlink" title="高级流—–》创建通过低级流"></a>高级流—–》创建通过低级流</h2><pre><code>BufferedInputStream/BufferedOutputStreamBufferedReader/BufferedWriterBUfferedInPutStream构建方式 使用低级流构建基本上使用与低级流完全一致read()skip()available()close() BufferedOutStream构建方式 使用低级流构建 注意缓冲流构建的时候没有boolean类型的参数基本使用与低级流的方法完全一致read()skip()available()close()BufferedOutputStream</code></pre><h1 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h1><h2 id="对象的序列化-反序列化"><a href="#对象的序列化-反序列化" class="headerlink" title="对象的序列化/反序列化"></a>对象的序列化/反序列化</h2><h2 id="为什么要有文件"><a href="#为什么要有文件" class="headerlink" title="为什么要有文件"></a>为什么要有文件</h2><pre><code>文件永久保存信息    很多数据存入文件-----数据持久化</code></pre><h2 id="如果按照以行为单位写信息"><a href="#如果按照以行为单位写信息" class="headerlink" title="如果按照以行为单位写信息"></a>如果按照以行为单位写信息</h2><h3 id="好处在于每一行记录的信息都是相关的"><a href="#好处在于每一行记录的信息都是相关的" class="headerlink" title="好处在于每一行记录的信息都是相关的"></a>好处在于每一行记录的信息都是相关的</h3><h3 id="信息我们可以读出来-直接看懂文件"><a href="#信息我们可以读出来-直接看懂文件" class="headerlink" title="信息我们可以读出来 直接看懂文件"></a>信息我们可以读出来 直接看懂文件</h3><h3 id="不好在于第一不一定安全-直接看懂"><a href="#不好在于第一不一定安全-直接看懂" class="headerlink" title="不好在于第一不一定安全 直接看懂"></a>不好在于第一不一定安全 直接看懂</h3><h3 id="不好在于只能记录String信息-不一定能记录一些动作（方法）"><a href="#不好在于只能记录String信息-不一定能记录一些动作（方法）" class="headerlink" title="不好在于只能记录String信息 不一定能记录一些动作（方法）"></a>不好在于只能记录String信息 不一定能记录一些动作（方法）</h3><h3 id="读取出来的信息-String——-gt-Person"><a href="#读取出来的信息-String——-gt-Person" class="headerlink" title="读取出来的信息 String——&gt;Person"></a>读取出来的信息 String——&gt;Person</h3><h3 id="如果能将对象拆分成字节码直接写入文件"><a href="#如果能将对象拆分成字节码直接写入文件" class="headerlink" title="如果能将对象拆分成字节码直接写入文件"></a>如果能将对象拆分成字节码直接写入文件</h3><h2 id="将对象直接存入文件中—–对象流"><a href="#将对象直接存入文件中—–对象流" class="headerlink" title="将对象直接存入文件中—–对象流"></a>将对象直接存入文件中—–对象流</h2><h1 id="为什么要重写toString方法"><a href="#为什么要重写toString方法" class="headerlink" title="为什么要重写toString方法"></a>为什么要重写toString方法</h1><h2 id="toString-方法默认是打印对象和hashcode码"><a href="#toString-方法默认是打印对象和hashcode码" class="headerlink" title="toString 方法默认是打印对象和hashcode码"></a>toString 方法默认是打印对象和hashcode码</h2><h2 id="当输出为一个对象名的时候"><a href="#当输出为一个对象名的时候" class="headerlink" title="当输出为一个对象名的时候"></a>当输出为一个对象名的时候</h2><h2 id="重写toString方法可以打印对象的值"><a href="#重写toString方法可以打印对象的值" class="headerlink" title="重写toString方法可以打印对象的值"></a>重写toString方法可以打印对象的值</h2><h1 id="对象序列化与反序列化"><a href="#对象序列化与反序列化" class="headerlink" title="对象序列化与反序列化"></a>对象序列化与反序列化</h1><h2 id="对象的序列化指的是"><a href="#对象的序列化指的是" class="headerlink" title="对象的序列化指的是"></a>对象的序列化指的是</h2><h3 id="将一个完整的对象-拆分成字节碎片-记录在文件中"><a href="#将一个完整的对象-拆分成字节碎片-记录在文件中" class="headerlink" title="将一个完整的对象 拆分成字节碎片 记录在文件中"></a>将一个完整的对象 拆分成字节碎片 记录在文件中</h3><h2 id="对象的反序列化指的是"><a href="#对象的反序列化指的是" class="headerlink" title="对象的反序列化指的是"></a>对象的反序列化指的是</h2><h3 id="将文件中记录的对象随便-反过来组合一个完整的对象"><a href="#将文件中记录的对象随便-反过来组合一个完整的对象" class="headerlink" title="将文件中记录的对象随便 反过来组合一个完整的对象"></a>将文件中记录的对象随便 反过来组合一个完整的对象</h3><h2 id="如果想要将对象序列化到文件中"><a href="#如果想要将对象序列化到文件中" class="headerlink" title="如果想要将对象序列化到文件中"></a>如果想要将对象序列化到文件中</h2><h3 id="需要对象实现Serializable接口"><a href="#需要对象实现Serializable接口" class="headerlink" title="需要对象实现Serializable接口"></a>需要对象实现Serializable接口</h3><h3 id="是一个示意性的接口"><a href="#是一个示意性的接口" class="headerlink" title="是一个示意性的接口"></a>是一个示意性的接口</h3><h2 id="如果要实现反序列化"><a href="#如果要实现反序列化" class="headerlink" title="如果要实现反序列化"></a>如果要实现反序列化</h2><h3 id="需要给对象提供一个序列化的版本号-1-7版本—-gt-String-1-8—-gt-String"><a href="#需要给对象提供一个序列化的版本号-1-7版本—-gt-String-1-8—-gt-String" class="headerlink" title="需要给对象提供一个序列化的版本号 1.7版本—&gt;String 1.8—&gt;String"></a>需要给对象提供一个序列化的版本号 1.7版本—&gt;String 1.8—&gt;String</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;学习文件流&quot;&gt;&lt;a href=&quot;#学习文件流&quot; class=&quot;headerlink&quot; title=&quot;学习文件流&quot;&gt;&lt;/a&gt;学习文件流&lt;/h1&gt;&lt;h2 id=&quot;文件流按照读取或写入的单位（字节数）大小来区分&quot;&gt;&lt;a href=&quot;#文件流按照读取或写入的单位（字节数）
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础  （三十）</title>
    <link href="http://yoursite.com/2020/03/26/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%B8%89%E5%8D%81%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/26/JavaSE基础-（三十）/</id>
    <published>2020-03-26T14:28:17.000Z</published>
    <updated>2020-03-26T15:59:06.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="I-O相关-输入-输出-流（数据流动）"><a href="#I-O相关-输入-输出-流（数据流动）" class="headerlink" title="I/O相关 输入/输出 流（数据流动）"></a>I/O相关 输入/输出 流（数据流动）</h1><h2 id="数据流动的方向-读数据-输入input-写数据（输出output）"><a href="#数据流动的方向-读数据-输入input-写数据（输出output）" class="headerlink" title="数据流动的方向 读数据(输入input) 写数据（输出output）"></a>数据流动的方向 读数据(输入input) 写数据（输出output）</h2><h2 id="文件流-字符流-数组流-对象流-网络流"><a href="#文件流-字符流-数组流-对象流-网络流" class="headerlink" title="文件流 字符流 数组流 对象流 网络流"></a>文件流 字符流 数组流 对象流 网络流</h2><h1 id="什么叫文件"><a href="#什么叫文件" class="headerlink" title="什么叫文件"></a>什么叫文件</h1><h2 id="一种电脑的存储形式"><a href="#一种电脑的存储形式" class="headerlink" title="一种电脑的存储形式"></a>一种电脑的存储形式</h2><h2 id="文件有不同的格式-txt-doc-ppt-mp4-rar-…"><a href="#文件有不同的格式-txt-doc-ppt-mp4-rar-…" class="headerlink" title="文件有不同的格式 .txt .doc .ppt .mp4 .rar …"></a>文件有不同的格式 .txt .doc .ppt .mp4 .rar …</h2><h2 id="文件夹—–目录路径"><a href="#文件夹—–目录路径" class="headerlink" title="文件夹—–目录路径"></a>文件夹—–目录路径</h2><h2 id="File—–-gt-与电脑上的文件夹产生一一对应的映射关系"><a href="#File—–-gt-与电脑上的文件夹产生一一对应的映射关系" class="headerlink" title="File—–&gt;与电脑上的文件夹产生一一对应的映射关系"></a>File—–&gt;与电脑上的文件夹产生一一对应的映射关系</h2><h2 id="File是一个类"><a href="#File是一个类" class="headerlink" title="File是一个类"></a>File是一个类</h2><h2 id="java-io包"><a href="#java-io包" class="headerlink" title="java.io包"></a>java.io包</h2><h2 id="文件或目录路径名的抽象形式"><a href="#文件或目录路径名的抽象形式" class="headerlink" title="文件或目录路径名的抽象形式"></a>文件或目录路径名的抽象形式</h2><h2 id="File与真实硬盘中的文件或文件夹-不是同一个东西"><a href="#File与真实硬盘中的文件或文件夹-不是同一个东西" class="headerlink" title="File与真实硬盘中的文件或文件夹 不是同一个东西"></a>File与真实硬盘中的文件或文件夹 不是同一个东西</h2><h2 id="File是内存中的一个对象-lt-—–映射—-gt-磁盘上的文件或文件夹"><a href="#File是内存中的一个对象-lt-—–映射—-gt-磁盘上的文件或文件夹" class="headerlink" title="File是内存中的一个对象&lt;—–映射—-&gt;磁盘上的文件或文件夹"></a>File是内存中的一个对象&lt;—–映射—-&gt;磁盘上的文件或文件夹</h2><h2 id="File类中的常用方法"><a href="#File类中的常用方法" class="headerlink" title="File类中的常用方法"></a>File类中的常用方法</h2><pre><code>canRead() canWrite() isHidden() isFile() isDirectory()length() 获取文件中的字节数lastModified()获取文件最后的修改时间----&gt;毫秒值*String path = getAbstractPath() 获取文件的绝对路径 D://test//Test.txt绝对路径&lt;---&gt;相对路径绝对路径可以通过完整字符串 定位盘符 文件夹 文件相对路径没有盘符的写法 当前工程（项目）所在的位置寻找              C：\Users\Administator\ideaProjects\TestFile\src*String name = getName()获取文件名字 Test.txt*creatNewFile() 创建新的文件*mkdir 创建新的文件夹 外层没有 不能创建*mkdirs 创建新的文件夹 外层没有 自动创建String pname = getParent() 获取当前file的父亲file名字*File file = getParent() 获取当前file父亲的对象String[] names = list() 获取当前file所有儿子的名字*File[]files = listFiles() 获取当前file所有儿子对象*boolean = delete() 删除文件或空的文件及 不能删除带元素的文件夹</code></pre><h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;I-O相关-输入-输出-流（数据流动）&quot;&gt;&lt;a href=&quot;#I-O相关-输入-输出-流（数据流动）&quot; class=&quot;headerlink&quot; title=&quot;I/O相关 输入/输出 流（数据流动）&quot;&gt;&lt;/a&gt;I/O相关 输入/输出 流（数据流动）&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础  （二十九）</title>
    <link href="http://yoursite.com/2020/03/25/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/25/JavaSE基础-（二十九）/</id>
    <published>2020-03-25T15:20:45.000Z</published>
    <updated>2020-03-31T01:25:00.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异常-错误"><a href="#异常-错误" class="headerlink" title="异常/错误"></a>异常/错误</h1><h2 id="程序运行过程中，可能会发生一些不被期望的效果，肯定会阻止我们的程序按指令去执行"><a href="#程序运行过程中，可能会发生一些不被期望的效果，肯定会阻止我们的程序按指令去执行" class="headerlink" title="程序运行过程中，可能会发生一些不被期望的效果，肯定会阻止我们的程序按指令去执行"></a>程序运行过程中，可能会发生一些不被期望的效果，肯定会阻止我们的程序按指令去执行</h2><h2 id="这种不被预期出现的效果，肯定需要抛出来告诉我们"><a href="#这种不被预期出现的效果，肯定需要抛出来告诉我们" class="headerlink" title="这种不被预期出现的效果，肯定需要抛出来告诉我们"></a>这种不被预期出现的效果，肯定需要抛出来告诉我们</h2><h2 id="在JAVA中有一个定义好的Throwable（可以抛出的）"><a href="#在JAVA中有一个定义好的Throwable（可以抛出的）" class="headerlink" title="在JAVA中有一个定义好的Throwable（可以抛出的）"></a>在JAVA中有一个定义好的Throwable（可以抛出的）</h2><h1 id="Error错误"><a href="#Error错误" class="headerlink" title="Error错误"></a>Error错误</h1><h2 id="通常是一些物理性的，JVM虚拟机本身出现的问题，程序指令是处理不了的"><a href="#通常是一些物理性的，JVM虚拟机本身出现的问题，程序指令是处理不了的" class="headerlink" title="通常是一些物理性的，JVM虚拟机本身出现的问题，程序指令是处理不了的"></a>通常是一些物理性的，JVM虚拟机本身出现的问题，程序指令是处理不了的</h2><h1 id="Exception异常"><a href="#Exception异常" class="headerlink" title="Exception异常"></a>Exception异常</h1><h2 id="是一种不正常的现象-通常是给定的指令程序产生了一些不合规范的事情"><a href="#是一种不正常的现象-通常是给定的指令程序产生了一些不合规范的事情" class="headerlink" title="是一种不正常的现象,通常是给定的指令程序产生了一些不合规范的事情"></a>是一种不正常的现象,通常是给定的指令程序产生了一些不合规范的事情</h2><h1 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h1><h2 id="Error（错误）"><a href="#Error（错误）" class="headerlink" title="Error（错误）"></a>Error（错误）</h2><h3 id="StackOverflowError"><a href="#StackOverflowError" class="headerlink" title="StackOverflowError"></a>StackOverflowError</h3><h3 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h3><h2 id="Exception-异常"><a href="#Exception-异常" class="headerlink" title="Exception(异常)"></a>Exception(异常)</h2><h3 id="RuntimeException（运行时）"><a href="#RuntimeException（运行时）" class="headerlink" title="RuntimeException（运行时）"></a>RuntimeException（运行时）</h3><h3 id="IOExceotion"><a href="#IOExceotion" class="headerlink" title="IOExceotion"></a>IOExceotion</h3><h1 id="异常的分支体系"><a href="#异常的分支体系" class="headerlink" title="异常的分支体系"></a>异常的分支体系</h1><h2 id="运行时异常（非检查异常）"><a href="#运行时异常（非检查异常）" class="headerlink" title="运行时异常（非检查异常）"></a>运行时异常（非检查异常）</h2><pre><code>Error和RuntimeException都算作运行时异常javac编译的时候，不会提示发现的在程序编写的时候不要求必须做处理，如果我们愿意可以添加处理手段（try throws）要求大家出现这样的异常的时候，知道怎么产生及如何修改1.InputMisMatchExceotin  输入不匹配        int value = input.nextInt();// abc2.NumberFormatException  数字格式化        int value = Integer.parseInt(&quot;123.45&quot;)3.NegativeArraySizeException 数组长度负数        int Array = new int[-2]4.NullPointerException 空指针异常        int[][] array = new int[3][];        array[0][0] = 10;        Person p = null;        p.getName();5.AirthmeticExceotion 数字异常  10/0  整数不允许除0 infinity小数除0会产生无穷6.ClassCastException 造型异常       Person p = new Teacher();       Student s = (Student) p;7.ArrayIndexOutOfBoundsException 数组索引越界       int[] array ={1,2,3};       array[5];8.StringIndexOutOfBoundsException 字符串越界       String str = &quot;abc&quot;;       str.charAt(5);9.IndexOutOfBoundsException 集合越界       List家族       ArrayList list = new ArrayList();       list.add();list.add();ist.add();       list.get(5);10.IllegalArguementException 非法参数异常       ArrayList list = new ArrayList(-1);</code></pre><h2 id="编译时异常（检查异常）"><a href="#编译时异常（检查异常）" class="headerlink" title="编译时异常（检查异常）"></a>编译时异常（检查异常）</h2><pre><code>除了Error和RuntimeException以外的其他异常javac编译的时候 强制要求我们必须为这样的异常处理（try或throws）因为这样的异常在程序运行中可能会产生问题异常产生后后续的所有执行就被停止啦1.InterruptException            try{                 Thead.sleep(5000);            }catch(Exception e){            }</code></pre><h2 id="添加处理异常的手段"><a href="#添加处理异常的手段" class="headerlink" title="添加处理异常的手段"></a>添加处理异常的手段</h2><h3 id="处理异常不是异常消失了"><a href="#处理异常不是异常消失了" class="headerlink" title="处理异常不是异常消失了"></a>处理异常不是异常消失了</h3><h3 id="处理异常指的是-处理掉异常之后-后续的代码不会因为此异常停止执行"><a href="#处理异常指的是-处理掉异常之后-后续的代码不会因为此异常停止执行" class="headerlink" title="处理异常指的是 处理掉异常之后 后续的代码不会因为此异常停止执行"></a>处理异常指的是 处理掉异常之后 后续的代码不会因为此异常停止执行</h3><h1 id="两种手段"><a href="#两种手段" class="headerlink" title="两种手段"></a>两种手段</h1><h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try{}catch(){}{finally{}}"></a>try{}catch(){}{finally{}}</h2><h3 id="try不能单独出现"><a href="#try不能单独出现" class="headerlink" title="try不能单独出现"></a>try不能单独出现</h3><h3 id="后面必须添加catch或finally"><a href="#后面必须添加catch或finally" class="headerlink" title="后面必须添加catch或finally"></a>后面必须添加catch或finally</h3><h3 id="catch有一组括号（NullPointerException）目的是为了捕获一组异常"><a href="#catch有一组括号（NullPointerException）目的是为了捕获一组异常" class="headerlink" title="catch有一组括号（NullPointerException）目的是为了捕获一组异常"></a>catch有一组括号（NullPointerException）目的是为了捕获一组异常</h3><h3 id="catch可以有多个存在"><a href="#catch可以有多个存在" class="headerlink" title="catch可以有多个存在"></a>catch可以有多个存在</h3><pre><code>捕获的异常直接没有任何的继承关系捕获的异常需要从小到大捕获</code></pre><h3 id="finally-不是必须存在的-若存在则必须执行"><a href="#finally-不是必须存在的-若存在则必须执行" class="headerlink" title="finally 不是必须存在的 若存在则必须执行"></a>finally 不是必须存在的 若存在则必须执行</h3><h2 id="fianl-fianlly-fianlizae-区别"><a href="#fianl-fianlly-fianlizae-区别" class="headerlink" title="fianl fianlly fianlizae 区别"></a>fianl fianlly fianlizae 区别</h2><h2 id="fianl-特征修饰符-修饰变量-属性-方法-类"><a href="#fianl-特征修饰符-修饰变量-属性-方法-类" class="headerlink" title="fianl 特征修饰符 修饰变量 属性 方法 类"></a>fianl 特征修饰符 修饰变量 属性 方法 类</h2><h3 id="修饰变量-基本类型-值不能改变-引用类型-地址不能改变（如果变量没有初值-给一次赋初值的机会）"><a href="#修饰变量-基本类型-值不能改变-引用类型-地址不能改变（如果变量没有初值-给一次赋初值的机会）" class="headerlink" title="修饰变量 基本类型 值不能改变 引用类型 地址不能改变（如果变量没有初值 给一次赋初值的机会）"></a>修饰变量 基本类型 值不能改变 引用类型 地址不能改变（如果变量没有初值 给一次赋初值的机会）</h3><h3 id="修饰属性-特点与修饰变量相似（要求必须给属性赋初值-否则编译报错）"><a href="#修饰属性-特点与修饰变量相似（要求必须给属性赋初值-否则编译报错）" class="headerlink" title="修饰属性 特点与修饰变量相似（要求必须给属性赋初值 否则编译报错）"></a>修饰属性 特点与修饰变量相似（要求必须给属性赋初值 否则编译报错）</h3><h3 id="修饰方法-不能被子类重写"><a href="#修饰方法-不能被子类重写" class="headerlink" title="修饰方法 不能被子类重写"></a>修饰方法 不能被子类重写</h3><h3 id="修饰类-不能被其他子类继承"><a href="#修饰类-不能被其他子类继承" class="headerlink" title="修饰类 不能被其他子类继承"></a>修饰类 不能被其他子类继承</h3><h2 id="fianlly-处理异常的手段的一部分"><a href="#fianlly-处理异常的手段的一部分" class="headerlink" title="fianlly 处理异常的手段的一部分"></a>fianlly 处理异常的手段的一部分</h2><h3 id="try-catch-后面的一个部分"><a href="#try-catch-后面的一个部分" class="headerlink" title="try()catch(){}后面的一个部分"></a>try()catch(){}后面的一个部分</h3><h3 id="这个部分可有可无-如果只能含有一部分-且必须执行"><a href="#这个部分可有可无-如果只能含有一部分-且必须执行" class="headerlink" title="这个部分可有可无 如果只能含有一部分 且必须执行"></a>这个部分可有可无 如果只能含有一部分 且必须执行</h3><h2 id="finalize-是Object类中的一个protected方法"><a href="#finalize-是Object类中的一个protected方法" class="headerlink" title="finalize 是Object类中的一个protected方法"></a>finalize 是Object类中的一个protected方法</h2><h3 id="对象没有任何引用指向的时候—-会被GC回收"><a href="#对象没有任何引用指向的时候—-会被GC回收" class="headerlink" title="对象没有任何引用指向的时候—-会被GC回收"></a>对象没有任何引用指向的时候—-会被GC回收</h3><h3 id="当对象回收的时候-默认调用finalize方法"><a href="#当对象回收的时候-默认调用finalize方法" class="headerlink" title="当对象回收的时候 默认调用finalize方法"></a>当对象回收的时候 默认调用finalize方法</h3><h3 id="若想看到回收的效果-可以重写-public-void-finalize"><a href="#若想看到回收的效果-可以重写-public-void-finalize" class="headerlink" title="若想看到回收的效果 可以重写 public void finalize(){}"></a>若想看到回收的效果 可以重写 public void finalize(){}</h3><h3 id="处理异常放在方法内部可能还会有小问题"><a href="#处理异常放在方法内部可能还会有小问题" class="headerlink" title="处理异常放在方法内部可能还会有小问题"></a>处理异常放在方法内部可能还会有小问题</h3><h3 id="如果在方法内部含有返回值"><a href="#如果在方法内部含有返回值" class="headerlink" title="如果在方法内部含有返回值"></a>如果在方法内部含有返回值</h3><h3 id="不管返回值return关键字在哪里-finally一定会执行完毕"><a href="#不管返回值return关键字在哪里-finally一定会执行完毕" class="headerlink" title="不管返回值return关键字在哪里 finally一定会执行完毕"></a>不管返回值return关键字在哪里 finally一定会执行完毕</h3><h3 id="返回值的具体结果-看情况"><a href="#返回值的具体结果-看情况" class="headerlink" title="返回值的具体结果 看情况"></a>返回值的具体结果 看情况</h3><h2 id="throws-抛出"><a href="#throws-抛出" class="headerlink" title="throws 抛出"></a>throws 抛出</h2><h3 id="异常只能在方法上抛出-属性是不能处理异常的"><a href="#异常只能在方法上抛出-属性是不能处理异常的" class="headerlink" title="异常只能在方法上抛出 属性是不能处理异常的"></a>异常只能在方法上抛出 属性是不能处理异常的</h3><h3 id="方法-构造"><a href="#方法-构造" class="headerlink" title="方法 构造"></a>方法 构造</h3><h3 id="方法-可以抛出不止一个异常，通过，隔开"><a href="#方法-可以抛出不止一个异常，通过，隔开" class="headerlink" title="方法 可以抛出不止一个异常，通过，隔开"></a>方法 可以抛出不止一个异常，通过，隔开</h3><h3 id="抛出的异常与多个catch类似-要么没关系-要么先抛出小异常"><a href="#抛出的异常与多个catch类似-要么没关系-要么先抛出小异常" class="headerlink" title="抛出的异常与多个catch类似 要么没关系 要么先抛出小异常"></a>抛出的异常与多个catch类似 要么没关系 要么先抛出小异常</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;异常-错误&quot;&gt;&lt;a href=&quot;#异常-错误&quot; class=&quot;headerlink&quot; title=&quot;异常/错误&quot;&gt;&lt;/a&gt;异常/错误&lt;/h1&gt;&lt;h2 id=&quot;程序运行过程中，可能会发生一些不被期望的效果，肯定会阻止我们的程序按指令去执行&quot;&gt;&lt;a href=&quot;#程序
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十八）</title>
    <link href="http://yoursite.com/2020/03/25/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/25/JavaSE基础-（二十八）/</id>
    <published>2020-03-25T14:41:32.000Z</published>
    <updated>2020-03-25T16:02:18.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Map-映射"><a href="#Map-映射" class="headerlink" title="Map 映射"></a>Map 映射</h1><h2 id="通过某一个key键可以直接定位到一个Value值"><a href="#通过某一个key键可以直接定位到一个Value值" class="headerlink" title="通过某一个key键可以直接定位到一个Value值"></a>通过某一个key键可以直接定位到一个Value值</h2><h2 id="存储方式以-键值对-存储-Key-Value"><a href="#存储方式以-键值对-存储-Key-Value" class="headerlink" title="存储方式以 键值对 存储 Key-Value"></a>存储方式以 键值对 存储 Key-Value</h2><h2 id="key无序还是一样-指的是存入顺序与取得顺序不一致"><a href="#key无序还是一样-指的是存入顺序与取得顺序不一致" class="headerlink" title="key无序还是一样,指的是存入顺序与取得顺序不一致"></a>key无序还是一样,指的是存入顺序与取得顺序不一致</h2><h2 id="key无重复当然指的是-元素不能一致"><a href="#key无重复当然指的是-元素不能一致" class="headerlink" title="key无重复当然指的是 元素不能一致"></a>key无重复当然指的是 元素不能一致</h2><h1 id="Map基本使用"><a href="#Map基本使用" class="headerlink" title="Map基本使用"></a>Map基本使用</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><h1 id="HashMap-1"><a href="#HashMap-1" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="包-java-util"><a href="#包-java-util" class="headerlink" title="包 java.util"></a>包 java.util</h2><h2 id="如何创建对象"><a href="#如何创建对象" class="headerlink" title="如何创建对象"></a>如何创建对象</h2><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><pre><code>增删改查增put(key,value)   存放一组映射关系 key-value          1.key存储的顺序与取得的顺序不同          2.不同的key可以存储相同的value          3.key若有相同的 则将原有的key覆盖而不是拒绝存入(跟Set刚好相反)删 E = remove(key);改 put = (key,value1) put（key,value2）  replace（key,newValue）查 E = get(key)遍历Map集合   key不一定什么样//获取map集合的全部keySet&lt;Integer&gt; it = map.keySet();//通过迭代器遍历Iterator&lt;Integer&gt; it = keys.iterator();while(it.hashNext()){   Integer key = it.next;   String value = map.get(key);   System.out.println(key+&quot;-&quot;value);}</code></pre><h2 id="API提供的其他方法"><a href="#API提供的其他方法" class="headerlink" title="API提供的其他方法"></a>API提供的其他方法</h2><pre><code>char containsKey(key) containsValue(value)getOrDfault(key.defaultValue)如果key存在就返回对象对应的Value 若没有找到则返回默认返回值isEmpty()putAll(map)putlfAbsent(key.value);//如果key不存在才向集合添加 如果key值不存在就不添加了</code></pre><h2 id="HashMap在什么情形下用"><a href="#HashMap在什么情形下用" class="headerlink" title="HashMap在什么情形下用?"></a>HashMap在什么情形下用?</h2><h3 id="想要存一组元素"><a href="#想要存一组元素" class="headerlink" title="想要存一组元素"></a>想要存一组元素</h3><h4 id="数组-or-集合-如果存储的元素以后长度不变用数组-如果数组长度以后不确定用集合"><a href="#数组-or-集合-如果存储的元素以后长度不变用数组-如果数组长度以后不确定用集合" class="headerlink" title="数组 or 集合 如果存储的元素以后长度不变用数组 如果数组长度以后不确定用集合"></a>数组 or 集合 如果存储的元素以后长度不变用数组 如果数组长度以后不确定用集合</h4><h4 id="如果发现长度以后不确定——————-gt-集合"><a href="#如果发现长度以后不确定——————-gt-集合" class="headerlink" title="如果发现长度以后不确定——————&gt;集合"></a>如果发现长度以后不确定——————&gt;集合</h4><pre><code>List Set MapList家族有序的  存储有顺序用这个       ArrayList       更适合遍历轮循       LinkList        更适合插入删除       Stack          LIFO      Set家族无重复   存储元素希望自动去掉重复元用这个       Hash            性能更高       Tree            希望存进去的元素自动去重复 同时还自动排序按(A-Z)字典顺序Map家族k-v      通过唯一的K快速找寻v用这个       Hash            性能更高       Tree            希望存进去的元素能自动排序</code></pre><h2 id="Hash底层的数据结构"><a href="#Hash底层的数据结构" class="headerlink" title="Hash底层的数据结构"></a>Hash底层的数据结构</h2><pre><code>散列表形式      数组加链表Person对象存入HashMap中  可以HashCode方法   —&gt;不同的对象可以产生相同的hashCode码不同的hashCode码  不同的对象//hashcode码static fial int hash(Object obj){  int h;  return(key == null)?0:(h = key.hashCode())^(h &gt;&gt;&gt;16);}数组：对象的hashCode码    发现hashCode码一致    当前数组后面串一个Node    先扫描数组(位置 )    继续扫描链表    数组中存储的是hash值    （key+value）包装成一个对象Entry    Map.entry</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Map-映射&quot;&gt;&lt;a href=&quot;#Map-映射&quot; class=&quot;headerlink&quot; title=&quot;Map 映射&quot;&gt;&lt;/a&gt;Map 映射&lt;/h1&gt;&lt;h2 id=&quot;通过某一个key键可以直接定位到一个Value值&quot;&gt;&lt;a href=&quot;#通过某一个key键可以直接
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>javaSE基础   （二十七）</title>
    <link href="http://yoursite.com/2020/03/25/javaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/25/javaSE基础-（二十七）/</id>
    <published>2020-03-25T13:58:13.000Z</published>
    <updated>2020-03-25T16:02:07.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><h2 id="以value形式存在"><a href="#以value形式存在" class="headerlink" title="以value形式存在"></a>以value形式存在</h2><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="无序无重复"><a href="#无序无重复" class="headerlink" title="无序无重复"></a>无序无重复</h2><h2 id="具体实现的类"><a href="#具体实现的类" class="headerlink" title="具体实现的类"></a>具体实现的类</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><h2 id="基本的使用"><a href="#基本的使用" class="headerlink" title="基本的使用"></a>基本的使用</h2><h2 id="无序-无重复"><a href="#无序-无重复" class="headerlink" title="无序 无重复"></a>无序 无重复</h2><h3 id="无序-：-我们使用的集合存放元素的顺序-集合内取出来的顺序不一致-（不是集合本身是否有序-Tree自然有序）"><a href="#无序-：-我们使用的集合存放元素的顺序-集合内取出来的顺序不一致-（不是集合本身是否有序-Tree自然有序）" class="headerlink" title="无序 ： 我们使用的集合存放元素的顺序 集合内取出来的顺序不一致 （不是集合本身是否有序 Tree自然有序）"></a>无序 ： 我们使用的集合存放元素的顺序 集合内取出来的顺序不一致 （不是集合本身是否有序 Tree自然有序）</h3><h3 id="无重复-：添加的元素不能一致（如果出现重复元素-只存第一个-不再存入）"><a href="#无重复-：添加的元素不能一致（如果出现重复元素-只存第一个-不再存入）" class="headerlink" title="无重复 ：添加的元素不能一致（如果出现重复元素 只存第一个 不再存入）"></a>无重复 ：添加的元素不能一致（如果出现重复元素 只存第一个 不再存入）</h3><h3 id="集合本身是有自己的算法排布顺序-hash算法"><a href="#集合本身是有自己的算法排布顺序-hash算法" class="headerlink" title="集合本身是有自己的算法排布顺序 hash算法"></a>集合本身是有自己的算法排布顺序 hash算法</h3><h1 id="HashSet——-gt-（HashMap（数组-链表）散列表-邻接表）"><a href="#HashSet——-gt-（HashMap（数组-链表）散列表-邻接表）" class="headerlink" title="HashSet——-&gt;（HashMap（数组+链表）散列表 邻接表）"></a>HashSet——-&gt;（HashMap（数组+链表）散列表 邻接表）</h1><h2 id="java-util包"><a href="#java-util包" class="headerlink" title="java.util包"></a>java.util包</h2><h2 id="如何创建对象"><a href="#如何创建对象" class="headerlink" title="如何创建对象"></a>如何创建对象</h2><h3 id="无参数"><a href="#无参数" class="headerlink" title="无参数"></a>无参数</h3><h3 id="有参数"><a href="#有参数" class="headerlink" title="有参数"></a>有参数</h3><h2 id="集合容器的基本使用"><a href="#集合容器的基本使用" class="headerlink" title="集合容器的基本使用"></a>集合容器的基本使用</h2><pre><code>增删改差boolean = add(value) addAll(collection c) retainAll removeAllboolean = remove(Object)没有修改方法size()</code></pre><h3 id="关于迭代器iterator"><a href="#关于迭代器iterator" class="headerlink" title="关于迭代器iterator"></a>关于迭代器iterator</h3><pre><code>//获取一个迭代器对象 通过set集合获取Iterator &lt;String&gt; it = set.iterator();// Iterator 接口 多态效果 父类引用子类对象//判断下一个位置是否有元素if（it.hashNext）{ String value = it.next(); System.out.println(Value);}</code></pre><h2 id="无重复原则"><a href="#无重复原则" class="headerlink" title="无重复原则"></a>无重复原则</h2><pre><code>首先通过String类和Person类型存储大概猜测 无重复原则 利用equals方法进行比较如果我们让Person对象的name一致 认为是同一个对象我们可以重写equals方法重写了equals方法 发现还没有产生无重复的效果证明可能原则不止equals方法这么简单还有另一个规则同时起着作用 hashcode方法</code></pre><h3 id="为什么要重写equals（）方法？"><a href="#为什么要重写equals（）方法？" class="headerlink" title="为什么要重写equals（）方法？"></a>为什么要重写equals（）方法？</h3><pre><code>  因为默认equals在比较两个对象时，是看他们是否指向同一个地址的。但有时，我们需要两个不同对象只要是某些属性相同就认为它们equals（）的结果为true。比如： person p1 = new person(1,&quot;name&quot;); person p2 = new person(1,&quot;name&quot;); 如果不重写equals的话，他们是不相同的，所以我们要重些equals，判断只要他们的id和名字相同equals就为true，在一些集合里有时也这样用，集合里的contain也是用equals来比较   先来看Object关于equals()的源码：   public boolean equals(Object obj) {   return (this == obj);   } //String 就重写了equals方法public boolean equals(Object obj){    if(this==obj){        return true;    }    if(obj instanceof Question) {        Question anotherQuestion = (Question)obj;       //this.title 按照？截取 与anotherQuestion.title截取之前的部分比较        if(this.title.equals(anotherQuestion.title)){            return true;        }    }    return false;}</code></pre><h3 id="当重写equals方法时，同时也要重写hashCode方法。"><a href="#当重写equals方法时，同时也要重写hashCode方法。" class="headerlink" title="当重写equals方法时，同时也要重写hashCode方法。"></a>当重写equals方法时，同时也要重写hashCode方法。</h3><pre><code>//修改equals 方法一定要修改hashcode方法 因为底层用hashCode比较public int hash(){   return this.title.hashCode();}</code></pre><h1 id="TreeSet—–-gt-（TreeMap-二叉树利用Node（Left-item-right））"><a href="#TreeSet—–-gt-（TreeMap-二叉树利用Node（Left-item-right））" class="headerlink" title="TreeSet—–&gt;（TreeMap 二叉树利用Node（Left item right））"></a>TreeSet—–&gt;（TreeMap 二叉树利用Node（Left item right））</h1><h2 id="无序无重复-java-util"><a href="#无序无重复-java-util" class="headerlink" title="无序无重复 java.util"></a>无序无重复 java.util</h2><h2 id="无参构造方法-带Collection构造方法"><a href="#无参构造方法-带Collection构造方法" class="headerlink" title="无参构造方法 带Collection构造方法"></a>无参构造方法 带Collection构造方法</h2><h2 id="基本常用方法"><a href="#基本常用方法" class="headerlink" title="基本常用方法"></a>基本常用方法</h2><pre><code>add(E e)  iterator() remove(E e) 没有修改 size()</code></pre><h2 id="无序无重复规则是如何实现的"><a href="#无序无重复规则是如何实现的" class="headerlink" title="无序无重复规则是如何实现的"></a>无序无重复规则是如何实现的</h2><pre><code>treeSet集合本身是有顺序的  我们指的无序是存入和取出不一致CompaerTo------&gt;String类 按照字母的自然顺序排列//如果想让Person对象存入TeeSet集合内  必须实现Comapareable接口 重写这个方法piublic int compareTo（o.name）{//当前对象name与另一个对象CompareTo结果return this.name.compareTo(o.name);//当前对象name和另一对象name的CompareTO结果}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Collection&quot;&gt;&lt;a href=&quot;#Collection&quot; class=&quot;headerlink&quot; title=&quot;Collection&quot;&gt;&lt;/a&gt;Collection&lt;/h1&gt;&lt;h2 id=&quot;以value形式存在&quot;&gt;&lt;a href=&quot;#以value形式存在&quot;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础         (二十六）</title>
    <link href="http://yoursite.com/2020/03/25/avaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/25/avaSE基础-（二十六）/</id>
    <published>2020-03-25T13:30:11.000Z</published>
    <updated>2020-03-30T00:03:19.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h1 id="Vector-类"><a href="#Vector-类" class="headerlink" title="Vector 类"></a>Vector 类</h1><h2 id="java-util包"><a href="#java-util包" class="headerlink" title="java.util包"></a>java.util包</h2><h2 id="是ArrayList集合-早期版本"><a href="#是ArrayList集合-早期版本" class="headerlink" title="是ArrayList集合 早期版本"></a>是ArrayList集合 早期版本</h2><pre><code>(StringBuffer类早期 Stringbuilder后来) vector底层也是用动态数组来存储 vector是线程同步的 安全性高 效率低</code></pre><h2 id="扩容方式与ArrayList不同"><a href="#扩容方式与ArrayList不同" class="headerlink" title="扩容方式与ArrayList不同"></a>扩容方式与ArrayList不同</h2><pre><code>默认是扩容两倍  可以通过构造方法创建对象时修改这一机制</code></pre><h1 id="Stack类-栈"><a href="#Stack类-栈" class="headerlink" title="Stack类 栈"></a>Stack类 栈</h1><h2 id="java-util包-1"><a href="#java-util包-1" class="headerlink" title="java.util包"></a>java.util包</h2><h2 id="构造方法只有一个无参数"><a href="#构造方法只有一个无参数" class="headerlink" title="构造方法只有一个无参数"></a>构造方法只有一个无参数</h2><h2 id="只有几个特殊的方法"><a href="#只有几个特殊的方法" class="headerlink" title="只有几个特殊的方法"></a>只有几个特殊的方法</h2><pre><code>push(E e)将某个元素压入栈顶（add()）E = pop()将某一个元素从栈顶取出并删掉(E = remove())E = peek()将某一个元素从栈顶取出并删除掉(E = remove())boolean = empty()判断栈顶元素是否为空(isEmpty)int = search()查找给定元素在栈中的位置(indexof())</code></pre><h2 id="中国象棋-悔棋"><a href="#中国象棋-悔棋" class="headerlink" title="中国象棋 悔棋"></a>中国象棋 悔棋</h2><pre><code>栈中存储每一次的操作步骤撤销功能</code></pre><h1 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h1><h2 id="java-util"><a href="#java-util" class="headerlink" title="java.util"></a>java.util</h2><h3 id="通常子类-Linklist-ArrayQueque"><a href="#通常子类-Linklist-ArrayQueque" class="headerlink" title="通常子类 Linklist ArrayQueque"></a>通常子类 Linklist ArrayQueque</h3><h2 id="通常用无参构造方法实现"><a href="#通常用无参构造方法实现" class="headerlink" title="通常用无参构造方法实现"></a>通常用无参构造方法实现</h2><h2 id="一般方法"><a href="#一般方法" class="headerlink" title="一般方法"></a>一般方法</h2><pre><code>add()element()-----&gt;get()remove()boolean = offer(E e);//相当于add  不会抛出异常E = peek();//相当于element方法E =poll; 剪短//相当于remove()</code></pre><h2 id="双十一秒杀"><a href="#双十一秒杀" class="headerlink" title="双十一秒杀"></a>双十一秒杀</h2><pre><code>所有进入秒杀系统的人存入队列</code></pre><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h1 id="Linklist类"><a href="#Linklist类" class="headerlink" title="Linklist类"></a>Linklist类</h1><h2 id="java-util包-2"><a href="#java-util包-2" class="headerlink" title="java.util包"></a>java.util包</h2><h3 id="自己封装过LinkBox-内部类Node-LT-T-GT-对象（节点-prev-item-next）"><a href="#自己封装过LinkBox-内部类Node-LT-T-GT-对象（节点-prev-item-next）" class="headerlink" title="自己封装过LinkBox 内部类Node&LT;T&GT;对象（节点 prev item next）"></a>自己封装过LinkBox 内部类Node&LT;T&GT;对象（节点 prev item next）</h3><h2 id="底层就是使用双向链表的数据结构形式来存储"><a href="#底层就是使用双向链表的数据结构形式来存储" class="headerlink" title="底层就是使用双向链表的数据结构形式来存储"></a>底层就是使用双向链表的数据结构形式来存储</h2><h3 id="适合插入或删除不适合遍历轮循"><a href="#适合插入或删除不适合遍历轮循" class="headerlink" title="适合插入或删除不适合遍历轮循"></a>适合插入或删除不适合遍历轮循</h3><h2 id="构建对象"><a href="#构建对象" class="headerlink" title="构建对象"></a>构建对象</h2><pre><code>无参构造方法 带参数的构造方法（collection）</code></pre><h2 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h2><pre><code>增删改查 add() remove() set() get() size()手册中提供其他常用方法addAll() addFirst() clear() contains()element() getFirst() getLast() indexOf() lastindex()....</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;List&quot;&gt;&lt;a href=&quot;#List&quot; class=&quot;headerlink&quot; title=&quot;List&quot;&gt;&lt;/a&gt;List&lt;/h1&gt;&lt;h1 id=&quot;Vector-类&quot;&gt;&lt;a href=&quot;#Vector-类&quot; class=&quot;headerlink&quot; title=&quot;V
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十五）</title>
    <link href="http://yoursite.com/2020/03/24/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/24/JavaSE基础-（二十五）/</id>
    <published>2020-03-24T14:23:31.000Z</published>
    <updated>2020-03-31T00:48:53.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合相关"><a href="#集合相关" class="headerlink" title="集合相关"></a>集合相关</h1><h2 id="变量–容器"><a href="#变量–容器" class="headerlink" title="变量–容器"></a>变量–容器</h2><pre><code>存取一个元素</code></pre><h2 id="数组–容器"><a href="#数组–容器" class="headerlink" title="数组–容器"></a>数组–容器</h2><pre><code>一组具有某种特性的数据存放在一起       存储一组元素（数据类型一致）  长度固定</code></pre><h2 id="集合–容器"><a href="#集合–容器" class="headerlink" title="集合–容器"></a>集合–容器</h2><pre><code>与数组类似 集合的长度存储之后还能改变集合用来存储一组元素</code></pre><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><pre><code>存的都是value</code></pre><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><pre><code>有序可重复</code></pre><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><pre><code>无序无重复</code></pre><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><pre><code>存储的是以key-value形式存在key无序无重复  value无序可重复</code></pre><h3 id="序：顺序"><a href="#序：顺序" class="headerlink" title="序：顺序"></a>序：顺序</h3><pre><code>添加进去的元素 取得元素的顺序一致 注意指的不是集合自己的顺序</code></pre><h3 id="重复：两个对象一致"><a href="#重复：两个对象一致" class="headerlink" title="重复：两个对象一致"></a>重复：两个对象一致</h3><h1 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h1><p>   1.ArrayList 2.LinkList 3.Vector</p><h1 id="ArrayList——-底层就是一个数组"><a href="#ArrayList——-底层就是一个数组" class="headerlink" title="ArrayList——-底层就是一个数组"></a>ArrayList——-底层就是一个数组</h1><h2 id="所属的包-java-util"><a href="#所属的包-java-util" class="headerlink" title="所属的包 java.util"></a>所属的包 java.util</h2><h2 id="如何创建对象"><a href="#如何创建对象" class="headerlink" title="如何创建对象"></a>如何创建对象</h2><pre><code>无参数构造方法 带默认参数的都构造方法 带collection参数的构造方法</code></pre><h2 id="常用的方法-—小容器"><a href="#常用的方法-—小容器" class="headerlink" title="常用的方法 —小容器"></a>常用的方法 —小容器</h2><pre><code>   存 add   取 get   删 remove   改   个数 sizeadd(E e) add(int index,E e)addAll(Collection c); add(int index,Collection c)clear();将集合内的元素全部清除boolean = contains(Object);找寻一个给定元素集合中是否拥有ensureCapacity(int minCapacity);E = get(int index);int = indexOf(Object obj); lastindexOf();isEmpty();iterator;//迭代器 1.5之后增强forremoveAll 差集 retainAll()交集addAll()并集E = set(int index,E value)int size();List = subList(int index,E value)toArray();集合变成数组toArray(T[]);trimToSize();//变成有效元素个数那么长</code></pre><h2 id="arryList底层是一个Object"><a href="#arryList底层是一个Object" class="headerlink" title="arryList底层是一个Object[]"></a>arryList底层是一个Object[]</h2><pre><code>什么类型都可以存进去取出来的时候多态效果 需要自己造型 显得用起来非常麻烦</code></pre><h1 id="JDK1-5之后—-gt-泛型"><a href="#JDK1-5之后—-gt-泛型" class="headerlink" title="JDK1.5之后—-&gt;泛型"></a>JDK1.5之后—-&gt;泛型</h1><pre><code>用来规定数据类型的,定义的时候用一个符号代替某种类型在使用的时候具体的数据类型 将定义的那个符号替换掉ArrayBox&lt;T&gt;</code></pre><h2 id="泛型可以用在哪里？"><a href="#泛型可以用在哪里？" class="headerlink" title="泛型可以用在哪里？"></a>泛型可以用在哪里？</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><pre><code>类定义的时候描述某种数据类型 集合就是这样使用</code></pre><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><pre><code>与泛型类的使用基本一致 子类实现接口时必须添加泛型public interface Text&lt;X&gt;{     public X value;}public class Son&lt;X&gt;implements Test&lt;X&gt;</code></pre><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><pre><code>方法调用时传参数 方法的泛型与类无关 带有泛型的方法可以不放在带有泛型的类中</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集合相关&quot;&gt;&lt;a href=&quot;#集合相关&quot; class=&quot;headerlink&quot; title=&quot;集合相关&quot;&gt;&lt;/a&gt;集合相关&lt;/h1&gt;&lt;h2 id=&quot;变量–容器&quot;&gt;&lt;a href=&quot;#变量–容器&quot; class=&quot;headerlink&quot; title=&quot;变量–容器&quot;&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十四）</title>
    <link href="http://yoursite.com/2020/03/24/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/24/JavaSE基础-（二十四）/</id>
    <published>2020-03-24T13:51:09.000Z</published>
    <updated>2020-03-24T15:58:51.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式-regex"><a href="#正则表达式-regex" class="headerlink" title="正则表达式 regex"></a>正则表达式 regex</h1><pre><code>Regualar有规律的   Expression表达式匹配字符串格式的</code></pre><h2 id="正则表达式通常的作用如下"><a href="#正则表达式通常的作用如下" class="headerlink" title="正则表达式通常的作用如下"></a>正则表达式通常的作用如下</h2><h3 id="字符串格式的校验"><a href="#字符串格式的校验" class="headerlink" title="字符串格式的校验"></a>字符串格式的校验</h3><pre><code>String类中提供的方法 boolean = str.match(&quot;regex&quot;);</code></pre><h3 id="字符串的拆分及替换"><a href="#字符串的拆分及替换" class="headerlink" title="字符串的拆分及替换"></a>字符串的拆分及替换</h3><pre><code>String类中提供的方法 replace split</code></pre><h3 id="字符串的查找"><a href="#字符串的查找" class="headerlink" title="字符串的查找"></a>字符串的查找</h3><pre><code>pattern模式 Matcher匹配器[abc]       abc中的一个[^abc]      不能是abc中的一个 其他都可以[a-zA-Z]     表示必须是这两个范围内的[a-z&amp;&amp;[^bc]]  表示a-z其中的一个但不能是b和c.代表任意一个字符\d digit [0-9]\D 非数字[^0-9]\S 非留白\w word单词 [0-9A-Za-z]数字或字母都可以</code></pre><h3 id="所有字符串中寻找如下规则的信息-邮政编码"><a href="#所有字符串中寻找如下规则的信息-邮政编码" class="headerlink" title="所有字符串中寻找如下规则的信息 邮政编码"></a>所有字符串中寻找如下规则的信息 邮政编码</h3><pre><code>String str = &quot;123456abc123456abc123456abc&quot;//1.利用pattern模式创建一个模式 理解为一个正则表达式对象Pattern pattern = Pattern.compile（&quot;\\d{6}&quot;）;//邮编//2.需要提供一个字符串//3.利用pattern模式对象创建一个匹配器Matcher matcher = pattern.matcher(str);//4.找寻字符串中出现满足上述格式的字串   while(matcher.find()){    System.out.println(matcher.group());//找到满足字符串格式的那一串文字</code></pre><h3 id="如下所有都用来描述字符出现的次数"><a href="#如下所有都用来描述字符出现的次数" class="headerlink" title="如下所有都用来描述字符出现的次数"></a>如下所有都用来描述字符出现的次数</h3><pre><code>？ 0-1次 [0-9]?*  0-n次 +  1-n次{n} 固定n次{n,}至少出现n次{m,n}m-n次</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;正则表达式-regex&quot;&gt;&lt;a href=&quot;#正则表达式-regex&quot; class=&quot;headerlink&quot; title=&quot;正则表达式 regex&quot;&gt;&lt;/a&gt;正则表达式 regex&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;Regualar有规律的   Expression表
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十三）</title>
    <link href="http://yoursite.com/2020/03/24/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/24/JavaSE基础-（二十三）/</id>
    <published>2020-03-24T12:54:08.000Z</published>
    <updated>2020-03-31T00:47:17.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="StringBuffer-StringBuilder"><a href="#StringBuffer-StringBuilder" class="headerlink" title="StringBuffer/StringBuilder"></a>StringBuffer/StringBuilder</h1><h2 id="所属的包"><a href="#所属的包" class="headerlink" title="所属的包"></a>所属的包</h2><pre><code>java.lang包</code></pre><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><pre><code>Serializable,CharSequence,Comparable非常特殊的类 可以像常量一样创建对象String str = &quot;abc&quot;;内存存储 &quot;abc&quot;对象 char[] valueString的不可变特性   private fianl char[] value频繁的修改内容的时候 性能不是很好</code></pre><h2 id="默认继承"><a href="#默认继承" class="headerlink" title="默认继承"></a>默认继承</h2><pre><code>obJect 实现接口Serialzable,CharSequence,AppendableStringBuffer/StringBuilder 没有compare To方法StringBuffer/StringBuilder 含有一个String没有的方法 append();拼接</code></pre><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><pre><code>可变字符串 char[] value;动态扩容</code></pre><h2 id="对象的构建"><a href="#对象的构建" class="headerlink" title="对象的构建"></a>对象的构建</h2><pre><code>无参数构造方法有参数构造方法//无参数构造方法 构建一个默认长度16个对象空间 char[] StringBuilder builder = new StringBuilder();//利用给定的参数 构建有一个自定义长度空间的对象 char[] StringBuilder builder = new StringBuilder(20);//利用带String参数的构造方法,默认数组字符长度字符串+16个长度 StringBuilder builder = new StringBuilder(&quot;abc&quot;);</code></pre><h2 id="StringBuilder中的常用方法"><a href="#StringBuilder中的常用方法" class="headerlink" title="StringBuilder中的常用方法"></a>StringBuilder中的常用方法</h2><pre><code>最主要的方法 append() 频繁的拼接字符串时候使用此方法 提高性能capcacity();字符串底层char[]的容量length();字符串有效元素个数（长度）char = charAt(int index);int = codePointAt(int index);String = substring(int start,[int end]);        注意需要接收返回值 看见取出来的字符串效果delete(int start,[int end]);        String Builder类中独有的方法String类没有        将Start到end之间的字符串删掉 不用接收返回值就看到效果啦int = indexOf(String str,[int fromindex]);int = lastindexof（String str,[int fromIndex]）        找寻给定的str字符串中第一次出现的索引位置 带重载 则从某一个位置开始找StringBuilder = deleteCharAt(int Index)        String类中没有的方法        将给定inde位置的某一字符串删除insert(int index,value);        将给定的value插入在index上replace(int start，int end，string str);        将start和end之间的部分替换成str        builder.replace(2.5,&quot;zzt&quot;)setCharAt(int index,char value);        将index位置的字符改成给定字符的valuetoString()        将StringBuilder对象 构建成一个string对象 返回trimToSize()        将数组无用的容量去掉 变成length长度的数组</code></pre><h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1><h2 id="StringBuilder类不一定需要"><a href="#StringBuilder类不一定需要" class="headerlink" title="StringBuilder类不一定需要"></a>StringBuilder类不一定需要</h2><pre><code>是为了避免String频繁拼接修改字符串信息时才使用的 底层是数组是可变的 提高了性能</code></pre><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><pre><code>与String类不同独有的方法append() lnsert() delete() deleteCharAt() reverse()与String类相同的方法charAt() codePointAt() indexOf() lastindexOf() replace() 名字相同 用法不一致不是很常用的方法ensureCapacity() capacity() SetLength() trimToSize() setCharAt();</code></pre><h1 id="String家族笔试中经常考察的知识点"><a href="#String家族笔试中经常考察的知识点" class="headerlink" title="String家族笔试中经常考察的知识点"></a>String家族笔试中经常考察的知识点</h1><h2 id="String所属的包-继承关系-实现接口"><a href="#String所属的包-继承关系-实现接口" class="headerlink" title="String所属的包 继承关系 实现接口"></a>String所属的包 继承关系 实现接口</h2><pre><code>java.lang包 继承Object 实现接口Serializable,CharSequence,Comparable</code></pre><h2 id="String构建方式"><a href="#String构建方式" class="headerlink" title="String构建方式"></a>String构建方式</h2><pre><code>常量 构造方法</code></pre><h2 id="String对象内存结构"><a href="#String对象内存结构" class="headerlink" title="String对象内存结构"></a>String对象内存结构</h2><pre><code>字符串常量区 new堆内存对象= = equals()区别&quot;a&quot; +&quot;b&quot;+&quot;c&quot;</code></pre><h2 id="String不可不变特性"><a href="#String不可不变特性" class="headerlink" title="String不可不变特性"></a>String不可不变特性</h2><pre><code>长度及内容</code></pre><h2 id="String类常用的方法—-与StringBuilder的区别"><a href="#String类常用的方法—-与StringBuilder的区别" class="headerlink" title="String类常用的方法—-与StringBuilder的区别"></a>String类常用的方法—-与StringBuilder的区别</h2><pre><code>concat(); toUpperCase();</code></pre><h2 id="String和StringBuilder区别-String和StringBuffer区别"><a href="#String和StringBuilder区别-String和StringBuffer区别" class="headerlink" title="String和StringBuilder区别|String和StringBuffer区别"></a>String和StringBuilder区别|String和StringBuffer区别</h2><pre><code>String不可变字符串        有一个接口Comparable        不可变体现在长度及内容        有一些方法StringBuilder没有 没有concat compareTo toUpperCaseStringBuilder可变字符串        JDK1.5        有一个接口Appendable        可变字符串 没有final修饰 底层可以进行数组扩容        有一些方法string没有 append() insert() delete() reverse()</code></pre><h2 id="StringBuffer和StringBuild的不同"><a href="#StringBuffer和StringBuild的不同" class="headerlink" title="StringBuffer和StringBuild的不同"></a>StringBuffer和StringBuild的不同</h2><pre><code>stringBuffer早期版本1.0StringBuilder后来的版本1.5方法使用几乎一致早期版本 线程同步  安全性比较高 执行效率相对较低后期版本 线程非同步 安全性能比较低 执行效率相对较高</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;StringBuffer-StringBuilder&quot;&gt;&lt;a href=&quot;#StringBuffer-StringBuilder&quot; class=&quot;headerlink&quot; title=&quot;StringBuffer/StringBuilder&quot;&gt;&lt;/a&gt;StringBu
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十二）</title>
    <link href="http://yoursite.com/2020/03/23/avaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/23/avaSE基础-（二十二）/</id>
    <published>2020-03-23T14:40:39.000Z</published>
    <updated>2020-03-31T00:45:54.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h1><h1 id="String类—-gt-引用类型-java-lang包"><a href="#String类—-gt-引用类型-java-lang包" class="headerlink" title="String类—-&gt;引用类型 java.lang包"></a>String类—-&gt;引用类型 java.lang包</h1><h1 id="常见的String笔试题"><a href="#常见的String笔试题" class="headerlink" title="常见的String笔试题"></a>常见的String笔试题</h1><pre><code>==  equals方法和区别             ==可以比较基本类型 也可以比较引用类型             比较基本类型只比较值 比较引用类型比较地址             equals只能比较引用类型（方法）             默认比较地址this == obj             如果想要修改比较规则可以重写equals方法             通常重写equals方法会伴随重写hashcode方法String的不可变特性             长度及内容String与StringBuffer区别StringBuffer与StringBuilder区别String对象的存储             &quot;abc&quot;-----&gt;字符串常量池             new String（&quot;abc&quot;）---&gt;堆内存*string中的常用方法</code></pre><h1 id="存在哪-java-lang包"><a href="#存在哪-java-lang包" class="headerlink" title="存在哪  java.lang包"></a>存在哪  java.lang包</h1><pre><code>没有任何继承关系  实现三个接口Serializable,CharSequence,Comparable</code></pre><h1 id="如何构建对象"><a href="#如何构建对象" class="headerlink" title="如何构建对象"></a>如何构建对象</h1><pre><code>String str = &quot;abc&quot;; //直接将字符串常量赋值给str （字符串常量池）String str = new String();//无参函数构造方法创建空的对象String str = new String(&quot;abc&quot;);//带参String构造方法创建对象String str = new String(byte[]);//将数组中的每一个元素转化成对应的char 组合成strString str = new String(char[]);//将数组中的每一个char元素拼接成最终的String</code></pre><h1 id="String的不可变特性"><a href="#String的不可变特性" class="headerlink" title="String的不可变特性"></a>String的不可变特性</h1><pre><code>体现在两个地方 长度及内容长度-----&gt;final修饰的数组  数组长度不变 final修饰素组的地址不变内容-----&gt;private修饰的属性 不能再类外访问在String类中包含一个 数组private fianl char[] value;//存储String中的每一个字符fianl最终是不可改变的----&gt;地址不让改变 数组的长度本身不可变private私有的当前类中----&gt;数组中的内容也不能改变</code></pre><h1 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="*4.常用方法"></a>*4.常用方法</h1><pre><code>booean = equals(Obj obj);     //继承自Object类 重写啦 比较两个字符串的字面值是否相等int = hashCode();     //继承自object类 重写啦 将当前字符串的每一个char元素拆开 乘以31求和int = CompareTo(String str);    //实现Comparable接口 实现啦 按照字典（Unicode编码）索引的顺序比较String = toString();    //继承自Object 重写啦 不在输出@hashCode 字符串中的字面值</code></pre><h2 id="char-charAt-int-index"><a href="#char-charAt-int-index" class="headerlink" title="char = charAt(int index);"></a>char = charAt(int index);</h2><pre><code>返回给定index位置对应的字符int = codePointAt(int index);返回给定index位置对应字符的code码</code></pre><h2 id="int-length"><a href="#int-length" class="headerlink" title="int = length();"></a>int = length();</h2><pre><code>返回字符串的长度 （其实就是底层 char[] value属性的长度）注意：区别数组length是属性 String的length()方法  集合size()方法</code></pre><h2 id="String-concat-String-str"><a href="#String-concat-String-str" class="headerlink" title=".String = concat(String str);"></a>.String = concat(String str);</h2><pre><code>将给定的str拼接在当前String对象的后面注意：方法执行完毕需要接受返回值 String的不可变特性      concat方法与 + 拼接性能的问题      开发中若遇到频繁拼接字符串-----&gt;通常使用stringBuilder/stringBuffer</code></pre><h2 id="boolean-contains（”s”）"><a href="#boolean-contains（”s”）" class="headerlink" title="boolean = contains（”s”）;"></a>boolean = contains（”s”）;</h2><pre><code>判断给定的s在字符串中是否存在</code></pre><h2 id="statsWith-String-prefix）-nbsp-nbsp-endWith（String-suffix）"><a href="#statsWith-String-prefix）-nbsp-nbsp-endWith（String-suffix）" class="headerlink" title="statsWith(String prefix）;  &nbsp;&nbsp; endWith（String suffix）;"></a>statsWith(String prefix）; <br> &nbsp;&nbsp; endWith（String suffix）;</h2><pre><code>判断此字符串是否已XX开头/结尾</code></pre><h2 id="byte-getBytes-—-gt-getBytes-String-charsetName-char-toCharArray"><a href="#byte-getBytes-—-gt-getBytes-String-charsetName-char-toCharArray" class="headerlink" title="byte[] = getBytes();—-&gt;getBytes(String charsetName); char[] = toCharArray[];"></a>byte[] = getBytes();—-&gt;getBytes(String charsetName); char[] = toCharArray[];</h2><pre><code>将当前字符串转化为数组 “我爱你中国”“我”“爱”“你”“中”“国”</code></pre><h2 id="int-index-indexOf-int-String-str-int-fromindex"><a href="#int-index-indexOf-int-String-str-int-fromindex" class="headerlink" title="int index = indexOf(int/String str,[int fromindex]);"></a>int index = indexOf(int/String str,[int fromindex]);</h2><pre><code>四个方法重载，找寻给定元素在字符串第一次出现的索引位置 若不存在返回-1lastIndexOf(int/String str,[int fromindex]);找寻给定元素在字符串最后一次出现的索引位置 若不存在返回-1</code></pre><h2 id="boolean-isEmpty"><a href="#boolean-isEmpty" class="headerlink" title="boolean = isEmpty();"></a>boolean = isEmpty();</h2><pre><code>判断当前字符串是否为空字符串（length是否为0）注意与null之间的区别</code></pre><h2 id="replace-replaceAll-replaceFirst"><a href="#replace-replaceAll-replaceFirst" class="headerlink" title="replace(); replaceAll(); replaceFirst();"></a>replace(); replaceAll(); replaceFirst();</h2><pre><code>将给定字符串替换成另一个字符串</code></pre><h2 id="String-split（String-regex-int-limit限度界限-）"><a href="#String-split（String-regex-int-limit限度界限-）" class="headerlink" title="String[] = split（String regex, [int limit限度界限]）;"></a>String[] = split（String regex, [int limit限度界限]）;</h2><pre><code>按照正则表达式将原来的字符串拆开   String str=&quot;a-b-c-d&quot;;   String[] value = str.split(&quot;-&quot;,3);   for(String v:value){     System.out.println(v);   }  </code></pre><h2 id="String-substring-int-beginIndex-int-endIndex"><a href="#String-substring-int-beginIndex-int-endIndex" class="headerlink" title="String = substring(int beginIndex),[int endIndex]);"></a>String = substring(int beginIndex),[int endIndex]);</h2><pre><code>将当前字符串截取一部分从beginIndex开始至endIndex结束[beginIndex，endIndex)若endIndex不写 则默认到字符串最后</code></pre><h2 id="String-toUpperCase-String-toLowerCase"><a href="#String-toUpperCase-String-toLowerCase" class="headerlink" title="String = toUpperCase();String = toLowerCase();"></a>String = toUpperCase();<br>String = toLowerCase();</h2><pre><code>将全部字母转换成大写/小写</code></pre><h2 id="String-trim"><a href="#String-trim" class="headerlink" title="String = trim();"></a>String = trim();</h2><pre><code>去掉字符串前后多余的空格</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字符串相关&quot;&gt;&lt;a href=&quot;#字符串相关&quot; class=&quot;headerlink&quot; title=&quot;字符串相关&quot;&gt;&lt;/a&gt;字符串相关&lt;/h1&gt;&lt;h1 id=&quot;String类—-gt-引用类型-java-lang包&quot;&gt;&lt;a href=&quot;#String类—-gt-引用
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
</feed>
