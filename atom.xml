<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一轮明月照九洲</title>
  
  <subtitle>长将静趣观天地，自有幽怀契古今</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-24T15:58:44.354Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>我与我周旋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaSE基础 （二十五）</title>
    <link href="http://yoursite.com/2020/03/24/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/24/JavaSE基础-（二十五）/</id>
    <published>2020-03-24T14:23:31.000Z</published>
    <updated>2020-03-24T15:58:44.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合相关"><a href="#集合相关" class="headerlink" title="集合相关"></a>集合相关</h1><h2 id="变量–容器"><a href="#变量–容器" class="headerlink" title="变量–容器"></a>变量–容器</h2><pre><code>存取一个元素</code></pre><h2 id="数组–容器"><a href="#数组–容器" class="headerlink" title="数组–容器"></a>数组–容器</h2><pre><code>一组具有某种特性的数据存放在一起       存储一组元素（数据类型一致）  长度固定</code></pre><h2 id="集合–容器"><a href="#集合–容器" class="headerlink" title="集合–容器"></a>集合–容器</h2><pre><code>与数组类似 集合的长度存储之后还能改变集合用来存储一组元素</code></pre><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><pre><code>存的都是value</code></pre><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><pre><code>有序可重复</code></pre><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><pre><code>无序无重复</code></pre><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><pre><code>存储的是以key-value形式存在key无序无重复  value无序可重复</code></pre><h3 id="序：顺序"><a href="#序：顺序" class="headerlink" title="序：顺序"></a>序：顺序</h3><pre><code>添加进去的元素 取得元素的顺序一致 注意指的不是集合自己的顺序</code></pre><h3 id="重复：两个对象一致"><a href="#重复：两个对象一致" class="headerlink" title="重复：两个对象一致"></a>重复：两个对象一致</h3><h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><p>   1.ArrayList 2.LinkList 3.Vector</p><h3 id="ArrayList——-底层就是一个数组"><a href="#ArrayList——-底层就是一个数组" class="headerlink" title="ArrayList——-底层就是一个数组"></a>ArrayList——-底层就是一个数组</h3><h3 id="所属的包-java-util"><a href="#所属的包-java-util" class="headerlink" title="所属的包 java.util"></a>所属的包 java.util</h3><h3 id="如何创建对象"><a href="#如何创建对象" class="headerlink" title="如何创建对象"></a>如何创建对象</h3><pre><code>无参数构造方法 带默认参数的都构造方法 带collection参数的构造方法</code></pre><h3 id="常用的方法-—小容器"><a href="#常用的方法-—小容器" class="headerlink" title="常用的方法 —小容器"></a>常用的方法 —小容器</h3><pre><code>   存 add   取 get   删 remove   改   个数 sizeadd(E e) add(int index,E e)addAll(Collection c); add(int index,Collection c)clear();将集合内的元素全部清除boolean = contains(Object);找寻一个给定元素集合中是否拥有ensureCapacity(int minCapacity);E = get(int index);int = indexOf(Object obj); lastindexOf();isEmpty();iterator;//迭代器 1.5之后增强forremoveAll 差集 retainAll()交集addAll()并集E = set(int index,E value)int size();List = subList(int index,E value)toArray();集合变成数组toArray(T[]);trimToSize();//变成有效元素个数那么长</code></pre><h3 id="arryList底层是一个Object"><a href="#arryList底层是一个Object" class="headerlink" title="arryList底层是一个Object[]"></a>arryList底层是一个Object[]</h3><pre><code>什么类型都可以存进去取出来的时候多态效果 需要自己造型 显得用起来非常麻烦</code></pre><h3 id="JDK1-5之后—-gt-泛型"><a href="#JDK1-5之后—-gt-泛型" class="headerlink" title="JDK1.5之后—-&gt;泛型"></a>JDK1.5之后—-&gt;泛型</h3><pre><code>用来规定数据类型的,定义的时候用一个符号代替某种类型在使用的时候具体的数据类型 将定义的那个符号替换掉ArrayBox&lt;T&gt;</code></pre><h3 id="泛型可以用在哪里？"><a href="#泛型可以用在哪里？" class="headerlink" title="泛型可以用在哪里？"></a>泛型可以用在哪里？</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><pre><code>类定义的时候描述某种数据类型 集合就是这样使用</code></pre><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><pre><code>与泛型类的使用基本一致 子类实现接口时必须添加泛型public interface Text&lt;X&gt;{     public X value;}public class Son&lt;X&gt;implements Test&lt;X&gt;</code></pre><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><pre><code>方法调用时传参数 方法的泛型与类无关 带有泛型的方法可以不放在带有泛型的类中</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集合相关&quot;&gt;&lt;a href=&quot;#集合相关&quot; class=&quot;headerlink&quot; title=&quot;集合相关&quot;&gt;&lt;/a&gt;集合相关&lt;/h1&gt;&lt;h2 id=&quot;变量–容器&quot;&gt;&lt;a href=&quot;#变量–容器&quot; class=&quot;headerlink&quot; title=&quot;变量–容器&quot;&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十四）</title>
    <link href="http://yoursite.com/2020/03/24/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/24/JavaSE基础-（二十四）/</id>
    <published>2020-03-24T13:51:09.000Z</published>
    <updated>2020-03-24T15:58:51.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式-regex"><a href="#正则表达式-regex" class="headerlink" title="正则表达式 regex"></a>正则表达式 regex</h1><pre><code>Regualar有规律的   Expression表达式匹配字符串格式的</code></pre><h2 id="正则表达式通常的作用如下"><a href="#正则表达式通常的作用如下" class="headerlink" title="正则表达式通常的作用如下"></a>正则表达式通常的作用如下</h2><h3 id="字符串格式的校验"><a href="#字符串格式的校验" class="headerlink" title="字符串格式的校验"></a>字符串格式的校验</h3><pre><code>String类中提供的方法 boolean = str.match(&quot;regex&quot;);</code></pre><h3 id="字符串的拆分及替换"><a href="#字符串的拆分及替换" class="headerlink" title="字符串的拆分及替换"></a>字符串的拆分及替换</h3><pre><code>String类中提供的方法 replace split</code></pre><h3 id="字符串的查找"><a href="#字符串的查找" class="headerlink" title="字符串的查找"></a>字符串的查找</h3><pre><code>pattern模式 Matcher匹配器[abc]       abc中的一个[^abc]      不能是abc中的一个 其他都可以[a-zA-Z]     表示必须是这两个范围内的[a-z&amp;&amp;[^bc]]  表示a-z其中的一个但不能是b和c.代表任意一个字符\d digit [0-9]\D 非数字[^0-9]\S 非留白\w word单词 [0-9A-Za-z]数字或字母都可以</code></pre><h3 id="所有字符串中寻找如下规则的信息-邮政编码"><a href="#所有字符串中寻找如下规则的信息-邮政编码" class="headerlink" title="所有字符串中寻找如下规则的信息 邮政编码"></a>所有字符串中寻找如下规则的信息 邮政编码</h3><pre><code>String str = &quot;123456abc123456abc123456abc&quot;//1.利用pattern模式创建一个模式 理解为一个正则表达式对象Pattern pattern = Pattern.compile（&quot;\\d{6}&quot;）;//邮编//2.需要提供一个字符串//3.利用pattern模式对象创建一个匹配器Matcher matcher = pattern.matcher(str);//4.找寻字符串中出现满足上述格式的字串   while(matcher.find()){    System.out.println(matcher.group());//找到满足字符串格式的那一串文字</code></pre><h3 id="如下所有都用来描述字符出现的次数"><a href="#如下所有都用来描述字符出现的次数" class="headerlink" title="如下所有都用来描述字符出现的次数"></a>如下所有都用来描述字符出现的次数</h3><pre><code>？ 0-1次 [0-9]?*  0-n次 +  1-n次{n} 固定n次{n,}至少出现n次{m,n}m-n次</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;正则表达式-regex&quot;&gt;&lt;a href=&quot;#正则表达式-regex&quot; class=&quot;headerlink&quot; title=&quot;正则表达式 regex&quot;&gt;&lt;/a&gt;正则表达式 regex&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;Regualar有规律的   Expression表
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十三）</title>
    <link href="http://yoursite.com/2020/03/24/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/24/JavaSE基础-（二十三）/</id>
    <published>2020-03-24T12:54:08.000Z</published>
    <updated>2020-03-24T15:58:57.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="StringBuffer-StringBuilder"><a href="#StringBuffer-StringBuilder" class="headerlink" title="StringBuffer/StringBuilder"></a>StringBuffer/StringBuilder</h1><h2 id="所属的包"><a href="#所属的包" class="headerlink" title="所属的包"></a>所属的包</h2><pre><code>java.lang包</code></pre><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><pre><code>Serializable,CharSequence,Comparable非常特殊的类 可以像常量一样创建对象String str = &quot;abc&quot;;内存存储 &quot;abc&quot;对象 char[] valueString的不可变特性   private fianl char[] value频繁的修改内容的时候 性能不是很好</code></pre><h2 id="默认继承"><a href="#默认继承" class="headerlink" title="默认继承"></a>默认继承</h2><pre><code>obJect 实现接口Serialzable,CharSequence,AppendableStringBuffer/StringBuilder 没有compare To方法StringBuffer/StringBuilder 含有一个String没有的方法 append();拼接</code></pre><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><pre><code>可变字符串 char[] value;动态扩容</code></pre><h2 id="对象的构建"><a href="#对象的构建" class="headerlink" title="对象的构建"></a>对象的构建</h2><pre><code>无参数构造方法有参数构造方法//无参数构造方法 构建一个默认长度16个对象空间 char[] StringBuilder builder = new StringBuilder();//利用给定的参数 构建有一个自定义长度空间的对象 char[] StringBuilder builder = new StringBuilder(20);//利用带String参数的构造方法,默认数组字符长度字符串+16个长度 StringBuilder builder = new StringBuilder(&quot;abc&quot;);</code></pre><h2 id="StringBuilder中的常用方法"><a href="#StringBuilder中的常用方法" class="headerlink" title="StringBuilder中的常用方法"></a>StringBuilder中的常用方法</h2><pre><code>最主要的方法 append() 频繁的拼接字符串时候使用此方法 提高性能capcacity();字符串底层char[]的容量length();字符串有效元素个数（长度）char = charAt(int index);int = codePointAt(int index);String = substring(int start,[int end]);        注意需要接收返回值 看见取出来的字符串效果delete(int start,[int end]);        String Builder类中独有的方法String类没有        将Start到end之间的字符串删掉 不用接收返回值就看到效果啦int = indexOf(String str,[int fromindex]);int = lastindexof（String str,[int fromIndex]）        找寻给定的str字符串中第一次出现的索引位置 带重载 则从某一个位置开始找StringBuilder = deleteCharAt(int Index)        String类中没有的方法        将给定inde位置的某一字符串删除insert(int index,value);        将给定的value插入在index上replace(int start，int end，string str);        将start和end之间的部分替换成str        builder.replace(2.5,&quot;zzt&quot;)setCharAt(int index,char value);        将index位置的字符改成给定字符的valuetoString()        将StringBuilder对象 构建成一个string对象 返回trimToSize()        将数组无用的容量去掉 变成length长度的数组</code></pre><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><h3 id="StringBuilder类不一定需要"><a href="#StringBuilder类不一定需要" class="headerlink" title="StringBuilder类不一定需要"></a>StringBuilder类不一定需要</h3><pre><code>是为了避免String频繁拼接修改字符串信息时才使用的 底层是数组是可变的 提高了性能</code></pre><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><pre><code>与String类不同独有的方法append() lnsert() delete() deleteCharAt() reverse()与String类相同的方法charAt() codePointAt() indexOf() lastindexOf() replace() 名字相同 用法不一致不是很常用的方法ensureCapacity() capacity() SetLength() trimToSize() setCharAt();</code></pre><h3 id="String家族笔试中经常考察的知识点"><a href="#String家族笔试中经常考察的知识点" class="headerlink" title="String家族笔试中经常考察的知识点"></a>String家族笔试中经常考察的知识点</h3><h4 id="String所属的包-继承关系-实现接口"><a href="#String所属的包-继承关系-实现接口" class="headerlink" title="String所属的包 继承关系 实现接口"></a>String所属的包 继承关系 实现接口</h4><pre><code>java.lang包 继承Object 实现接口Serializable,CharSequence,Comparable</code></pre><h4 id="String构建方式"><a href="#String构建方式" class="headerlink" title="String构建方式"></a>String构建方式</h4><pre><code>常量 构造方法</code></pre><h4 id="String对象内存结构"><a href="#String对象内存结构" class="headerlink" title="String对象内存结构"></a>String对象内存结构</h4><pre><code>字符串常量区 new堆内存对象= = equals()区别&quot;a&quot; +&quot;b&quot;+&quot;c&quot;</code></pre><h4 id="String不可不变特性"><a href="#String不可不变特性" class="headerlink" title="String不可不变特性"></a>String不可不变特性</h4><pre><code>长度及内容</code></pre><h4 id="String类常用的方法—-与StringBuilder的区别"><a href="#String类常用的方法—-与StringBuilder的区别" class="headerlink" title="String类常用的方法—-与StringBuilder的区别"></a>String类常用的方法—-与StringBuilder的区别</h4><pre><code>concat(); toUpperCase();</code></pre><h4 id="String和StringBuilder区别-String和StringBuffer区别"><a href="#String和StringBuilder区别-String和StringBuffer区别" class="headerlink" title="String和StringBuilder区别|String和StringBuffer区别"></a>String和StringBuilder区别|String和StringBuffer区别</h4><pre><code>String不可变字符串        有一个接口Comparable        不可变体现在长度及内容        有一些方法StringBuilder没有 没有concat compareTo toUpperCaseStringBuilder可变字符串        JDK1.5        有一个接口Appendable        可变字符串 没有final修饰 底层可以进行数组扩容        有一些方法string没有 append() insert() delete() reverse()</code></pre><h4 id="StringBuffer和StringBuild的不同"><a href="#StringBuffer和StringBuild的不同" class="headerlink" title="StringBuffer和StringBuild的不同"></a>StringBuffer和StringBuild的不同</h4><pre><code>stringBuffer早期版本1.0StringBuilder后来的版本1.5方法使用几乎一致早期版本 线程同步  安全性比较高 执行效率相对较低后期版本 线程非同步 安全性能比较低 执行效率相对较高</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;StringBuffer-StringBuilder&quot;&gt;&lt;a href=&quot;#StringBuffer-StringBuilder&quot; class=&quot;headerlink&quot; title=&quot;StringBuffer/StringBuilder&quot;&gt;&lt;/a&gt;StringBu
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十二）</title>
    <link href="http://yoursite.com/2020/03/23/avaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/23/avaSE基础-（二十二）/</id>
    <published>2020-03-23T14:40:39.000Z</published>
    <updated>2020-03-23T15:47:49.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h1><h2 id="String类—-gt-引用类型-java-lang包"><a href="#String类—-gt-引用类型-java-lang包" class="headerlink" title="String类—-&gt;引用类型 java.lang包"></a>String类—-&gt;引用类型 java.lang包</h2><h3 id="0-常见的String笔试题"><a href="#0-常见的String笔试题" class="headerlink" title="0.常见的String笔试题"></a>0.常见的String笔试题</h3><pre><code>==  equals方法和区别             ==可以比较基本类型 也可以比较引用类型             比较基本类型只比较值 比较引用类型比较地址             equals只能比较引用类型（方法）             默认比较地址this == obj             如果想要修改比较规则可以重写equals方法             通常重写equals方法会伴随重写hashcode方法String的不可变特性             长度及内容String与StringBuffer区别StringBuffer与StringBuilder区别String对象的存储             &quot;abc&quot;-----&gt;字符串常量池             new String（&quot;abc&quot;）---&gt;堆内存*string中的常用方法</code></pre><h3 id="1-存在哪-java-lang包"><a href="#1-存在哪-java-lang包" class="headerlink" title="1.存在哪  java.lang包"></a>1.存在哪  java.lang包</h3><pre><code>没有任何继承关系  实现三个接口Serializable,CharSequence,Comparable</code></pre><h3 id="2-如何构建对象"><a href="#2-如何构建对象" class="headerlink" title="2.如何构建对象"></a>2.如何构建对象</h3><pre><code>String str = &quot;abc&quot;; //直接将字符串常量赋值给str （字符串常量池）String str = new String();//无参函数构造方法创建空的对象String str = new String(&quot;abc&quot;);//带参String构造方法创建对象String str = new String(byte[]);//将数组中的每一个元素转化成对应的char 组合成strString str = new String(char[]);//将数组中的每一个char元素拼接成最终的String</code></pre><h3 id="3-String的不可变特性"><a href="#3-String的不可变特性" class="headerlink" title="3.String的不可变特性"></a>3.String的不可变特性</h3><pre><code>体现在两个地方 长度及内容长度-----&gt;final修饰的数组  数组长度不变 final修饰素组的地址不变内容-----&gt;private修饰的属性 不能再类外访问在String类中包含一个 数组private fianl char[] value;//存储String中的每一个字符fianl最终是不可改变的----&gt;地址不让改变 数组的长度本身不可变private私有的当前类中----&gt;数组中的内容也不能改变</code></pre><h3 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="*4.常用方法"></a>*4.常用方法</h3><pre><code>booean = equals(Obj obj);     //继承自Object类 重写啦 比较两个字符串的字面值是否相等int = hashCode();     //继承自object类 重写啦 将当前字符串的每一个char元素拆开 乘以31求和int = CompareTo(String str);    //实现Comparable接口 实现啦 按照字典（Unicode编码）索引的顺序比较String = toString();    //继承自Object 重写啦 不在输出@hashCode 字符串中的字面值</code></pre><h3 id="5-char-charAt-int-index"><a href="#5-char-charAt-int-index" class="headerlink" title="5.char = charAt(int index);"></a>5.char = charAt(int index);</h3><pre><code>返回给定index位置对应的字符int = codePointAt(int index);返回给定index位置对应字符的code码</code></pre><h3 id="6-int-length"><a href="#6-int-length" class="headerlink" title="6.int = length();"></a>6.int = length();</h3><pre><code>返回字符串的长度 （其实就是底层 char[] value属性的长度）注意：区别数组length是属性 String的length()方法  集合size()方法</code></pre><h3 id="7-String-concat-String-str"><a href="#7-String-concat-String-str" class="headerlink" title="7.String = concat(String str);"></a>7.String = concat(String str);</h3><pre><code>将给定的str拼接在当前String对象的后面注意：方法执行完毕需要接受返回值 String的不可变特性      concat方法与 + 拼接性能的问题      开发中若遇到频繁拼接字符串-----&gt;通常使用stringBuilder/stringBuffer</code></pre><h3 id="8-boolean-contains（”s”）"><a href="#8-boolean-contains（”s”）" class="headerlink" title="8.boolean = contains（”s”）;"></a>8.boolean = contains（”s”）;</h3><pre><code>判断给定的s在字符串中是否存在</code></pre><h3 id="9-statsWith-String-prefix）-nbsp-nbsp-endWith（String-suffix）"><a href="#9-statsWith-String-prefix）-nbsp-nbsp-endWith（String-suffix）" class="headerlink" title="9.statsWith(String prefix）;  &nbsp;&nbsp; endWith（String suffix）;"></a>9.statsWith(String prefix）; <br> &nbsp;&nbsp; endWith（String suffix）;</h3><pre><code>判断此字符串是否已XX开头/结尾</code></pre><h3 id="10-byte-getBytes-—-gt-getBytes-String-charsetName-char-toCharArray"><a href="#10-byte-getBytes-—-gt-getBytes-String-charsetName-char-toCharArray" class="headerlink" title="10.byte[] = getBytes();—-&gt;getBytes(String charsetName); char[] = toCharArray[];"></a>10.byte[] = getBytes();—-&gt;getBytes(String charsetName); char[] = toCharArray[];</h3><pre><code>将当前字符串转化为数组 “我爱你中国”“我”“爱”“你”“中”“国”</code></pre><h3 id="11-int-index-indexOf-int-String-str-int-fromindex"><a href="#11-int-index-indexOf-int-String-str-int-fromindex" class="headerlink" title="11.int index = indexOf(int/String str,[int fromindex]);"></a>11.int index = indexOf(int/String str,[int fromindex]);</h3><pre><code>四个方法重载，找寻给定元素在字符串第一次出现的索引位置 若不存在返回-1lastIndexOf(int/String str,[int fromindex]);找寻给定元素在字符串最后一次出现的索引位置 若不存在返回-1</code></pre><h3 id="12-boolean-isEmpty"><a href="#12-boolean-isEmpty" class="headerlink" title="12.boolean = isEmpty();"></a>12.boolean = isEmpty();</h3><pre><code>判断当前字符串是否为空字符串（length是否为0）注意与null之间的区别</code></pre><h3 id="13-replace-replaceAll-replaceFirst"><a href="#13-replace-replaceAll-replaceFirst" class="headerlink" title="13.replace(); replaceAll(); replaceFirst();"></a>13.replace(); replaceAll(); replaceFirst();</h3><pre><code>将给定字符串替换成另一个字符串</code></pre><h3 id="14-String-split（String-regex-int-limit限度界限-）"><a href="#14-String-split（String-regex-int-limit限度界限-）" class="headerlink" title="14.String[] = split（String regex, [int limit限度界限]）;"></a>14.String[] = split（String regex, [int limit限度界限]）;</h3><pre><code>按照正则表达式将原来的字符串拆开   String str=&quot;a-b-c-d&quot;;   String[] value = str.split(&quot;-&quot;,3);   for(String v:value){     System.out.println(v);   }  </code></pre><h3 id="15-String-substring-int-beginIndex-int-endIndex"><a href="#15-String-substring-int-beginIndex-int-endIndex" class="headerlink" title="15.String = substring(int beginIndex),[int endIndex]);"></a>15.String = substring(int beginIndex),[int endIndex]);</h3><pre><code>将当前字符串截取一部分从beginIndex开始至endIndex结束[beginIndex，endIndex)若endIndex不写 则默认到字符串最后</code></pre><h3 id="16-String-toUpperCase-String-toLowerCase"><a href="#16-String-toUpperCase-String-toLowerCase" class="headerlink" title="16.String = toUpperCase();String = toLowerCase();"></a>16.String = toUpperCase();<br>String = toLowerCase();</h3><pre><code>将全部字母转换成大写/小写</code></pre><h3 id="17-String-trim"><a href="#17-String-trim" class="headerlink" title="17.String = trim();"></a>17.String = trim();</h3><pre><code>去掉字符串前后多余的空格</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字符串相关&quot;&gt;&lt;a href=&quot;#字符串相关&quot; class=&quot;headerlink&quot; title=&quot;字符串相关&quot;&gt;&lt;/a&gt;字符串相关&lt;/h1&gt;&lt;h2 id=&quot;String类—-gt-引用类型-java-lang包&quot;&gt;&lt;a href=&quot;#String类—-gt-引用
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十一）</title>
    <link href="http://yoursite.com/2020/03/23/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/23/JavaSE基础-（二十一）/</id>
    <published>2020-03-23T14:02:16.000Z</published>
    <updated>2020-03-23T15:47:41.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日期相关"><a href="#日期相关" class="headerlink" title="日期相关"></a>日期相关</h1><h2 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h2><pre><code>1.通常使用的是java.util包2.导包 拿来使用 构建对象3.通常使用的是无参构造方法 或者带long构造方法4.Date类中常用的方法     before();after();     setTime();getTime();     compareTo();5.可以处理一个Date日期的格式</code></pre><h2 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h2><pre><code>1.java.text包 需要导包2.此类是一个抽象类 不能创建对象 子类来使用3.SimpleDarteFormat类 是DateFormat的子类4.调用String参数的构造方法创建format对象       SimpleDateFormat sdf =  new Simple DateFormat(&quot;yyyyy--MM--dd HH:mm:ss&quot;)        string v = sdf.format(date.1)//通过sdf将对象格式化成你描述的样子</code></pre><h2 id="Calendar-1-1版本"><a href="#Calendar-1-1版本" class="headerlink" title="Calendar 1.1版本"></a>Calendar 1.1版本</h2><pre><code>1.所属的包 java.util 需要导包2.有构造方法 用protected修饰的 通常访问不到 通常还会调用默认的getInstance()3.常用方法        after() before()        setTime() getTime()---&gt;Date        getTimeInMills()----time        getTimeZone()----TimeZone        Calendar calendar = Calendar.getInstance();//系统当前时间的Calendar对象        Calendar里面包含一个date属性 可以操作某一个局部信息        set get        calendar.set（Calendar.YEAR,2015）;        int year = calendar.get（Calendar.YEAR）;</code></pre><h2 id="TimeZone"><a href="#TimeZone" class="headerlink" title="TimeZone"></a>TimeZone</h2><pre><code>1.java.util包2.可以通过calendar对象.getTimeZone（）获取 或 TimeZone.getDefault();3.常用方法        tz.getID();       System.out.println(tz.getDisplayName());</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;日期相关&quot;&gt;&lt;a href=&quot;#日期相关&quot; class=&quot;headerlink&quot; title=&quot;日期相关&quot;&gt;&lt;/a&gt;日期相关&lt;/h1&gt;&lt;h2 id=&quot;Date类&quot;&gt;&lt;a href=&quot;#Date类&quot; class=&quot;headerlink&quot; title=&quot;Date类&quot;&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十）</title>
    <link href="http://yoursite.com/2020/03/23/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/23/JavaSE基础-（二十）/</id>
    <published>2020-03-23T12:50:35.000Z</published>
    <updated>2020-03-23T15:47:35.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java中提供的工具类——-官方API帮助文档"><a href="#java中提供的工具类——-官方API帮助文档" class="headerlink" title="java中提供的工具类——-官方API帮助文档"></a>java中提供的工具类——-官方API帮助文档</h1><pre><code>Application  Programming interface应用程序编程接口,一些预先创建好的类及方法，目的是为了让我们更好的进行程序开发</code></pre><h2 id="与数学相关的类—-Math类"><a href="#与数学相关的类—-Math类" class="headerlink" title="与数学相关的类—-Math类"></a>与数学相关的类—-Math类</h2><pre><code>1.所属的包java.lang2.Math构造方法是私有的 我们不能直接调用创建对象3.由于Math中提供的属性方法都是static 不需要创建对象4.常用的方法           abs()返回给定数字的绝对值 （参数 int long float double）           double = ceil() 向上取整           double = floor()向下取整           double = rint() 临近的整数 如果两边距离一样则返回偶数           int = round 四舍五入的整数           max（a，b） min（a，b）参数int long float double            pow（a，b） a的b次方（参数double 返回值double）           sqrt（double a） 获取给定参数的平方根           double = random(); 随机产生一个  [0.0-1.0] 5.Math.randon()计算小数的时候精确度可能会有些损失               0-9之间的随机整数               int Value = （int）(Math.random()*10);               5.0----10.9之间的小数               （Math.random()*6)+5               0.0----0.99999 * 6               (0.0---5.49999)+5</code></pre><h2 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h2><pre><code>1.在java.util包中的类 需要import导入2.没有任何继承关系 默认继承Object类3.查找构造方法----》如何创建对象        Random r = new Random();4.类中常用的方法        r.nextInt(); 随机产生int范围内的整数  有正有负        r.nextInt(int bound);随机产生一个[0-bound]整数                 注意bound必须为正数 否则会出现如下的运行时异常                 IllegalArgumentException        r.nextFloat() 随机产生一个[0.0--1.0]        r.nextBoolean()随机产生一个boolean值 true false        //调用的方法都需要用相对应类型的变量接收值</code></pre><h2 id="UUID类"><a href="#UUID类" class="headerlink" title="UUID类"></a>UUID类</h2><pre><code>1.所属的包 java.util  需要import导入2.没有任何继承关系 默认继承Object类3.构造方法有 没有无参的 我们通常不会创建对象          UUID  uuid = UUID.randomUUID();          System.out.println(uuid.toString());//数据库表格主键primary key          产生一个32位的随机元素 每一个位置都是16进制的数字</code></pre><h2 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h2><pre><code>1.所属的包java.math  需要impor导入2.继承自Number3.如何创建对象 提供的构造方法都是带参的        通常利用String参数的构造方法创建这个类的对象        BigInteger bi = new BigInteger{&quot;123&quot;};4.类中常用的方法        做四则运算        add()  substract() multiply() divide()5.小例子 设计一个方法 用来设计给定数字的阶乘        //设计一个方法 用来设计数字的阶乘       //参数 返回值       Public BigInteger factorial(int num){            BigInteger result = new BigInteger(&quot;1&quot;);            for(int i = 1;i &lt;= num;i++){                result=result.multiply(new BigInteger(i+&quot; &quot;))        }        retrun result;      } </code></pre><h2 id="BigDecimal类-超过了double取值范围"><a href="#BigDecimal类-超过了double取值范围" class="headerlink" title="BigDecimal类  超过了double取值范围"></a>BigDecimal类  超过了double取值范围</h2><pre><code>1.所属的包  java.math包2.继承Number类3.通常可以通过 带String参数构造对象4.类中常用的方法         做四则运算         add()  substract() multiply() divide()         两个参数前面保留小数点之后的位数，后面的参数是设置的格式如何保留         对象.setScale(2,BigDecimal.ROUND_DOWN);</code></pre><h2 id="DecimalFormat——-格式化"><a href="#DecimalFormat——-格式化" class="headerlink" title="DecimalFormat——-格式化"></a>DecimalFormat——-格式化</h2><pre><code>1.所属的包 java.text2.import导入才能使用3.通过带String参数的构造方法格式化创建成一个字符串            DecimalFormat df = new DecimalFormat（&quot;000.###&quot;）;            String value = df.format(12.45);            System.out.println(value);1.</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java中提供的工具类——-官方API帮助文档&quot;&gt;&lt;a href=&quot;#java中提供的工具类——-官方API帮助文档&quot; class=&quot;headerlink&quot; title=&quot;java中提供的工具类——-官方API帮助文档&quot;&gt;&lt;/a&gt;java中提供的工具类——-官方A
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十九）</title>
    <link href="http://yoursite.com/2020/03/22/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/22/JavaSE基础-（十九）/</id>
    <published>2020-03-22T15:29:06.000Z</published>
    <updated>2020-03-22T15:58:56.288Z</updated>
    
    <content type="html"><![CDATA[<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><pre><code>1.类所在的包2.类的关系 自己默认继承 实现3，类中提供常用方法4.是否可以创建对象 调用 方法本身是静态的包装类（封装类） 1.5版本之后自动拆包byte----Byte   short----Short   int------Integer  long-----Longfloat-----Float  double-----Double char-----Character boolean----Boolean1.八个包装类都在同一个包下  java.lang包  不需要import导包自己使用2.八个包装类有六个都是与数字有关  都默认继承父类Number3.八个包装类都实现了Serializable，Comparable4.八个包装类都带有自己对应类型参数的构造方法 八个包装类中有7个（除了Character）有构造方法重载 带String类型5.创建对象  对象调用方法     有六个与数字相关的类都继承Number   xxValue();将一个包装类类型转化为对应的基本类型（拆包）Interger i1 = new Interger（10）//引用数据类型 包装类 int value = i1.intValue(); int value  = Inter.parseInt(&quot;123&quot;)  Float.parseFloat(&quot;123.45&quot;) int value  = new Integer(&quot;123&quot;);</code></pre><h3 id="经常在笔试中出现的问题"><a href="#经常在笔试中出现的问题" class="headerlink" title="经常在笔试中出现的问题"></a>经常在笔试中出现的问题</h3><pre><code>       integer i1 = 10;       integer i2 = 10;       integer i3 = new Integer(10);       integer i4 = new Integer(10);       System.out.println(i1==i2);//true       System.out.println(i1==i3);//false       System.out,println(i3==i4);//false       System.out.pritnln(i1.equals(i2));//true       System.out.pritnln(i1.equals(i3));//true       System.out.pritnln(i1.equals(i4));//true 1.==与equals()的区别  ==可以比较基本数据类型 也可以比较引用数据类型（变量中存储的内容）  如果比较基本类型比较的是变量中存储的值  如果比较的是引用类型比较的是变量中存储地址的引用  equals()是Object类中继承过来的方法==一致 如果想要改变比较规则 可以重写equals方法  由于integer类就重写了equals()所以Integer比较的是数值2.考察Integer类加载的时候有一个静态空间  空间内立即加载Integer类型的数组 内存储256个Integer对象 -128-127  如果我们用的对象范围在这之内 integer i1 = 10;直接取静态元素区中找对应的对象  如果我们用的对象范围超出了Integer i1 = 1000; 会帮我们创建一个新的Integer对象</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;包装类&quot;&gt;&lt;a href=&quot;#包装类&quot; class=&quot;headerlink&quot; title=&quot;包装类&quot;&gt;&lt;/a&gt;包装类&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1.类所在的包
2.类的关系 自己默认继承 实现
3，类中提供常用方法
4.是否可以创建对象 调用 方法本身是静态的
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十八）</title>
    <link href="http://yoursite.com/2020/03/22/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89-1/"/>
    <id>http://yoursite.com/2020/03/22/JavaSE基础-（十八）-1/</id>
    <published>2020-03-22T15:28:17.000Z</published>
    <updated>2020-03-22T15:58:30.992Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>1.成员内部类</p><pre><code>将一个类直接定义在类的里面，作为成员，与属性或方法层次一次成员内部类可以与正常类一样 使用不同的修饰符去修饰好处1.省略了一个.java文件 好处2.成员内部类可以访问外部类的所有成员 包括私有的若想要在内部类中通过对象.调用外部类成员  外部类.this.外部类成员内部类存在后 源代码进行编译 产生一个字节码 Demo$InnerDemo.class</code></pre><p>2.局部内部类</p><pre><code>将一个类定义在方法/块里面,作为成员的内部结构，与临时的局部变量一个层次局部内部类像是一个局部变量一样，不能用public protected privtae及staic只能用abstract或final局部内部类命名规则Demo$InnerTestMethod局部内部类使用的变量只能用final修饰</code></pre><p>3.匿名内部类<br><br>        成员匿名内部类<br><br>        局部匿名内部类</p><pre><code>public interface Test{          public void test();} Test t = new Test{          public void test(){          }} ;通常接口或抽象类的具体子类这样写开发中为了省略一个类文件 上诉写法比较常见匿名内部类很特殊 只有类体 没有类的所有结构（修饰符 名字 继承 实现）      不能用任何修饰符来修饰 匿名内部类也没有任何构造方法</code></pre><p>4.静态内部类</p><pre><code>成员静态内部类不需要外部类对象，通过正常的方式直接创建内部类静态元素不能访问非静态成员（自己类和外部类）</code></pre><h2 id="枚举类enum"><a href="#枚举类enum" class="headerlink" title="枚举类enum"></a>枚举类enum</h2><h4 id="一个类中的对象-认为个数有限且固定的，可以将每一个对象一一列举出来"><a href="#一个类中的对象-认为个数有限且固定的，可以将每一个对象一一列举出来" class="headerlink" title="一个类中的对象 认为个数有限且固定的，可以将每一个对象一一列举出来"></a>一个类中的对象 认为个数有限且固定的，可以将每一个对象一一列举出来</h4><pre><code> 1.试一试若没有枚举类型的时候如何动手设计（静态常量 单例模式）Day（类 当做描述星期七个对象）      private 构造方法      public static final 属性 = new      //构造方法私有        private Day(){}      //所有对象都是属性      public static final Day monday = new Day(); 2.JDK1.5版本后可以直接定义enmu类型      我们自己定义的enmu类型直接默认继承enmu（java.lang包）      我们自己定义的enmu类型不能再写extrends但是可以实现      Enum类型             有两个属性             name-------&gt;枚举对象的名字   name()获取name的属性             ordinal------&gt;枚举对象在罗列中的顺序  类似index 也从0开始 ordinal获取序列号             常用的方法             valueof()  通过给定的name获取对应的枚举对象             values()   获取全部的枚举对象----&gt;返回一个数组 Day[]             compaerTo() 可以比较两个枚举对象 int             toString()  由于这个方法没有final修饰 可以覆盖（重写）3.我们也可以在enum中描述自己的一些属性或方法      必须在enum类中第一行 描述一下枚举的样子 最后需要分号结束;      可以定义自己的属性      类创建过程中 帮我们创建枚举类型的对象      需要给枚举型提供对应样子的构造方法 方法只能private修饰 可以重载</code></pre><h3 id="内存机制问题"><a href="#内存机制问题" class="headerlink" title="内存机制问题"></a>内存机制问题</h3><pre><code>栈内存-----&gt;Person p = new Person();-----&gt;堆内存   方法区----类模板栈内存-----&gt;创建开始  用完立即回收   StackoverflowError方法区-----&gt;类 常量 静态 只有一份回收不了堆内存-----&gt;new创建的对象 Garbage Collection 垃圾回收器Runtime类之中提供了几个管理内存的方法        maxMemory        totalMemory        freeMemory        堆内存溢出错误OutOfMemoryErrorObject类中有一个finalize方法 如果重写也能看见对象回收GC系统提供的一个线程  回收算法</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;内部类&quot;&gt;&lt;a href=&quot;#内部类&quot; class=&quot;headerlink&quot; title=&quot;内部类&quot;&gt;&lt;/a&gt;内部类&lt;/h3&gt;&lt;p&gt;1.成员内部类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;将一个类直接定义在类的里面，作为成员，与属性或方法层次一次
成员内部类可以与正常类一样
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十七）</title>
    <link href="http://yoursite.com/2020/03/22/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/22/JavaSE基础-（十七）/</id>
    <published>2020-03-22T13:57:03.000Z</published>
    <updated>2020-03-22T15:58:10.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="策略者模式-Strategy-nbsp-———-行为型模式"><a href="#策略者模式-Strategy-nbsp-———-行为型模式" class="headerlink" title="策略者模式 Strategy &nbsp; ——— 行为型模式"></a>策略者模式 Strategy &nbsp; ——— 行为型模式</h2><h4 id="用来解决-执行流程固定-执行结果由于提供不同策略而不同"><a href="#用来解决-执行流程固定-执行结果由于提供不同策略而不同" class="headerlink" title="用来解决  执行流程固定 执行结果由于提供不同策略而不同"></a>用来解决  执行流程固定 执行结果由于提供不同策略而不同</h4><pre><code>              银行类                  profession（人）{  人----抽象类 接口（不能产生对象） 传递一个子类对象                  欢迎用户进来                  叫号                  办理                  离开                  欢迎您下次再来                  }             长者   年轻人  vip            //按普通设计  可能有问题              1.三个不同的人类方法名不一致（可以）              2.银行办理业务的方法写了3个            //解决上诉所述问题可以在三个人之上创建一个父类              1.解决桑个人类中相同代码 比如name属性 比如get方法之类              2.父类定义的三个方法可以是抽象类 解决了子类命名不一致问题 子类执行也不一致              3.父类可以作为参数传入银行  //主函数     public static void main (String[] args){          Bank bank = new bank ();          Person p = new Oldman(长者); //父类作为参数          bank profession（p）;//银行欢迎长者来办理业务 调的是子类对象       }   //银行三个方法写成一个       public class Bank{       //开门  等待用户进来办理业务       public void profession（Person person）{       System.out，println（person.getName()+&quot;客户进入银行啦&quot;）       person.callNumber();       person.transact();       person.leave();       }//抽象类        public abstract class Person{       protected String name;       public String getName(){        return this.name;        }        //1.进银行叫号        public abstract void callNumaber();        //2.去窗口办理        public abstract void transact();        //3.办理完毕离开啦        public abstract void leave();       }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h1&gt;&lt;h2 id=&quot;策略者模式-Strategy-nbsp-———-行为型模式&quot;&gt;&lt;a href=&quot;#策略者模式-Strategy-n
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础  （十六）</title>
    <link href="http://yoursite.com/2020/03/22/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/22/JavaSE基础-（十六）/</id>
    <published>2020-03-22T13:14:51.000Z</published>
    <updated>2020-03-22T16:07:05.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式<br></h1><h2 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式 Adapter"></a>适配器模式 Adapter</h2><pre><code>定义一个规则-------&gt;和尚 吃斋 念经 打坐 撞钟 习武适配器鲁智深 鲁达 形态丑陋 面貌凶顽 方丈说 此人上应天星 心地刚直 虽时下凶顽 命中驳杂 久后却得清净 证果非凡 汝等不及他public abstract class AbstractBox implements Box{          public booolean add(element);          public void add(int index,int element){//具体化          }          public void addAll(){//具体化          }          public int get（index）;          public int remove（index）;          public int size();          }</code></pre><h2 id="Java面向对象的四大特性"><a href="#Java面向对象的四大特性" class="headerlink" title="Java面向对象的四大特性"></a>Java面向对象的四大特性</h2><pre><code>继承 封装 多态 （抽象）</code></pre><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><pre><code>同一个对象 体现出来的多种不同形态（身份）将一种行为表现出不同效果要想实现多态的效果 需要先有继承关系</code></pre><h3 id="体现"><a href="#体现" class="headerlink" title="体现"></a>体现<br></h3><pre><code>              1.父类类型的引用  指向  子类的对象                   Person p = new Teachher();              2.该引用只能调用父类定义的属性和方法              3.如果子类中将父类的方法重写,那么调取方法后执行的结果是子类重写之后的那个结果              如果父类与子类有同名的属性           执行父类的属性              如果父类与子类有同名的方法（重载）      执行子类重写之后的方法              4.若想要调用子类中独有的成员              （强制类型转换）造型 铸型 （向上/向下转型）//把父类引用向下转型              5.造型时（强制向下转型时）可能会出现一个运行时异常              ClassCastException   造型 铸型 异常              如果想要避免造型异常可以用instanceof关键字来进行判断// O instanceof Student 对象是否属于后面类型                                      Object                          hashCode equals toString getClass......                          Animal                     name属性 eat sleep               Person                                      Pig           name属性 重eat 重sleep 独talk             name属性  重sleep          Teacher                     Student                  name属性 重eat 独有teach       name属性 重talk 独study            Object o = new Teacher();//向上转型            o.hashCode() o.toString();            Animal a = (Animal)o;//向下转型            a.hashCode() a.toString a.name a.eat() a.sleep()            Person p = (Person)o;            p.hashCode();p.name p.eat p.sleep p.talk</code></pre><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><pre><code>1.InputMismatchException  输入不匹配2.NumberFormateException  数字格式化异常3.ArrayIndexOutBoundsException  数组索引越界4.NegativeArraySizeException  数组长度负数5.NullPointerException   空指针异常6.AirthmeticException    算数异常7.ClassCastException     造型异常</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;br&gt;&lt;/h1&gt;&lt;h2 id=&quot;适配器模式-Adapter&quot;&gt;&lt;a href=&quot;#适配器模式-Adapter&quot; class=&quot;header
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础  （十五）</title>
    <link href="http://yoursite.com/2020/03/21/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/21/JavaSE基础-（十五）/</id>
    <published>2020-03-21T15:25:31.000Z</published>
    <updated>2020-03-21T16:01:12.177Z</updated>
    
    <content type="html"><![CDATA[<p>abstract  抽象类</p><pre><code>         不具体 没有执行过程 只是一个概念1.可以修饰什么        修饰方法        用abstract修饰符修饰的方法 只有方法的构造  没有方法执行体叫抽象方法        当然注意native修饰的方法虽然没有方法体 但是不是抽象方法 只是执行的过程是其他语言写的 不属于抽象类        用abstract修饰符修饰的类 叫抽象类2.修饰后有什么特点                抽象类中必须要有抽象方法吗？ 不是必须含有抽象方法        抽象方法必须放在抽象类中？ 目前来看必须要放在抽象类中（或接口中）普通类是不许有抽象方法3.研究一下什么叫抽象类  抽象类有什么特点？        1.类里面有什么 成员                  属性    可以含有一般的属性  也可以含有 private static final 等                  方法    可以含有一般方法    也可以含有 private static final 等                           注意：抽象类中允许含有抽象方法（只有方法结构 没有方法执行体）                  块      可以含有一般程序块  也可以含有static程序块                  构造方法  可以含有一般方法，包括重载        2.类如何使用  创建对象                  抽象类含有构造方法 但我们不能通过调用构造方法创建对象                  抽象类只能通过子类单继承来做事        3.类和类的关系                  抽象类-----直接单继承---抽象类   可以                  抽象类-----直接单继承---具体类   可以                  具体类-----直接单继承---抽象类   不可以（）4.小问题        抽象类中能不能没有抽象方法 全都是具体成员  可以        抽象类能不能没有具体成员 全都是抽象方法 可以 ----&gt;抽象到极致---&gt;接口        接口可以理解为是抽象类抽象到极致-------&gt;还是一个类的结构 不能用class修饰 改用interface修饰</code></pre><p>interface 接口</p><pre><code>什么是接口？接口也是一个类的结构 只不过用interface修饰 替换原有的class1.有什么      成员              属性            不能含有一般属性 只能含有公有的静态常量 public static final              方法            不能含有一般的方法 只能含有公有的抽象方法（1.8以后default修饰具体方法）              块             不能含有一般程序块 也不能含有static块（块本身就是具体的 接口中不让有具体的）              构造方法         不能含有构造方法2.如何使用   创建对象         不能创建对象         只能通过子类多实现（implements）来做事         public class A implements B,C,D{         }3.与别的类结构关系         接口不能继承别的类   最抽象         抽象类--------直接多实现-------接口  可以         具体类--------直接多实现-------接口  不可以（不能直接将抽象方法具体化）         接口----------多继承-----------接口  可以直接多实现</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;abstract  抽象类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;         不具体 没有执行过程 只是一个概念
1.可以修饰什么
        修饰方法
        用abstract修饰符修饰的方法 只有方法的构造  没有方法执行体叫抽象方法
        当然注
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十四）</title>
    <link href="http://yoursite.com/2020/03/21/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/21/JavaSE基础-（十四）/</id>
    <published>2020-03-21T15:16:13.000Z</published>
    <updated>2020-03-21T16:01:03.420Z</updated>
    
    <content type="html"><![CDATA[<p>类的加载关系</p><pre><code>存在继承关系的类 加载机制 及执行过程加载类的过程-----静态元素已经加载new Person();1.加载父类2.父类会产生自己的静态空间 属性 方法 块            执行静态块3.加载子类4.子类会产生自己的静态空间 属性 方法 块            执行静态块5.开辟对象空间  6.加载父类的非静态成员  属性 方法 块 构造方法 7.执行块 执行父类的构造方法8.加载子类的非静态成员 属性 方法 块 构造方法9.执行块 执行子类的构造方法10.将对象空间的地址引用交给变量存储</code></pre><p>native 本地的</p><pre><code>Java源代码看到native就已经再也看不到后续代码后续会调用其他编程语言C++或C执行内存操作 帮我们操作Object类中的一个方法 hashCode</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;类的加载关系&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;存在继承关系的类 加载机制 及执行过程
加载类的过程-----静态元素已经加载
new Person();
1.加载父类
2.父类会产生自己的静态空间 属性 方法 块
            执行静态块
3.加载子类
4.子类会产
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十三）</title>
    <link href="http://yoursite.com/2020/03/21/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/21/JavaSE基础-（十三）/</id>
    <published>2020-03-21T14:43:20.000Z</published>
    <updated>2020-03-21T16:01:25.886Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式<br><br>  &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;  1.设计模式不是知识点<br><br>  &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;  2.设计模式是一种设计经验的总结<br><br>  &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br>  3.设计模式用来解决某些场景下的某一类问题的—-&gt;通用的解决方案<br><br>   &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 4.有了设计模式之后  可以让代码更容易被理解 确保了复用性 可靠性 可扩展性<br>  <br><br> 设计模式分为三类</p><pre><code>1.创新型模式（5种）--------&gt;用于解决创建对象的过程 单例模式  工厂方法模式  抽象模式 工作模式 建造者模式 原型模式2.结构型模式（7种）--------&gt;把类或对象通过某种形式结合在一起 构成某种复杂或合理的结构 适配器模式 装饰者模式 代理模式 外观模式 桥接模式 组合模式 享元模式3.行为行模式（11种）------&gt;用来解决类或对象之间的交互 更合理的优化类或对象之间的关系 观察者模式 策略模式 模板模式 责任链模式 解析器模式 迭代器模式 命令模式 状态模式 备忘录模式 访问者模式 中介者模式</code></pre><p> 单例模式</p><pre><code>设计------&gt;一个类只能创建一个对象 有效减小内存占用空间设计一个系统-----&gt;百度  搜索引擎 public class Baidu{           public void 搜索（String keyword）{           } }创建一个baidu对象 new调用搜索的方法 做事情 方法只执行一遍同一时间有很多很多很多的人在使用这个系统对象------&gt;只能创建一个 堆内存就开辟了一个空间调用一次方法-----&gt;临时执行一次 方法执行空间就回收了</code></pre><p>单例模式的实现</p><pre><code> 1.私有的构造方法 2.私有的静态的当前类作为属性 3.公有的静态的方法当返回值 饿汉式（立即加载） 对象启动时就加载啦           不会产生对象就没有拿来使用的问题 空指针异常           启动项目时的对象加载过多 有些还没有使用 产生服务器承载压力问题 懒汉式（延迟加载）对象什么时候用到了 才会加载           可能会由于没有操作好 导致异常（很严谨）           启动项目时候只有需要的加载 不需要的时候还没有创建 不会浪费空间*生命周期托管（单例对象别人帮我们处理）对象加载过程交给别人    private static SingleTon;               //直接=new SingleTon()饿汉式   public static SingleTon getSingleTon(){     if(single=null){     Single = new SingleTon();            //延迟加载方式  懒汉式     }     return single;  }public static void main(String[] args){    SingleTon s1 = Singleton.getSingleTon();    }}  </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设计模式&lt;br&gt;&lt;br&gt;  &amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;  1.设计模式不是知识点&lt;br&gt;&lt;br&gt;  &amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;n
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十二）</title>
    <link href="http://yoursite.com/2020/03/21/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/21/JavaSE基础-（十二）/</id>
    <published>2020-03-21T14:07:10.000Z</published>
    <updated>2020-03-21T14:42:38.934Z</updated>
    
    <content type="html"><![CDATA[<p>权限修饰符</p><pre><code>public       公共的        本类      同包    子类  当前类的任何位置只要有对象都可以使用protected    保护的        本类      同包    子类 （通过子类对象在子类内部访问）默认不写     默认的        本类     同包private      私有的1.能修饰什么  2.范围如何权限修饰符可以用来修饰   类本身   和类中的成员（除程序块）权限修饰符用来修饰类的时候只有两个可以用 （public 默认不写）权限修饰符可以用来修饰类中的其他成员</code></pre><p>Java类和类直接的关系</p><pre><code>继承  关联 多态（抽象）</code></pre><p>封装：将一些数据或执行过程  进行一个包装<br><br>目的：保护这些数据或执行过程的安全隐藏细节，增加复用性<br><br>对属性本身的封装：<br><br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     属性私有：（封装在类中）<br><br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 提供操作属性的公有方法<br>  <br><br>特征修饰符<br></p><pre><code>1.可以修饰什么2.修饰后什么特点</code></pre><p>  final    </p><pre><code>最终的   不可更改的  修饰变量           如果在定义时没有赋初始值         给变量一次存值的机会（因为变量在栈内存空间内 没有默认值 如果不给机会 就都没法用了         一旦变量存储了一个值若用final修饰后则不让改变----相当于常量         注意变量类型是基本类型还是引用类型         如果修饰的是基本数据类型 则变量内的值不让更改 常量         如果修饰的是引用数据类型 则变量内的地址不让更改对象唯一  修饰属性         全局变量 存储在堆内存的对象空间有一个空间         属性如果没有赋值  有默认值存在         属性用final修饰后 必须给属性赋初值 否则编译报错         特点与修饰变量一致         注意变量类型是基本类型还是引用类型         如果修饰的变量是基本数据类型 则变量内的值不让更改 ---常量         如果修饰的变量是引用数据类型 则变量内地址引用不让更改---对象唯一 修饰方法         方法是最终的方法 不可更改         子类继承父类的方法 可将父类的方法重写（覆盖）         final修饰的方法 要求不可以被子类重写（覆盖） 修饰类本身         类是最终的  不可更改         此类不可被其他字类继承         通常都是一些定义好的工具类         Math Scanner Intneger String</code></pre><p> static静态的</p><pre><code>1.可以修饰：修饰属性 修饰方法 *修饰块 修饰类（内部类）2.特点：     1.静态元素在类加载时就初始化了，创建的非常早，此时没有创建对象     2.静态元素存储在静态元素区中，每一个类都有一个自己的区域，与别的类不冲突     3.静态元素只加载一次（只有一份），全部类对象及类本身共享     4.由于静态元素区加载时候，可能没有创建对象，可以通过类的名字直接访问     5.静态元素区Garbage Collection 无法管理，可以粗暴认为常驻内存     6.可以理解静态元素不属于任何一个对象，是属于类的     7.非静态成员（堆内存对象里）中可以访问静态成员（静态区）     8.静态成员中可以访问静态成员（静态区）     9.静态成员不可以访问非静态成员     10.静态元素不可以出现this或super（静态元素属于类）</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;权限修饰符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public       公共的        本类      同包    子类  当前类的任何位置只要有对象都可以使用
protected    保护的        本类      同包    子类 （通过子类对象在子类内部访问
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十一）</title>
    <link href="http://yoursite.com/2020/03/20/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/20/JavaSE基础-（十一）/</id>
    <published>2020-03-20T15:16:57.000Z</published>
    <updated>2020-03-20T15:29:08.277Z</updated>
    
    <content type="html"><![CDATA[<p>包packge（可以理解为是一个文件夹）</p><pre><code>在我们类的第一行会出现package关键字如果package和import同时出现先写package后写importpackage只能有一个import可以有多个</code></pre><p>类的关系<br>    has-a</p><pre><code>包含关系（组合 聚合 关联） 语义从亲密程度来讲不太一样组合---&gt;人的大脑  人和心脏的关系     整体和部分的关系 不可分割 要出现整体出现 要消亡整体消亡整合----&gt;汽车和轮子 电脑和主板     整体和部分的关系 创建时可能是分开的关联----&gt;人有汽车 人有电脑     整体和部分的关系 可以分割后来形成一起从Java程序来描述这样的关系 通过一个类的对象当做另一个类的属性来存储</code></pre><p>ues a &nbsp;&nbsp;&nbsp;&nbsp;(need a ) 依赖关系</p><pre><code>屠夫 杀 猪           可以做一件事情 杀猪           需要一头猪不是整体和部分的关系 某一件事情产生关系临时组合在一起 这件事情一旦做完关系就解散通过在方法中引用另一个类的对象实现</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;包packge（可以理解为是一个文件夹）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在我们类的第一行会出现package关键字
如果package和import同时出现
先写package后写import
package只能有一个import可以有多个&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>html-css-js  （二）</title>
    <link href="http://yoursite.com/2020/03/20/html-css-js-%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/20/html-css-js-（二）/</id>
    <published>2020-03-20T14:19:19.000Z</published>
    <updated>2020-03-20T15:15:27.772Z</updated>
    
    <content type="html"><![CDATA[<p>高级标签 </p><pre><code>空格标签     &amp;nbsp;左尖括号     &amp;lt;   less than右尖括号     &amp;gt;   great than换行        &lt;br&gt;划线        &lt;hr&gt;</code></pre><p>   有序列表   </p><pre><code>  &lt;ol&gt;       &lt;li&gt;苹果&lt;/li&gt;     &lt;li&gt;香蕉&lt;/li&gt;     &lt;li&gt;菠萝&lt;/li&gt;   &lt;/ol&gt;  有序表属性  &lt;ol type =&quot;a&quot;(a,A,1,i,I)  reversed = &quot;reversed&quot;  start = &quot;3&quot;&gt;  //排序可以按a，A，1,罗马小写i，罗马大写 i reversed属性表示倒序 start表示起始顺序                </code></pre><p>   *无序表 </p><pre><code>&lt;ul&gt;   &lt;li&gt;Marvel&lt;/li&gt;   &lt;li&gt;返老还童&lt;/li&gt;   &lt;li&gt;了不起的盖茨比&lt;/li&gt; &lt;/ul&gt;&lt;ul type = &quot;disc&quot; (square circle)&gt;//标签是实心圆 实心方块 空心圆</code></pre><p>   超文本链接 </p><pre><code>&lt;a herf &quot; &quot; &gt;www.baidu.com&lt;/a&gt; //hyperText reference   数字 文字 图片均可以跳转 target在当前页面打开 blank打开新页面  &lt;打电话&gt;  &lt;a herf=&quot;tel:&quot;&gt;  &lt;发邮件&gt;  &lt;a herf=&quot;mailto&quot;&gt;  &lt;协议限定符&gt;  //&lt;a herf=&quot;javascript=while(1）{alert（&quot;让你手欠&quot;）} 你点我试试呀！come on 来呀！&lt;/a&gt;</code></pre><p> 图片标签   </p><pre><code>    &lt;img src=&quot;url&quot;&gt;//可以打开网络url；本地绝对路径；本地相对路径 alt属性图片占位符（图片出错时显示信息）     title属性图片提示符（光标移动到图片显示） </code></pre><p>锚点                   </p><pre><code>anhor（实现置顶）记录位置 </code></pre><p>表单                     </p><pre><code>&lt;form method=&quot;get/post&quot; action=&quot;&quot;&gt;&lt;input type=&quot;text&quot;  name=&quot;username&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;login&quot;&gt;&lt;/form&gt;// 发送数据 需要数据名和数据内容两项  提交检验 pro/Desktop/lesson2.html?username=sunny&amp;password=123123.  md5协议进行加密         123123                     加密后&amp;@#￥&amp;￥&lt;input type =&quot;radio&quot;&gt;单选                     </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;高级标签 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;空格标签     &amp;amp;nbsp;
左尖括号     &amp;amp;lt;   less than
右尖括号     &amp;amp;gt;   great than
换行        &amp;lt;br&amp;gt;
划线        &amp;lt;
      
    
    </summary>
    
      <category term="前端基础" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十）</title>
    <link href="http://yoursite.com/2020/03/19/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/19/JavaSE基础-（十）/</id>
    <published>2020-03-19T15:03:29.000Z</published>
    <updated>2020-03-19T15:58:48.949Z</updated>
    
    <content type="html"><![CDATA[<p>类和类之间的关系</p><p>A is a B 泛化 （继承 实现）</p><p>A has a B 包含 （组合 聚合 关联）</p><p>A use a B 依赖 （依赖）need a </p><p>继承</p><pre><code>1.子类继承父类，通过一个关键字 extends2.子类的对象可以调用父类中的（public protected）属性和方法3.子类可以添加自己的属性和方法4.子类从父类继承过来的方法不能满足子类的需要，可以在子类中重写父类的方法 指内容重写5.每一个类都有一个继承类，如果extrends关键字不写，默认继承Object类6.java中继承是单个存在的（单继承）每一个类都只能有一个继承类（在extrends后面写一个类）目的是让类变得更安全，可以通过传递方式实现多继承的效果，后续还有多实现7.继承在内存中的存储形式8.关于this和super的使用</code></pre><p>   方法重写与重载</p><pre><code>   方法重写override                                 方法重载overload1.   产生两个继承关系的类                          一个类中的一组方法     子类可以写父类的方法2.特征符            final static abstract                          没有要求          父类方法是 final  子类不能重写      父类方法是 static 子类不存在      父类方法是 abstract 子类必须重写3.权限修饰符         子类可以大于等于父类                             没有要求4.返回值          子类可以小于等于父类                             没有要求5.参数             子类父类必须一致                          每一个方法参数必须不一致6.名字            子类父类必须一致                          一个类中的方法名必须一致7.异常                 运行时 编译时    如果父类方法抛出运行时异常：                         没有要求    子类可不予理会    如果父类方法抛出编译时异常：    子类抛出异常的个数和类型都少于等于父类8.方法体   子类方法内容和父类不一致              每个重载方法执行过程不一致</code></pre><p> Object类       </p><pre><code>        Object类是所有类的父类 Object类没有父类        Object方法         1.toString方法 打印输出一个对象变成字符串        public String toString() {    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());}        2.hashcode（）将对象的地址在内存中计算得到一个整数        3.equals（）用来比较两个对象的内容         == 和equals的区别         equals方法是Object类中继承的方法 默认比较地址         ==可以比较基本类型比较（值）也可以用来比较引用类型比较（地址）         如果想要改变规则可以方法重写          public boolean equals(Object obj) {    return (this == obj);}        4.getclass（）   获取对应类的映射        5.wait（）      线程进入挂起等待状态        6.notify（）     唤醒线程        7.notifyAll（）   唤醒所有        8.finalize      权限修饰符 protected在对象被GC回收时默认执行方法 相当于C++析构函数        9.clone（）     权限修饰符 protected为了克隆对象</code></pre><p> this和super的使用  </p><pre><code>1.this和super都是指代词 代替的是对象2.this代替的是当前执行方法时的那个对象 不一定是当前类的  super代替的是当前执行方法时父类的那个对象 空间内部那个3.都能调用一般属性和方法4.可以放在类成员的任一位置（属性，方法，构造，块）5.注意调用一般方法的时候来回调用（写法编译好用）执行可能产生问题 （stack overflow error）6.可调用构造方法（放在构造方法的第一行）7.this和super在构造方法中调用另一个类的构造方法不能出现在第一行8.构造方法之间不能用来互相调用（编译不好用）</code></pre><p>  <img src="/2020/03/19/JavaSE基础-（十）/%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;类和类之间的关系&lt;/p&gt;
&lt;p&gt;A is a B 泛化 （继承 实现）&lt;/p&gt;
&lt;p&gt;A has a B 包含 （组合 聚合 关联）&lt;/p&gt;
&lt;p&gt;A use a B 依赖 （依赖）need a &lt;/p&gt;
&lt;p&gt;继承&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.子类继承父类，通过一个
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>html-css-js  （一）</title>
    <link href="http://yoursite.com/2020/03/19/html-css-js-%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/19/html-css-js-（一）/</id>
    <published>2020-03-19T14:38:00.000Z</published>
    <updated>2020-03-19T15:02:14.840Z</updated>
    
    <content type="html"><![CDATA[<p>HTML 基础标签</p><p>html  （hyper text markup language） 超文本标记语言</p><pre><code>&lt;html lang = &quot;en&quot;&gt;&lt;head&gt;     &lt;meta charset = &quot;utf-8&quot;&gt;     &lt;title&gt; hello！new friend！&lt;/title&gt;&lt;/head&gt;&lt; body&gt;      Life is full of hope!      生活充满希望！&lt;/body&gt;&lt;/html&gt;</code></pre><p>  基础标签</p><pre><code>根标签 &lt;html&gt; &lt;/html&gt;头标签 &lt;head&gt; &lt;/head&gt;   浏览器设置内容标签 &lt;body&gt; &lt;/body&gt;  用户可见属性标签 &lt;meta&gt;       可对关键字赋值标题标签 &lt;title&gt; &lt;/title&gt; 设置浏览器角标段落标签 &lt;p&gt; &lt;/p&gt;字号标签 &lt;h1-6&gt; &lt;h1-6&gt;   由大到小加粗标签 &lt;strong&gt; &lt;/strong&gt;斜体标签 &lt;em&gt; &lt;/em&gt;     斜体中划线标签 &lt;dek&gt; &lt;/del&gt;地址标签 &lt;adress&gt; &lt;/adress&gt;容器标签 &lt;div&gt; &lt;/div&gt;    换行 结构化 分块明确 捆绑操作         &lt;span&gt;&lt;sapn&gt;</code></pre><p> 字符集</p><pre><code>gb2312    只收录简体gbk      包含繁体unicod    万国码utf -8    Unicode transformation format 第八版lang = &quot;en&quot; en表示英语 中文 zh</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HTML 基础标签&lt;/p&gt;
&lt;p&gt;html  （hyper text markup language） 超文本标记语言&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;html lang = &amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
     &amp;lt;meta 
      
    
    </summary>
    
      <category term="前端基础" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （九）</title>
    <link href="http://yoursite.com/2020/03/15/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/15/JavaSE基础-（九）/</id>
    <published>2020-03-15T14:04:33.000Z</published>
    <updated>2020-03-15T14:57:18.907Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象的编程思想"><a href="#面向对象的编程思想" class="headerlink" title="面向对象的编程思想"></a>面向对象的编程思想</h3><p>类——–抽象的  属性（特征）和方法（行为）</p><p>对象—–具体的</p><p>1.描述一个类</p><pre><code>属性权限修饰符  {特征修饰符}  数据类型  属性名字  {=值}方法权限修饰符  {特征修饰符}  返回值类型 方法名字（参数列表）  {抛出异常} {{方法体}}；</code></pre><p>2.创建一个对象          </p><pre><code>new  对象     调用属性   存值/取值对象.方法  调用方法   执行一次  （存储 执行）</code></pre><p>3.类的加载</p><pre><code>对象的创建属性及方法的存储方法的执行方法执行的过程中  参数返回值的传递{基本数据类型  引用数据类型的区别}</code></pre><p>4.方法的重载 overloard</p><pre><code>1.概念：一个类中的一个一组方法  相同的方法名字 不同的参数列表  构成了方法的重载参数的不同体现在  参数的个数 参数的类型 参数的顺序 三个方面2.作用为了便于记忆和调用 使得方法调用的时候更加的灵活3.自己也可以设计方法的重载  调用的时候 先通过方法的名字来定位  名字一致 通过参数列表的数据类型来定位  方法返回值  修饰符 ---- 与方法重载无关4.JDK1.5之后的  新写法 动态参数列表 ...   参数类型固定  参数的个数可以动态  0-n  使用起来类似于数组的使用 length index  int...x    int[][] x  动态参数列表的方法   对应匹配的数组类型的方法不能构成重载（本质上是一样的）  动态参数列表在方法的参数中只能存一份  且放置在参数的末尾 </code></pre><p>5.构造方法 —–做事情</p><pre><code>1.作用：只有一个  构建（构造）当前类的对象2.写法：   权限修饰符  与类名一致的方法名 （参数列表）{抛出异常}{方法体}3.用法  通过new关键字调用4.特点：      （1）每个类都有构造方法：若自己的类中没有定义系统会默认提供一个无参的构造方法，若在类中定义了构造方法，则默认无参的狗造方法被覆盖      （2）构造方法存值方法重载5.每个类都提供一个构造方法  在创建对象的时候想做一些事情可以用构造方法</code></pre><p>6.程序块  （代码块） </p><pre><code>1.作用：跟普通方法一样 做事情的2.写法：可以认为程序块是一个 没有修饰符 没有参数 没有返回值 没有名字的特殊方法{}3.用法：块需要调用才执行 我们自己调用不到（没有名字）每次我们调用构造方法之前系统就会调用一次程序块（让他执行一遍）4.特点：没有什么重载的概念 但可以在类中定义多个程序块5.可以在里面写一些程序 我想要在创建对象之前执行</code></pre><p>7.this关键字的使用</p><pre><code>1.是一个关键字  代替某一个对象 （当前调用属性或方法时的那个对象）2.this 既然指代一个对象  this 可以调用 属性 方法  this 可以调用构造方法  通过this();省略了构造方法的名字（必须与类名一致） 必须放在程序第一行  一般方法不能调用构造方法</code></pre><p>8.Scanner类</p><pre><code>              1.导包               java.util              2.创建对象         Scanner input = new Scanner(System.in);              3.做事情          int value = input.nextInt（）;                                String value = input.nextLine();            --------------------------------------------------------------------------             nextInt（nextFloat nextByte）next nextLine1.读取方式上  大家都以回车符作为结束符号          除了nextLine以外其余方法都不读取回车符2.读取的返回结果来讲    nextInt---&gt;int   nextFloat----float  nextLine---String  next--string            next 方法看到回车或空格都认为结束               输入  abc def  g              输出  abc             nextLine 只认回车是结束符              输入 abc def g              输出 abc def g</code></pre><p>8.利用包装类做string与基本类型的转化问题</p><pre><code>int value = Interger.parseInt(&quot;&quot;);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;面向对象的编程思想&quot;&gt;&lt;a href=&quot;#面向对象的编程思想&quot; class=&quot;headerlink&quot; title=&quot;面向对象的编程思想&quot;&gt;&lt;/a&gt;面向对象的编程思想&lt;/h3&gt;&lt;p&gt;类——–抽象的  属性（特征）和方法（行为）&lt;/p&gt;
&lt;p&gt;对象—–具体的&lt;/p&gt;

      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （八）</title>
    <link href="http://yoursite.com/2020/03/14/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%85%AB%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/14/JavaSE基础-（八）/</id>
    <published>2020-03-14T14:33:53.000Z</published>
    <updated>2020-03-14T15:20:08.371Z</updated>
    
    <content type="html"><![CDATA[<p>转义字符</p><pre><code>\转义字符 将身后的一个字符意思发生转换 转换特殊符号   比如 &quot; &apos; \ 转换几个特殊的字母 比如 \n换行  \r回车 \t制表符</code></pre><p>main方法</p><pre><code>public static void static (String[] args){}public 访问权限修饰符  公有的staric  特征修饰符  静态的 有且只有一份void   关键字   方法执行完没有返回值main()  方法名称  主要的主方法中的参数args参数  可否传递？1.主方法不是我们调用的 JVM虚拟机启动的时候 虚拟机调用的2.主方法里面有args参数 是一个String[]类型 我们可以传递参数进去给JVM</code></pre><p>命名规则和规约</p><p>规则</p><pre><code>字母 数字 符号 中文字母 区分大小写数字 不能开头符号 _$中文 不推荐</code></pre><p>规约</p><pre><code>类名字  首字母大写 两个单词以上 每一个首字母都大写      Test TestOne TestTwo 属性/方法/变量 驼峰式命名规约 首字母小写 两个单词以上 第二个以后的每个首字母大写构造方法  与类名一致 类中唯一的大写字母开头的方法静态常量  全部字母大写 通过 做具体说明 BOOKSTORE ADMIN包名    全部字母小写 java关键字都是小写 注意与关键字不要冲突</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转义字符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\转义字符 将身后的一个字符意思发生转换
 转换特殊符号   比如 &amp;quot; &amp;apos; \
 转换几个特殊的字母 比如 \n换行  \r回车 \t制表符&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;main方法&lt;/p&gt;
&lt;pre&gt;&lt;code
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
</feed>
