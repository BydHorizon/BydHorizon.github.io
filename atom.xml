<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一轮明月照九洲</title>
  
  <subtitle>长将静趣观天地，自有幽怀契古今</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-10T06:20:11.430Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>我与我周旋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL   (二)</title>
    <link href="http://yoursite.com/2020/04/10/MySQL-%E4%BA%8C/"/>
    <id>http://yoursite.com/2020/04/10/MySQL-二/</id>
    <published>2020-04-10T06:17:35.000Z</published>
    <updated>2020-04-10T06:20:11.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DQL：查询表中的记录"><a href="#DQL：查询表中的记录" class="headerlink" title="DQL：查询表中的记录"></a>DQL：查询表中的记录</h1><pre><code>* select * from 表名;</code></pre><h1 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h1><pre><code>select    字段列表from    表名列表where    条件列表group by    分组字段having    分组之后的条件order by    排序limit    分页限定</code></pre><h1 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h1><pre><code>1. 多个字段的查询    select 字段名1，字段名2... from 表名；    * 注意：        * 如果查询所有字段，则可以使用*来替代字段列表。2. 去除重复：    * distinct3. 计算列    * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）    * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null        * 表达式1：哪个字段需要判断是否为null        * 如果该字段为null后的替换值。4. 起别名：    * as：as也可以省略</code></pre><h1 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h1><pre><code>1. where子句后跟条件2. 运算符    * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;    * BETWEEN...AND      * IN( 集合)     * LIKE：模糊查询        * 占位符：            * _:单个任意字符            * %：多个任意字符    * IS NULL      * and  或 &amp;&amp;    * or  或 ||     * not  或 !        -- 查询年龄大于20岁        SELECT * FROM student WHERE age &gt; 20;        SELECT * FROM student WHERE age &gt;= 20;        -- 查询年龄等于20岁        SELECT * FROM student WHERE age = 20;        -- 查询年龄不等于20岁        SELECT * FROM student WHERE age != 20;        SELECT * FROM student WHERE age &lt;&gt; 20;        -- 查询年龄大于等于20 小于等于30        SELECT * FROM student WHERE age &gt;= 20 &amp;&amp;  age &lt;=30;        SELECT * FROM student WHERE age &gt;= 20 AND  age &lt;=30;        SELECT * FROM student WHERE age BETWEEN 20 AND 30;        -- 查询年龄22岁，18岁，25岁的信息        SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25        SELECT * FROM student WHERE age IN (22,18,25);        -- 查询英语成绩为null        SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断        SELECT * FROM student WHERE english IS NULL;        -- 查询英语成绩不为null        SELECT * FROM student WHERE english  IS NOT NULL;        -- 查询姓马的有哪些？ like        SELECT * FROM student WHERE NAME LIKE &apos;马%&apos;;        -- 查询姓名第二个字是化的人        SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;        -- 查询姓名是3个字的人        SELECT * FROM student WHERE NAME LIKE &apos;___&apos;;        -- 查询姓名中包含德的人        SELECT * FROM student WHERE NAME LIKE &apos;%德%&apos;;</code></pre><h1 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h1><pre><code>* 语法：order by 子句    * order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...* 排序方式：    * ASC：升序，默认的。    * DESC：降序。* 注意：    * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。</code></pre><h1 id="聚合函数：将一列数据作为一个整体，进行纵向的计算。"><a href="#聚合函数：将一列数据作为一个整体，进行纵向的计算。" class="headerlink" title="聚合函数：将一列数据作为一个整体，进行纵向的计算。"></a>聚合函数：将一列数据作为一个整体，进行纵向的计算。</h1><pre><code>1. count：计算个数    1. 一般选择非空的列：主键    2. count(*)2. max：计算最大值3. min：计算最小值4. sum：计算和5. avg：计算平均值* 注意：聚合函数的计算，排除null值。    解决方案：        1. 选择不包含非空的列进行计算        2. IFNULL函数</code></pre><h1 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询:"></a>分组查询:</h1><pre><code>1. 语法：group by 分组字段；2. 注意：    1. 分组之后查询的字段：分组字段、聚合函数    2. where 和 having 的区别？        1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来        2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。    -- 按照性别分组。分别查询男、女同学的平均分    SELECT sex , AVG(math) FROM student GROUP BY sex;    -- 按照性别分组。分别查询男、女同学的平均分,人数    SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;    --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组    SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;    --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人    SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;    SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2;</code></pre><h1 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h1><pre><code>1. 语法：limit 开始的索引,每页查询的条数;2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数    -- 每页显示3条记录     SELECT * FROM student LIMIT 0,3; -- 第1页    SELECT * FROM student LIMIT 3,3; -- 第2页    SELECT * FROM student LIMIT 6,3; -- 第3页3. limit 是一个MySQL&quot;方言&quot;                </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DQL：查询表中的记录&quot;&gt;&lt;a href=&quot;#DQL：查询表中的记录&quot; class=&quot;headerlink&quot; title=&quot;DQL：查询表中的记录&quot;&gt;&lt;/a&gt;DQL：查询表中的记录&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;* select * from 表名;&lt;/code&gt;
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL（一）</title>
    <link href="http://yoursite.com/2020/04/01/MySQL%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/04/01/MySQL（一）/</id>
    <published>2020-04-01T00:30:35.000Z</published>
    <updated>2020-04-01T00:35:22.192Z</updated>
    
    <content type="html"><![CDATA[<ol><li>数据库的基本概念</li></ol><ol start="2"><li><p>MySQL数据库软件</p><ol><li>安装</li><li>卸载</li><li>配置</li></ol></li><li><p>SQL</p></li></ol><h2 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h2><pre><code>1. 数据库的英文单词： DataBase 简称 ： DB2. 什么数据库？    * 用于存储和管理数据的仓库。3. 数据库的特点：    1. 持久化存储数据的。其实数据库就是一个文件系统    2. 方便存储和管理数据    3. 使用了统一的方式操作数据库 -- SQL4. 常见的数据库软件    * 参见《MySQL基础.pdf》</code></pre><h1 id="MySQL数据库软件"><a href="#MySQL数据库软件" class="headerlink" title="MySQL数据库软件"></a>MySQL数据库软件</h1><pre><code>1. 安装    * 参见《MySQL基础.pdf》2. 卸载    1. 去mysql的安装目录找到my.ini文件        * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;    2. 卸载MySQL    3. 删除C:/ProgramData目录下的MySQL文件夹。3. 配置    * MySQL服务启动        1. 手动。        2. cmd--&gt; services.msc 打开服务的窗口        3. 使用管理员打开cmd            * net start mysql : 启动mysql的服务            * net stop mysql:关闭mysql服务    * MySQL登录        1. mysql -uroot -p密码        2. mysql -hip -uroot -p连接目标的密码        3. mysql --host=ip --user=root --password=连接目标的密码    * MySQL退出        1. exit        2. quit    * MySQL目录结构        1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot;            * 配置文件 my.ini        2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;            * 几个概念                * 数据库：文件夹                * 表：文件                * 数据：数据</code></pre><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><pre><code>1.什么是SQL？    Structured Query Language：结构化查询语言    其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。2.SQL通用语法    1. SQL 语句可以单行或多行书写，以分号结尾。    2. 可使用空格和缩进来增强语句的可读性。    3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。    4. 3 种注释        * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有)         * 多行注释: /* 注释 */3. SQL分类    1) DDL(Data Definition Language)数据定义语言        用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等    2) DML(Data Manipulation Language)数据操作语言        用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等    3) DQL(Data Query Language)数据查询语言        用来查询数据库中表的记录(数据)。关键字：select, where 等    4) DCL(Data Control Language)数据控制语言(了解)        用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</code></pre><h2 id="DDL-操作数据库、表"><a href="#DDL-操作数据库、表" class="headerlink" title="DDL:操作数据库、表"></a>DDL:操作数据库、表</h2><pre><code>1. 操作数据库：CRUD    1. C(Create):创建        * 创建数据库：            * create database 数据库名称;        * 创建数据库，判断不存在，再创建：            * create database if not exists 数据库名称;        * 创建数据库，并指定字符集            * create database 数据库名称 character set 字符集名;        * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk            * create database if not exists db4 character set gbk;    2. R(Retrieve)：查询        * 查询所有数据库的名称:            * show databases;        * 查询某个数据库的字符集:查询某个数据库的创建语句            * show create database 数据库名称;    3. U(Update):修改        * 修改数据库的字符集            * alter database 数据库名称 character set 字符集名称;    4. D(Delete):删除        * 删除数据库            * drop database 数据库名称;        * 判断数据库存在，存在再删除            * drop database if exists 数据库名称;    5. 使用数据库        * 查询当前正在使用的数据库名称            * select database();        * 使用数据库            * use 数据库名称;2. 操作表    1. C(Create):创建        1. 语法：            create table 表名(                列名1 数据类型1,                列名2 数据类型2,                ....                列名n 数据类型n            );            * 注意：最后一列，不需要加逗号（,）            * 数据库类型：                1. int：整数类型                    * age int,                2. double:小数类型                    * score double(5,2)                3. date:日期，只包含年月日，yyyy-MM-dd                4. datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss                5. timestamp:时间错类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss                        * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值                6. varchar：字符串                    * name varchar(20):姓名最大20个字符                    * zhangsan 8个字符  张三 2个字符        * 创建表            create table student(                id int,                name varchar(32),                age int ,                score double(4,1),                birthday date,                insert_time timestamp            );        * 复制表：            * create table 表名 like 被复制的表名;              2. R(Retrieve)：查询        * 查询某个数据库中所有的表名称            * show tables;        * 查询表结构            * desc 表名;    3. U(Update):修改        1. 修改表名            alter table 表名 rename to 新的表名;        2. 修改表的字符集            alter table 表名 character set 字符集名称;        3. 添加一列            alter table 表名 add 列名 数据类型;        4. 修改列名称 类型            alter table 表名 change 列名 新列别 新数据类型;            alter table 表名 modify 列名 新数据类型;        5. 删除列            alter table 表名 drop 列名;    4. D(Delete):删除        * drop table 表名;        * drop table  if exists 表名 ;</code></pre><ul><li>客户端图形化工具：SQLYog</li></ul><h2 id="DML：增删改表中数据"><a href="#DML：增删改表中数据" class="headerlink" title="DML：增删改表中数据"></a>DML：增删改表中数据</h2><pre><code>1. 添加数据：    * 语法：        * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);    * 注意：        1. 列名和值要一一对应。        2. 如果表名后，不定义列名，则默认给所有列添加值            insert into 表名 values(值1,值2,...值n);        3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来2. 删除数据：    * 语法：        * delete from 表名 [where 条件]    * 注意：        1. 如果不加条件，则删除表中所有记录。        2. 如果要删除所有记录            1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作            2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。3. 修改数据：    * 语法：        * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];    * 注意：        1. 如果不加任何条件，则会将表中所有记录全部修改。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;数据库的基本概念&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;p&gt;MySQL数据库软件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装&lt;/li&gt;
&lt;li&gt;卸载&lt;/li&gt;
&lt;li&gt;配置&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SQL&lt;/p&gt;
&lt;/li&gt;

      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础  （三十五）</title>
    <link href="http://yoursite.com/2020/03/30/avaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%94%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/30/avaSE基础-（三十五）/</id>
    <published>2020-03-30T12:20:01.000Z</published>
    <updated>2020-03-31T01:03:53.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li>软件架构CS／BS</li><li>网络通信三要素</li><li>TCP通信</li><li>Socket套接字</li><li>ServerSocket</li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><input disabled type="checkbox"> 能够辨别UDP和TCP协议特点</li><li><input disabled type="checkbox"> 能够说出TCP协议下两个常用类名称</li><li><input disabled type="checkbox"> 能够编写TCP协议下字符串数据传输程序</li><li><input disabled type="checkbox"> 能够理解TCP协议下文件上传案例</li><li><input disabled type="checkbox"> 能够理解TCP协议下案例2</li></ul><h1 id="第一章-网络编程入门"><a href="#第一章-网络编程入门" class="headerlink" title="第一章 网络编程入门"></a>第一章 网络编程入门</h1><h2 id="1-1软件结构"><a href="#1-1软件结构" class="headerlink" title="1.1软件结构"></a>1.1软件结构</h2><ul><li><strong>C/S结构</strong> ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。</li></ul><p><img src="/2020/03/30/avaSE基础-（三十五）/1_cs.jpg" alt></p><p><strong>B/S结构</strong> ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</p><p><img src="/2020/03/30/avaSE基础-（三十五）/2_bs.jpg" alt></p><p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p><h2 id="1-2-网络通信协议"><a href="#1-2-网络通信协议" class="headerlink" title="1.2 网络通信协议"></a>1.2 网络通信协议</h2><ul><li><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</li></ul><ul><li><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</li></ul><p><img src="/2020/03/30/avaSE基础-（三十五）/3_tcp_ip.jpg" alt></p><p>上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</p><h2 id="1-3-协议分类"><a href="#1-3-协议分类" class="headerlink" title="1.3 协议分类"></a>1.3 协议分类</h2><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p><p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p><ul><li><p><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p><p>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p><p>但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。</p></li></ul><p><img src="/2020/03/30/avaSE基础-（三十五）/img%5CUDP%E9%80%9A%E4%BF%A1%E5%9B%BE%E8%A7%A3.bmp" alt="UDP通信图解"></p><p>特点:数据被限制在64kb以内，超出这个范围就不能发送了。</p><p>数据报(Datagram):网络传输的基本单位 </p><ul><li><p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p><p>在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p><ul><li>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。<ul><li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。</li><li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。</li><li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。</li></ul></li></ul></li></ul><p><img src="/2020/03/30/avaSE基础-（三十五）/4_tcp.jpg" alt></p><p>​    完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p><h2 id="1-4-网络编程三要素"><a href="#1-4-网络编程三要素" class="headerlink" title="1.4 网络编程三要素"></a>1.4 网络编程三要素</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul><li><strong>协议：</strong>计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。</li></ul><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul><li><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</li></ul><p><strong>IP地址分类</strong></p><ul><li><p>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p></li><li><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。</p><p>为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p></li></ul><p><strong>常用命令</strong></p><ul><li>查看本机IP地址，在控制台输入：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure><ul><li>检查网络是否连通，在控制台输入：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping 空格 IP地址</span><br><span class="line">ping <span class="number">220.181</span>.57.216</span><br></pre></td></tr></table></figure><p><strong>特殊的IP地址</strong></p><ul><li>本机IP地址：<code>127.0.0.1</code>、<code>localhost</code> 。</li></ul><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p><p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p><ul><li><strong>端口号：用两个字节表示的整数，它的取值范围是0~65535</strong>。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</li></ul><p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p><h1 id="第二章-TCP通信程序"><a href="#第二章-TCP通信程序" class="headerlink" title="第二章 TCP通信程序"></a>第二章 TCP通信程序</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。</p><p><strong>两端通信时步骤：</strong></p><ol><li>服务端程序，需要事先启动，等待客户端的连接。</li><li>客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。</li></ol><p><strong>在Java中，提供了两个类用于实现TCP通信程序：</strong></p><ol><li>客户端：<code>java.net.Socket</code> 类表示。创建<code>Socket</code>对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li><li>服务端：<code>java.net.ServerSocket</code> 类表示。创建<code>ServerSocket</code>对象，相当于开启一个服务，并等待客户端的连接。</li></ol><h2 id="2-2-Socket类"><a href="#2-2-Socket类" class="headerlink" title="2.2 Socket类"></a>2.2 Socket类</h2><p><code>Socket</code> 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><p><code>public Socket(String host, int port)</code> :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。  </p><blockquote><p>小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p></blockquote></li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket client = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">6666</span>);</span><br></pre></td></tr></table></figure><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ul><li><p><code>public InputStream getInputStream()</code> ： 返回此套接字的输入流。</p><ul><li>如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。</li><li>关闭生成的InputStream也将关闭相关的Socket。</li></ul></li><li><p><code>public OutputStream getOutputStream()</code> ： 返回此套接字的输出流。</p><ul><li>如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。</li><li>关闭生成的OutputStream也将关闭相关的Socket。</li></ul></li><li><p><code>public void close()</code> ：关闭此套接字。</p><ul><li>一旦一个socket被关闭，它不可再使用。</li><li>关闭此socket也将关闭相关的InputStream和OutputStream 。 </li></ul></li><li><p><code>public void shutdownOutput()</code> ： 禁用此套接字的输出流。   </p><ul><li>任何先前写出的数据将被发送，随后终止输出流。 </li></ul><h2 id="2-3-ServerSocket类"><a href="#2-3-ServerSocket类" class="headerlink" title="2.3 ServerSocket类"></a>2.3 ServerSocket类</h2></li></ul><p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public ServerSocket(int port)</code> ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。</li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure><h3 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h3><ul><li><code>public Socket accept()</code> ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 </li></ul><h2 id="2-4-简单的TCP网络程序"><a href="#2-4-简单的TCP网络程序" class="headerlink" title="2.4 简单的TCP网络程序"></a>2.4 简单的TCP网络程序</h2><h3 id="TCP通信分析图解"><a href="#TCP通信分析图解" class="headerlink" title="TCP通信分析图解"></a>TCP通信分析图解</h3><ol><li>【服务端】启动,创建ServerSocket对象，等待连接。</li><li>【客户端】启动,创建Socket对象，请求连接。</li><li>【服务端】接收连接,调用accept方法，并返回一个Socket对象。</li><li>【客户端】Socket对象，获取OutputStream，向服务端写出数据。</li><li>【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。</li></ol><blockquote><p>到此，客户端向服务端发送数据成功。</p></blockquote><p><img src="/2020/03/30/avaSE基础-（三十五）/5_%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%A1.jpg" alt></p><blockquote><p>自此，服务端向客户端回写数据。</p></blockquote><ol start="6"><li>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</li><li>【客户端】Scoket对象，获取InputStream，解析回写数据。</li><li>【客户端】释放资源，断开连接。</li></ol><h3 id="客户端向服务器发送数据"><a href="#客户端向服务器发送数据" class="headerlink" title="客户端向服务器发送数据"></a>客户端向服务器发送数据</h3><p><strong>服务端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTCP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端启动 , 等待连接 .... "</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        Socket server = ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        InputStream is = server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      <span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      <span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="keyword">int</span> len = is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        String msg = <span class="keyword">new</span> String(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="comment">//5.关闭资源.</span></span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTCP</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"客户端 发送数据"</span>);</span><br><span class="line"><span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">Socket client = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line"><span class="comment">// 2.获取流对象 . 输出流</span></span><br><span class="line">OutputStream os = client.getOutputStream();</span><br><span class="line"><span class="comment">// 3.写出数据.</span></span><br><span class="line">os.write(<span class="string">"你好么? tcp ,我来了"</span>.getBytes());</span><br><span class="line"><span class="comment">// 4. 关闭资源 .</span></span><br><span class="line">os.close();</span><br><span class="line">client.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务器向客户端回写数据"><a href="#服务器向客户端回写数据" class="headerlink" title="服务器向客户端回写数据"></a>服务器向客户端回写数据</h3><p><strong>服务端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTCP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端启动 , 等待连接 .... "</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        Socket server = ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        InputStream is = server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      <span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      <span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="keyword">int</span> len = is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        String msg = <span class="keyword">new</span> String(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">      <span class="comment">// =================回写数据=======================</span></span><br><span class="line">      <span class="comment">// 5. 通过 socket 获取输出流</span></span><br><span class="line">       OutputStream out = server.getOutputStream();</span><br><span class="line">      <span class="comment">// 6. 回写数据</span></span><br><span class="line">       out.write(<span class="string">"我很好,谢谢你"</span>.getBytes());</span><br><span class="line">      <span class="comment">// 7.关闭资源.</span></span><br><span class="line">      out.close();</span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTCP</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"客户端 发送数据"</span>);</span><br><span class="line"><span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">Socket client = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line"><span class="comment">// 2.通过Scoket,获取输出流对象 </span></span><br><span class="line">OutputStream os = client.getOutputStream();</span><br><span class="line"><span class="comment">// 3.写出数据.</span></span><br><span class="line">os.write(<span class="string">"你好么? tcp ,我来了"</span>.getBytes());</span><br><span class="line">      <span class="comment">// ==============解析回写=========================</span></span><br><span class="line">      <span class="comment">// 4. 通过Scoket,获取 输入流对象</span></span><br><span class="line">      InputStream in = client.getInputStream();</span><br><span class="line">      <span class="comment">// 5. 读取数据数据</span></span><br><span class="line">      <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">      <span class="keyword">int</span> len = in.read(b);</span><br><span class="line">      System.out.println(<span class="keyword">new</span> String(b, <span class="number">0</span>, len));</span><br><span class="line"><span class="comment">// 6. 关闭资源 .</span></span><br><span class="line">      in.close();</span><br><span class="line">os.close();</span><br><span class="line">client.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第三章-综合案例"><a href="#第三章-综合案例" class="headerlink" title="第三章 综合案例"></a>第三章 综合案例</h1><h2 id="3-1-文件上传案例"><a href="#3-1-文件上传案例" class="headerlink" title="3.1 文件上传案例"></a>3.1 文件上传案例</h2><h3 id="文件上传分析图解"><a href="#文件上传分析图解" class="headerlink" title="文件上传分析图解"></a>文件上传分析图解</h3><ol><li>【客户端】输入流，从硬盘读取文件数据到程序中。</li><li>【客户端】输出流，写出文件数据到服务端。</li><li>【服务端】输入流，读取文件数据到服务端程序。</li><li>【服务端】输出流，写出文件数据到服务器硬盘中。</li></ol><p><img src="/2020/03/30/avaSE基础-（三十五）/6_upload.jpg" alt>    </p><h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p><strong>服务端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">      ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">  <span class="comment">// 2. 建立连接 </span></span><br><span class="line">        Socket accept = serverSocket.accept();</span><br><span class="line">      <span class="comment">// 3. 创建流对象</span></span><br><span class="line">      <span class="comment">// 3.1 获取输入流,读取文件数据</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">        <span class="comment">// 3.2 创建输出流,保存到本地 .</span></span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"copy.jpg"</span>));</span><br><span class="line"><span class="comment">// 4. 读写数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5. 关闭 资源</span></span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">        accept.close();</span><br><span class="line">        System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUPload_Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 创建输入流,读取本地文件  </span></span><br><span class="line">        BufferedInputStream bis  = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.jpg"</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端 </span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">        BufferedOutputStream   bos   = <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据. </span></span><br><span class="line">        <span class="keyword">byte</span>[] b  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="keyword">int</span> len ; </span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">            bos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"文件发送完毕"</span>);</span><br><span class="line">        <span class="comment">// 3.释放资源</span></span><br><span class="line"></span><br><span class="line">        bos.close(); </span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close(); </span><br><span class="line">        System.out.println(<span class="string">"文件上传完毕 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件上传优化分析"><a href="#文件上传优化分析" class="headerlink" title="文件上传优化分析"></a>文件上传优化分析</h3><ol><li><p><strong>文件名称写死的问题</strong></p><p>服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis()+<span class="string">".jpg"</span>) <span class="comment">// 文件名称</span></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>循环接收的问题</strong></p><p>服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次接收新的连接,创建一个Socket</span></span><br><span class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</span><br><span class="line">    Socket accept = serverSocket.accept();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p><strong>效率问题</strong></p><p>服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</span><br><span class="line">    Socket accept = serverSocket.accept();</span><br><span class="line">    <span class="comment">// accept 交给子线程处理.</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      ......</span><br><span class="line">        InputStream bis = accept.getInputStream();</span><br><span class="line">      ......</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">      <span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">          <span class="comment">/* </span></span><br><span class="line"><span class="comment">          3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="string">".jpg"</span>);</span><br><span class="line">                    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                      bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//4. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信息回写分析图解"><a href="#信息回写分析图解" class="headerlink" title="信息回写分析图解"></a>信息回写分析图解</h3><p>前四步与基本文件上传一致.</p><ol start="5"><li>【服务端】获取输出流，回写数据。</li><li>【客户端】获取输入流，解析回写数据。</li></ol><p><img src="/2020/03/30/avaSE基础-（三十五）/6_upload2.jpg" alt></p><h4 id="回写实现"><a href="#回写实现" class="headerlink" title="回写实现"></a>回写实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="string">".jpg"</span>);</span><br><span class="line">                    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.=======信息回写===========================</span></span><br><span class="line">                    System.out.println(<span class="string">"back ........"</span>);</span><br><span class="line">                    OutputStream out = accept.getOutputStream();</span><br><span class="line">                    out.write(<span class="string">"上传成功"</span>.getBytes());</span><br><span class="line">                    out.close();</span><br><span class="line">                    <span class="comment">//================================</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//5. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 创建输入流,读取本地文件</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.jpg"</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据.</span></span><br><span class="line">        <span class="keyword">byte</span>[] b  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="keyword">int</span> len ;</span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 关闭输出流,通知服务端,写出数据完毕</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        System.out.println(<span class="string">"文件发送完毕"</span>);</span><br><span class="line">        <span class="comment">// 3. =====解析回写============</span></span><br><span class="line">        InputStream in = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] back = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">        in.read(back);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(back));</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="comment">// ============================</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-模拟B-S服务器-扩展知识点"><a href="#3-2-模拟B-S服务器-扩展知识点" class="headerlink" title="3.2 模拟B\S服务器(扩展知识点)"></a>3.2 模拟B\S服务器(扩展知识点)</h2><p>模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。</p><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li><p>准备页面数据，web文件夹。</p><p>复制到我们Module中，比如复制到day08中</p><p><img src="/2020/03/30/avaSE基础-（三十五）/img%5C%E5%A4%8D%E5%88%B6.png" alt></p></li><li><p>我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8000</span>);</span><br><span class="line">    Socket socket = server.accept();</span><br><span class="line">    InputStream in = socket.getInputStream();</span><br><span class="line">       <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len = in.read(bytes);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">    socket.close();</span><br><span class="line">    server.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/30/avaSE基础-（三十五）/img%5C%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE.jpg" alt></p></li><li><p>服务器程序中字节输入流可以读取到浏览器发来的请求信息</p><p><img src="/2020/03/30/avaSE基础-（三十五）/img%5C%E8%AF%BB%E5%8F%96%E8%AE%BF%E9%97%AE%E4%BF%A1%E6%81%AF.jpg" alt></p></li></ol><p>GET/web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转换流,读取浏览器请求第一行</span></span><br><span class="line">BufferedReader readWb = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">String requst = readWb.readLine();</span><br><span class="line"><span class="comment">//取出请求资源的路径</span></span><br><span class="line">String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line"><span class="comment">//去掉web前面的/</span></span><br><span class="line">String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">System.out.println(path);</span><br></pre></td></tr></table></figure><h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>服务端实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端  启动 , 等待连接 .... "</span>);</span><br><span class="line">        <span class="comment">// 创建ServerSocket 对象</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        <span class="comment">// 转换流读取浏览器的请求消息</span></span><br><span class="line">        BufferedReader readWb = <span class="keyword">new</span></span><br><span class="line">        BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">        String requst = readWb.readLine();</span><br><span class="line">        <span class="comment">// 取出请求资源的路径</span></span><br><span class="line">        String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="comment">// 去掉web前面的/</span></span><br><span class="line">        String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 读取客户端请求的资源文件</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line">        <span class="comment">// 字节输出流,将文件写会客户端</span></span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 写入HTTP协议响应头,固定写法</span></span><br><span class="line">        out.write(<span class="string">"HTTP/1.1 200 OK\r\n"</span>.getBytes());</span><br><span class="line">        out.write(<span class="string">"Content-Type:text/html\r\n"</span>.getBytes());</span><br><span class="line">        <span class="comment">// 必须要写入空行,否则浏览器不解析</span></span><br><span class="line">        out.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        out.close();</span><br><span class="line">        readWb.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问效果"><a href="#访问效果" class="headerlink" title="访问效果"></a>访问效果</h3><ul><li><strong>火狐</strong></li></ul><p><img src="/2020/03/30/avaSE基础-（三十五）/%E6%95%88%E6%9E%9C%E5%9B%BE1.png" alt></p><blockquote><p>小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。</p></blockquote><p>发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。</p><p>浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket socket = server.accept();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Web(socket)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Web</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Web</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket=socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//转换流,读取浏览器请求第一行</span></span><br><span class="line">                BufferedReader readWb = <span class="keyword">new</span></span><br><span class="line">                        BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String requst = readWb.readLine();</span><br><span class="line">                <span class="comment">//取出请求资源的路径</span></span><br><span class="line">                String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line">                System.out.println(Arrays.toString(strArr));</span><br><span class="line">                String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">                System.out.println(path);</span><br><span class="line"></span><br><span class="line">                FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">                System.out.println(fis);</span><br><span class="line">                <span class="keyword">byte</span>[] bytes= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line">                <span class="comment">//向浏览器 回写数据</span></span><br><span class="line">                OutputStream out = socket.getOutputStream();</span><br><span class="line">                out.write(<span class="string">"HTTP/1.1 200 OK\r\n"</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">"Content-Type:text/html\r\n"</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">                <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    out.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">                &#125;</span><br><span class="line">                fis.close();</span><br><span class="line">                out.close();</span><br><span class="line">                readWb.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>访问效果：</strong></p><p><img src="/2020/03/30/avaSE基础-（三十五）/%E6%95%88%E6%9E%9C%E5%9B%BE2.png" alt>图解：</p><p><img src="/2020/03/30/avaSE基础-（三十五）/img%5CBS%E9%80%9A%E4%BF%A1.bmp" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络编程&quot;&gt;&lt;a href=&quot;#网络编程&quot; class=&quot;headerlink&quot; title=&quot;网络编程&quot;&gt;&lt;/a&gt;网络编程&lt;/h1&gt;&lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （三十四）</title>
    <link href="http://yoursite.com/2020/03/30/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%B8%89%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/30/JavaSE基础-（三十四）/</id>
    <published>2020-03-30T11:36:48.000Z</published>
    <updated>2020-03-30T12:03:30.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Annocation（注释-注解）"><a href="#Annocation（注释-注解）" class="headerlink" title="Annocation（注释 注解）"></a>Annocation（注释 注解）</h1><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><pre><code>单行注释 //多行注释 /*   */文档注释 /**  */</code></pre><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="注解的写法"><a href="#注解的写法" class="headerlink" title="注解的写法"></a>注解的写法</h2><pre><code>@xxxx[{一些信息}]</code></pre><h2 id="注解放在哪里"><a href="#注解放在哪里" class="headerlink" title="注解放在哪里"></a>注解放在哪里</h2><pre><code>类的上面  属性的上面 方法的上面 构造方法的上面 参数的前面</code></pre><h2 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h2><pre><code>1.用来充当注释的作用（仅仅是一个文字说明）@deprecated2.用来做代码的检测（验证）    @Override3.可以携带一些信息（内容）    文件.properties.xml 注解</code></pre><h2 id="Java中有一些写好的注解给我们使用"><a href="#Java中有一些写好的注解给我们使用" class="headerlink" title="Java中有一些写好的注解给我们使用"></a>Java中有一些写好的注解给我们使用</h2><pre><code>@Deprecated   用来说明方法是废弃的@Override     用来做代码检测 检测此方法是否重写@SuppressWarnings(信息)  String[]  {&quot;&quot;}如果数组内的元素只有一个长度  可以省略()unused   变量定义后未被使用serial   类实现了序列化接口  不添加序列化ID号rawtypes  集合没有定义泛型deprecation 方法以废弃*unchecked  出现了泛型问题 可以不检测all       包含以上所有（不推荐）</code></pre><h2 id="注解中可以携带信息-可以不携带"><a href="#注解中可以携带信息-可以不携带" class="headerlink" title="注解中可以携带信息 可以不携带"></a>注解中可以携带信息 可以不携带</h2><pre><code>信息不能随便写 信息类型只能是如下的类型1.基本数据类型2.String数据类型3.枚举数据类型4.注解类型@5.数组类型[] 数组的内部需要加上的四种类型</code></pre><h2 id="如何自己描述一个注解类型"><a href="#如何自己描述一个注解类型" class="headerlink" title="如何自己描述一个注解类型"></a>如何自己描述一个注解类型</h2><pre><code>1.通过@interface 定义个新的注解类型2.发现写法与接口非常相似  可以描述public static final 的属性 比较少见  可以描述public abstract的方法 方法返回值必须有 返回值类型是如上那些3.我们自己定义的注解拿来使用     光定义还不够还需要做很多细致的说明（需要利用java提供好的注解来说明）     元注解（也是注解 不是拿来使用的 是用来说明注解）     @target 描述当前的注解可以放在哪里写     @retention 描述当前的这个注解存在什么作用域中的            源代码文件----&gt;编译----&gt;字节码文件----&gt;加载---&gt;内存执行            SOURCE                    CLASS                  RUNTIME     @Inherited  描述当前这个注解能否被子类对象继承     @Document   描述这个注解能否生成文档</code></pre><h2 id="我们使用自己描述的注解"><a href="#我们使用自己描述的注解" class="headerlink" title="我们使用自己描述的注解"></a>我们使用自己描述的注解</h2><pre><code>问题1.注解里面描述了一个方法 方法没有参数 方法有返回值String[]     使用注解的时候让我们传递参数     理解为 注解的方法做事 将我们传递的参数 搬运走了给了别人问题2.使用别人写好的注解不用写方法名 我们自己定义的方法必须写名字     如果我们自己定义的注解 只有一个方法名字叫value     在使用的时候可以省略方法名     如果传递的信息是一个数组 数组内只有一个元素 可以省略{}     如果是两个以上 每一个方法必须写名字</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Annocation（注释-注解）&quot;&gt;&lt;a href=&quot;#Annocation（注释-注解）&quot; class=&quot;headerlink&quot; title=&quot;Annocation（注释 注解）&quot;&gt;&lt;/a&gt;Annocation（注释 注解）&lt;/h1&gt;&lt;h1 id=&quot;注释&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （三十三）</title>
    <link href="http://yoursite.com/2020/03/30/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/30/JavaSE基础-（三十三）/</id>
    <published>2020-03-30T00:05:21.000Z</published>
    <updated>2020-03-30T12:03:32.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反射-reflect"><a href="#反射-reflect" class="headerlink" title="反射 reflect"></a>反射 reflect</h1><h2 id="类是用来描述一组类"><a href="#类是用来描述一组类" class="headerlink" title="类是用来描述一组类"></a>类是用来描述一组类</h2><h2 id="反射机制认为是描述一组类"><a href="#反射机制认为是描述一组类" class="headerlink" title="反射机制认为是描述一组类"></a>反射机制认为是描述一组类</h2><pre><code>Class           用来描述类本身Package         用来描述所属类的包Field           用来描述类中的属性Method          用来描述类的方法Constructor     用来描述类中的构造方法Annotation      用来描述类中的注解</code></pre><h1 id="如何获取Class"><a href="#如何获取Class" class="headerlink" title="如何获取Class"></a>如何获取Class</h1><pre><code>如何下三种方式Class    clazz = Class.for.Name(&quot;包名.类名&quot;)Class    clazz = 类名.class;Class    clazz = 对象.getClass();//Object类中的方法</code></pre><h1 id="Class中的常用方法"><a href="#Class中的常用方法" class="headerlink" title="Class中的常用方法"></a>Class中的常用方法</h1><pre><code>int result = getModifiers();   获取类的修饰符（权限 特征）每一个修饰符 用一个整数来进行表示0开始----0-1-2-4-8-16-32--64-128-256-512-10240---默认不写  1---public         2---private    4---protected 8---static16---final    32----sychronized  64---voliate   128---trasnsient256---native  512---interface    1024---abstractString name = getName(); 获取名字String simpleName = getSimpleName();简单名Package p = getPackage();p.getName();Class sclazz = getSuperClass();//获取父类Class[] classes = getModifiers();Object obj = newInstance();//默认调用无参构造方法创建对象Filed f = getField(&quot;属性名&quot;);Field[] fs = getField();如上两个方法只能获取公有属性 但是包含继承过来父类属性getDeclaredField(&quot;属性&quot;)Field[] fs =getDeclaredFields();如上的两个方法能获取公有和私有的属性 但是只能获取本类中的属性</code></pre><h1 id="Filed类中常用方法"><a href="#Filed类中常用方法" class="headerlink" title="Filed类中常用方法"></a>Filed类中常用方法</h1><pre><code>int = getModifers()Class = getType()String = getName()操作属性 向里面存值set(对象，值）操作属性 从里面取值值 = get(对象)对象 =new():// 创建对象空间 当前对象空间有自己的一套元素（属性 方法）    setAccessable（true）可以修改属性设备操作</code></pre><h1 id="如何操作类中的方法"><a href="#如何操作类中的方法" class="headerlink" title="如何操作类中的方法"></a>如何操作类中的方法</h1><pre><code>Class类中的方法Method m = class.getMethod(&quot;方法名&quot;，Class...参数类型);  获取公有方法（自己类+父类）Method[] = clazz.getMethod();获取所有的方法（公有 自己+父类）Method = getDeclaredMethod（&quot;方法名字&quot;，参数类型class...）获取所有的方法（自己类 公有 私有）Method = getDeclaredMethods()   获取全部的方法（自己类 公有加私有）获取构造方法Construct = clazz.getConstructor（class...参数类型）</code></pre><h1 id="Method类中常用的方法"><a href="#Method类中常用的方法" class="headerlink" title="Method类中常用的方法"></a>Method类中常用的方法</h1><pre><code>int mm = m.getModififers()//获取方法的修饰符（权限+特征）Class mrt = m.getReturnType();//获取返回值数据类型String mn= m.getName();//获取方法名字Class[] mpts = m.getParameterTypes();//获取方法参数列表的类型Class[] mets = m.getExceptionTypes();//获取方法抛出异常类型如何操作方法调用方法 让他执行一次Object result = invoke（对象.执行方法需要传递的所有参数）若方法是私有方法 不许与操作可以设置setAccessable（True）设置方法使用权准入</code></pre><h1 id="Constructor类中的常用方法"><a href="#Constructor类中的常用方法" class="headerlink" title="Constructor类中的常用方法"></a>Constructor类中的常用方法</h1><pre><code>con.getModifiers();con.getName();con.getParamenterTyper();con.getExceptionTypers()如何操作构造方法执行一次 创建对象Object = newInstance（执行构造方法时的所有参数）;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;反射-reflect&quot;&gt;&lt;a href=&quot;#反射-reflect&quot; class=&quot;headerlink&quot; title=&quot;反射 reflect&quot;&gt;&lt;/a&gt;反射 reflect&lt;/h1&gt;&lt;h2 id=&quot;类是用来描述一组类&quot;&gt;&lt;a href=&quot;#类是用来描述一组类&quot; c
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （三十二）</title>
    <link href="http://yoursite.com/2020/03/29/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/29/JavaSE基础-（三十二）/</id>
    <published>2020-03-29T13:33:41.000Z</published>
    <updated>2020-03-30T12:03:33.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主线程-系统线程"><a href="#主线程-系统线程" class="headerlink" title="主线程  系统线程"></a>主线程  系统线程</h1><h1 id="用户线程-main"><a href="#用户线程-main" class="headerlink" title="用户线程 main"></a>用户线程 main</h1><h1 id="守护线程-GC"><a href="#守护线程-GC" class="headerlink" title="守护线程 GC"></a>守护线程 GC</h1><h1 id="线程——操作系统级别-CPU"><a href="#线程——操作系统级别-CPU" class="headerlink" title="线程——操作系统级别 CPU"></a>线程——操作系统级别 CPU</h1><h1 id="如何在Java中创建线程-让线程执行-多线程"><a href="#如何在Java中创建线程-让线程执行-多线程" class="headerlink" title="如何在Java中创建线程 让线程执行 多线程"></a>如何在Java中创建线程 让线程执行 多线程</h1><h1 id="掌握线程的几种不同状态以及如何切换"><a href="#掌握线程的几种不同状态以及如何切换" class="headerlink" title="掌握线程的几种不同状态以及如何切换"></a>掌握线程的几种不同状态以及如何切换</h1><pre><code>new      start()     cpu分配run()      wait()       exception over 创建线程----就绪状态---执行状态------等待/挂起----------异常/消亡               |                          |               |__________________________|                      notify/notifyAll唤醒</code></pre><h1 id="实现线程的过程"><a href="#实现线程的过程" class="headerlink" title="实现线程的过程"></a>实现线程的过程</h1><h2 id="自己描述一个类"><a href="#自己描述一个类" class="headerlink" title="自己描述一个类"></a>自己描述一个类</h2><h2 id="基础父类Thead"><a href="#基础父类Thead" class="headerlink" title="基础父类Thead"></a>基础父类Thead</h2><h2 id="重写run方法"><a href="#重写run方法" class="headerlink" title="重写run方法"></a>重写run方法</h2><h2 id="new一个线程对象-调用start方法让线程进入就绪状态"><a href="#new一个线程对象-调用start方法让线程进入就绪状态" class="headerlink" title="new一个线程对象 调用start方法让线程进入就绪状态"></a>new一个线程对象 调用start方法让线程进入就绪状态</h2><h1 id="实现线程的过程-1"><a href="#实现线程的过程-1" class="headerlink" title="实现线程的过程"></a>实现线程的过程</h1><h2 id="自己描述一个类-1"><a href="#自己描述一个类-1" class="headerlink" title="自己描述一个类"></a>自己描述一个类</h2><h2 id="实现一个父类接口Runnerable"><a href="#实现一个父类接口Runnerable" class="headerlink" title="实现一个父类接口Runnerable"></a>实现一个父类接口Runnerable</h2><h2 id="重写run方法-1"><a href="#重写run方法-1" class="headerlink" title="重写run方法"></a>重写run方法</h2><h2 id="new一个线程对象-需要创建Thead将自己包起来-然后调用Start"><a href="#new一个线程对象-需要创建Thead将自己包起来-然后调用Start" class="headerlink" title="new一个线程对象 需要创建Thead将自己包起来 然后调用Start()"></a>new一个线程对象 需要创建Thead将自己包起来 然后调用Start()</h2><h1 id="生产者和消费者模型"><a href="#生产者和消费者模型" class="headerlink" title="生产者和消费者模型"></a>生产者和消费者模型</h1><h2 id="通过这个模型-成功演示出-线程的安全问题"><a href="#通过这个模型-成功演示出-线程的安全问题" class="headerlink" title="通过这个模型 成功演示出 线程的安全问题"></a>通过这个模型 成功演示出 线程的安全问题</h2><pre><code>两个消费者 同时访问一个仓库对象 仓库内只有一个元素的时候两个消费者 并发访问 会有可能产生抢夺资源的问题</code></pre><h2 id="自己解决一下线程安全的问题"><a href="#自己解决一下线程安全的问题" class="headerlink" title="自己解决一下线程安全的问题"></a>自己解决一下线程安全的问题</h2><pre><code>让仓库对象被线程访问的时候 仓库对象被锁定仓库对象只能被一个线程所访问 其他对象处于等待状态特征修饰符synchronized 同步 一个时间段只有一个线程能访问</code></pre><h2 id="线程安全锁两种写法"><a href="#线程安全锁两种写法" class="headerlink" title="线程安全锁两种写法"></a>线程安全锁两种写法</h2><h3 id="将synchronized关键字-放在方法结构上"><a href="#将synchronized关键字-放在方法结构上" class="headerlink" title="将synchronized关键字 放在方法结构上"></a>将synchronized关键字 放在方法结构上</h3><pre><code>public synchronized void get(){}锁定的是调用方法时的那个对象</code></pre><h3 id="将synchronized关键字-方法在（构造方法内部）的内部"><a href="#将synchronized关键字-方法在（构造方法内部）的内部" class="headerlink" title="将synchronized关键字 方法在（构造方法内部）的内部"></a>将synchronized关键字 方法在（构造方法内部）的内部</h3><pre><code>public void get(){     好多代码     synchronzied（对象）{     好多代码     }     好多代码}</code></pre><h2 id="我们觉得return-不是很好"><a href="#我们觉得return-不是很好" class="headerlink" title="我们觉得return 不是很好"></a>我们觉得return 不是很好</h2><pre><code>应该让线程的不同状态来回切换执行 等待 执行 等待wait() Object类中的方法对象.wait();对象.wait();不是当前对象wait              访问当前这个对象的线程wait notify notifyAll p.setPriority(10);   p.getPriorty(); 产生一个类似假死的状态 所有的线程进入等待状态 没有线程做事</code></pre><h1 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h1><h2 id="程序-进程-线程-概念的区别"><a href="#程序-进程-线程-概念的区别" class="headerlink" title="程序 进程 线程 概念的区别"></a>程序 进程 线程 概念的区别</h2><h2 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h2><h2 id="线程的几种状态-如何切换"><a href="#线程的几种状态-如何切换" class="headerlink" title="线程的几种状态 如何切换"></a>线程的几种状态 如何切换</h2><h2 id="sleep方法-和-wait方法区别"><a href="#sleep方法-和-wait方法区别" class="headerlink" title="sleep方法 和  wait方法区别"></a>sleep方法 和  wait方法区别</h2><pre><code>1.类    Thead类                       Object类2.调用  静态 类名                       对象3，理解  那个位置调用                    对象调用的方法      那个线程等待                    访问对象的其他线程等待4.唤醒   不需要别人                     需要其他对象调用notiy唤醒5.锁    不会释放锁                      等会会释放锁</code></pre><h1 id="比较重要的方法-join"><a href="#比较重要的方法-join" class="headerlink" title="比较重要的方法 join"></a>比较重要的方法 join</h1><pre><code>设计一个模型1.有两个线程 One   Two  Two加入到One里面2.设计模型的时候  two线程在one的run里面创建 保证两个先后顺序3.Two.join();  无参数==0; 有参数==2000         two.join(0){         while(two.isAlive()){                    Two.wait（0）；//访问Two的线程进入等待状态         }</code></pre><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="一旦对象锁定-不释放的情况下其他对象都需要等待-有可能会产生死锁的效果"><a href="#一旦对象锁定-不释放的情况下其他对象都需要等待-有可能会产生死锁的效果" class="headerlink" title="一旦对象锁定 不释放的情况下其他对象都需要等待 有可能会产生死锁的效果"></a>一旦对象锁定 不释放的情况下其他对象都需要等待 有可能会产生死锁的效果</h2><h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><h2 id="解决死锁的问题"><a href="#解决死锁的问题" class="headerlink" title="解决死锁的问题"></a>解决死锁的问题</h2><h3 id="礼让—–-gt-产生时间差"><a href="#礼让—–-gt-产生时间差" class="headerlink" title="礼让—–&gt;产生时间差"></a>礼让—–&gt;产生时间差</h3><h3 id="不要产生公用对象问题"><a href="#不要产生公用对象问题" class="headerlink" title="不要产生公用对象问题"></a>不要产生公用对象问题</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;主线程-系统线程&quot;&gt;&lt;a href=&quot;#主线程-系统线程&quot; class=&quot;headerlink&quot; title=&quot;主线程  系统线程&quot;&gt;&lt;/a&gt;主线程  系统线程&lt;/h1&gt;&lt;h1 id=&quot;用户线程-main&quot;&gt;&lt;a href=&quot;#用户线程-main&quot; class=&quot;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础  （三十一）</title>
    <link href="http://yoursite.com/2020/03/26/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/26/JavaSE基础-（三十一）/</id>
    <published>2020-03-26T15:25:56.000Z</published>
    <updated>2020-03-29T13:24:59.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习文件流"><a href="#学习文件流" class="headerlink" title="学习文件流"></a>学习文件流</h1><h2 id="文件流按照读取或写入的单位（字节数）大小来区分"><a href="#文件流按照读取或写入的单位（字节数）大小来区分" class="headerlink" title="文件流按照读取或写入的单位（字节数）大小来区分"></a>文件流按照读取或写入的单位（字节数）大小来区分</h2><h2 id="字节型文件流（1字节）"><a href="#字节型文件流（1字节）" class="headerlink" title="字节型文件流（1字节）"></a>字节型文件流（1字节）</h2><h3 id="FileInputStream-FileOutputStream"><a href="#FileInputStream-FileOutputStream" class="headerlink" title="FileInputStream/FileOutputStream"></a>FileInputStream/FileOutputStream</h3><h2 id="字符型文件流（2-字节–1字符）"><a href="#字符型文件流（2-字节–1字符）" class="headerlink" title="字符型文件流（2-字节–1字符）"></a>字符型文件流（2-字节–1字符）</h2><h3 id="FileReader-FileWriter"><a href="#FileReader-FileWriter" class="headerlink" title="FileReader/FileWriter"></a>FileReader/FileWriter</h3><h1 id="字节型文件输入流"><a href="#字节型文件输入流" class="headerlink" title="字节型文件输入流"></a>字节型文件输入流</h1><h2 id="了解一下继承关系-inputStream类-字节型输入流的父类"><a href="#了解一下继承关系-inputStream类-字节型输入流的父类" class="headerlink" title="了解一下继承关系 inputStream类 字节型输入流的父类"></a>了解一下继承关系 inputStream类 字节型输入流的父类</h2><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="调用一个带File类型的构造方法"><a href="#调用一个带File类型的构造方法" class="headerlink" title="调用一个带File类型的构造方法"></a>调用一个带File类型的构造方法</h3><h3 id="调用一个带String类型的构造方法"><a href="#调用一个带String类型的构造方法" class="headerlink" title="调用一个带String类型的构造方法"></a>调用一个带String类型的构造方法</h3><h2 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h2><pre><code>int code = read(); 每次从流管道中读取一个字节 返回字节码的code码int count = read(byte[] )每次从流管道中读取若干字节 存入数组内 返回有效元素skip（long n）跳过几个字节 读取多线程————————&gt;利用几个线程同时读取文件*close()   将流管道关闭---必须要做 最好放在fianlly里 注意代码的健壮性 严谨性</code></pre><h1 id="字节型文件输出流"><a href="#字节型文件输出流" class="headerlink" title="字节型文件输出流"></a>字节型文件输出流</h1><h2 id="FileOutput-将数据写入文件中"><a href="#FileOutput-将数据写入文件中" class="headerlink" title="FileOutput 将数据写入文件中"></a>FileOutput 将数据写入文件中</h2><h2 id="java-io"><a href="#java-io" class="headerlink" title="java.io"></a>java.io</h2><h2 id="继承OutputStream-所有字节输出型的父类"><a href="#继承OutputStream-所有字节输出型的父类" class="headerlink" title="继承OutputStream 所有字节输出型的父类"></a>继承OutputStream 所有字节输出型的父类</h2><h2 id="创建对象-1"><a href="#创建对象-1" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="调用一个带file参数-还有file-Boolean重载"><a href="#调用一个带file参数-还有file-Boolean重载" class="headerlink" title="调用一个带file参数 还有file Boolean重载"></a>调用一个带file参数 还有file Boolean重载</h3><h3 id="调用一个带String参数-还有String-boolean-重载"><a href="#调用一个带String参数-还有String-boolean-重载" class="headerlink" title="调用一个带String参数 还有String boolean 重载"></a>调用一个带String参数 还有String boolean 重载</h3><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><pre><code>writr(int code);将给定的code对应的字符写入文件“=”write(byte[]) 将数组中的全部字节写入文集 getByte()flush() 将管道内的字节推入(刷新)文件close() 注意在finaly类中关闭</code></pre><h1 id="字符型文件流"><a href="#字符型文件流" class="headerlink" title="字符型文件流"></a>字符型文件流</h1><h2 id="FileReader-FileWriter-1"><a href="#FileReader-FileWriter-1" class="headerlink" title="FileReader   FileWriter"></a>FileReader   FileWriter</h2><h2 id="只能操作存文本文件（右键打开方式-记事本打开-能看懂）-txt"><a href="#只能操作存文本文件（右键打开方式-记事本打开-能看懂）-txt" class="headerlink" title="只能操作存文本文件（右键打开方式 记事本打开 能看懂）.txt"></a>只能操作存文本文件（右键打开方式 记事本打开 能看懂）.txt</h2><h1 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h1><h2 id="java-io包"><a href="#java-io包" class="headerlink" title="java.io包"></a>java.io包</h2><h2 id="继承-InputStreamReader-Reader"><a href="#继承-InputStreamReader-Reader" class="headerlink" title="继承 InputStreamReader Reader"></a>继承 InputStreamReader Reader</h2><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><h3 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h3><h3 id="read-char"><a href="#read-char" class="headerlink" title="read(char[])"></a>read(char[])</h3><h1 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h1><h2 id="java-io包-1"><a href="#java-io包-1" class="headerlink" title="java.io包"></a>java.io包</h2><h2 id="继承OutputStreamWriter-Writer"><a href="#继承OutputStreamWriter-Writer" class="headerlink" title="继承OutputStreamWriter Writer"></a>继承OutputStreamWriter Writer</h2><h2 id="构造方法-带file参数-带file-boolean参数"><a href="#构造方法-带file参数-带file-boolean参数" class="headerlink" title="构造方法 带file参数 带file,boolean参数"></a>构造方法 带file参数 带file,boolean参数</h2><h2 id="nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-带String参数-带String，boolean参数"><a href="#nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-带String参数-带String，boolean参数" class="headerlink" title="&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;带String参数 带String，boolean参数"></a>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;带String参数 带String，boolean参数</h2><h2 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h2><pre><code>writer（int）writer（char[]）writer（String）int count = read(char[]);close() flush()</code></pre><h1 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h1><h2 id="在管道中内增加缓存的数据"><a href="#在管道中内增加缓存的数据" class="headerlink" title="在管道中内增加缓存的数据"></a>在管道中内增加缓存的数据</h2><h2 id="让我们使用流读取的文字更加流畅"><a href="#让我们使用流读取的文字更加流畅" class="headerlink" title="让我们使用流读取的文字更加流畅"></a>让我们使用流读取的文字更加流畅</h2><h2 id="高级流—–》创建通过低级流"><a href="#高级流—–》创建通过低级流" class="headerlink" title="高级流—–》创建通过低级流"></a>高级流—–》创建通过低级流</h2><pre><code>BufferedInputStream/BufferedOutputStreamBufferedReader/BufferedWriterBUfferedInPutStream构建方式 使用低级流构建基本上使用与低级流完全一致read()skip()available()close() BufferedOutStream构建方式 使用低级流构建 注意缓冲流构建的时候没有boolean类型的参数基本使用与低级流的方法完全一致read()skip()available()close()BufferedOutputStream</code></pre><h1 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h1><h2 id="对象的序列化-反序列化"><a href="#对象的序列化-反序列化" class="headerlink" title="对象的序列化/反序列化"></a>对象的序列化/反序列化</h2><h2 id="为什么要有文件"><a href="#为什么要有文件" class="headerlink" title="为什么要有文件"></a>为什么要有文件</h2><pre><code>文件永久保存信息    很多数据存入文件-----数据持久化</code></pre><h2 id="如果按照以行为单位写信息"><a href="#如果按照以行为单位写信息" class="headerlink" title="如果按照以行为单位写信息"></a>如果按照以行为单位写信息</h2><h3 id="好处在于每一行记录的信息都是相关的"><a href="#好处在于每一行记录的信息都是相关的" class="headerlink" title="好处在于每一行记录的信息都是相关的"></a>好处在于每一行记录的信息都是相关的</h3><h3 id="信息我们可以读出来-直接看懂文件"><a href="#信息我们可以读出来-直接看懂文件" class="headerlink" title="信息我们可以读出来 直接看懂文件"></a>信息我们可以读出来 直接看懂文件</h3><h3 id="不好在于第一不一定安全-直接看懂"><a href="#不好在于第一不一定安全-直接看懂" class="headerlink" title="不好在于第一不一定安全 直接看懂"></a>不好在于第一不一定安全 直接看懂</h3><h3 id="不好在于只能记录String信息-不一定能记录一些动作（方法）"><a href="#不好在于只能记录String信息-不一定能记录一些动作（方法）" class="headerlink" title="不好在于只能记录String信息 不一定能记录一些动作（方法）"></a>不好在于只能记录String信息 不一定能记录一些动作（方法）</h3><h3 id="读取出来的信息-String——-gt-Person"><a href="#读取出来的信息-String——-gt-Person" class="headerlink" title="读取出来的信息 String——&gt;Person"></a>读取出来的信息 String——&gt;Person</h3><h3 id="如果能将对象拆分成字节码直接写入文件"><a href="#如果能将对象拆分成字节码直接写入文件" class="headerlink" title="如果能将对象拆分成字节码直接写入文件"></a>如果能将对象拆分成字节码直接写入文件</h3><h2 id="将对象直接存入文件中—–对象流"><a href="#将对象直接存入文件中—–对象流" class="headerlink" title="将对象直接存入文件中—–对象流"></a>将对象直接存入文件中—–对象流</h2><h1 id="为什么要重写toString方法"><a href="#为什么要重写toString方法" class="headerlink" title="为什么要重写toString方法"></a>为什么要重写toString方法</h1><h2 id="toString-方法默认是打印对象和hashcode码"><a href="#toString-方法默认是打印对象和hashcode码" class="headerlink" title="toString 方法默认是打印对象和hashcode码"></a>toString 方法默认是打印对象和hashcode码</h2><h2 id="当输出为一个对象名的时候"><a href="#当输出为一个对象名的时候" class="headerlink" title="当输出为一个对象名的时候"></a>当输出为一个对象名的时候</h2><h2 id="重写toString方法可以打印对象的值"><a href="#重写toString方法可以打印对象的值" class="headerlink" title="重写toString方法可以打印对象的值"></a>重写toString方法可以打印对象的值</h2><h1 id="对象序列化与反序列化"><a href="#对象序列化与反序列化" class="headerlink" title="对象序列化与反序列化"></a>对象序列化与反序列化</h1><h2 id="对象的序列化指的是"><a href="#对象的序列化指的是" class="headerlink" title="对象的序列化指的是"></a>对象的序列化指的是</h2><h3 id="将一个完整的对象-拆分成字节碎片-记录在文件中"><a href="#将一个完整的对象-拆分成字节碎片-记录在文件中" class="headerlink" title="将一个完整的对象 拆分成字节碎片 记录在文件中"></a>将一个完整的对象 拆分成字节碎片 记录在文件中</h3><h2 id="对象的反序列化指的是"><a href="#对象的反序列化指的是" class="headerlink" title="对象的反序列化指的是"></a>对象的反序列化指的是</h2><h3 id="将文件中记录的对象随便-反过来组合一个完整的对象"><a href="#将文件中记录的对象随便-反过来组合一个完整的对象" class="headerlink" title="将文件中记录的对象随便 反过来组合一个完整的对象"></a>将文件中记录的对象随便 反过来组合一个完整的对象</h3><h2 id="如果想要将对象序列化到文件中"><a href="#如果想要将对象序列化到文件中" class="headerlink" title="如果想要将对象序列化到文件中"></a>如果想要将对象序列化到文件中</h2><h3 id="需要对象实现Serializable接口"><a href="#需要对象实现Serializable接口" class="headerlink" title="需要对象实现Serializable接口"></a>需要对象实现Serializable接口</h3><h3 id="是一个示意性的接口"><a href="#是一个示意性的接口" class="headerlink" title="是一个示意性的接口"></a>是一个示意性的接口</h3><h2 id="如果要实现反序列化"><a href="#如果要实现反序列化" class="headerlink" title="如果要实现反序列化"></a>如果要实现反序列化</h2><h3 id="需要给对象提供一个序列化的版本号-1-7版本—-gt-String-1-8—-gt-String"><a href="#需要给对象提供一个序列化的版本号-1-7版本—-gt-String-1-8—-gt-String" class="headerlink" title="需要给对象提供一个序列化的版本号 1.7版本—&gt;String 1.8—&gt;String"></a>需要给对象提供一个序列化的版本号 1.7版本—&gt;String 1.8—&gt;String</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;学习文件流&quot;&gt;&lt;a href=&quot;#学习文件流&quot; class=&quot;headerlink&quot; title=&quot;学习文件流&quot;&gt;&lt;/a&gt;学习文件流&lt;/h1&gt;&lt;h2 id=&quot;文件流按照读取或写入的单位（字节数）大小来区分&quot;&gt;&lt;a href=&quot;#文件流按照读取或写入的单位（字节数）
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础  （三十）</title>
    <link href="http://yoursite.com/2020/03/26/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%B8%89%E5%8D%81%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/26/JavaSE基础-（三十）/</id>
    <published>2020-03-26T14:28:17.000Z</published>
    <updated>2020-03-26T15:59:06.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="I-O相关-输入-输出-流（数据流动）"><a href="#I-O相关-输入-输出-流（数据流动）" class="headerlink" title="I/O相关 输入/输出 流（数据流动）"></a>I/O相关 输入/输出 流（数据流动）</h1><h2 id="数据流动的方向-读数据-输入input-写数据（输出output）"><a href="#数据流动的方向-读数据-输入input-写数据（输出output）" class="headerlink" title="数据流动的方向 读数据(输入input) 写数据（输出output）"></a>数据流动的方向 读数据(输入input) 写数据（输出output）</h2><h2 id="文件流-字符流-数组流-对象流-网络流"><a href="#文件流-字符流-数组流-对象流-网络流" class="headerlink" title="文件流 字符流 数组流 对象流 网络流"></a>文件流 字符流 数组流 对象流 网络流</h2><h1 id="什么叫文件"><a href="#什么叫文件" class="headerlink" title="什么叫文件"></a>什么叫文件</h1><h2 id="一种电脑的存储形式"><a href="#一种电脑的存储形式" class="headerlink" title="一种电脑的存储形式"></a>一种电脑的存储形式</h2><h2 id="文件有不同的格式-txt-doc-ppt-mp4-rar-…"><a href="#文件有不同的格式-txt-doc-ppt-mp4-rar-…" class="headerlink" title="文件有不同的格式 .txt .doc .ppt .mp4 .rar …"></a>文件有不同的格式 .txt .doc .ppt .mp4 .rar …</h2><h2 id="文件夹—–目录路径"><a href="#文件夹—–目录路径" class="headerlink" title="文件夹—–目录路径"></a>文件夹—–目录路径</h2><h2 id="File—–-gt-与电脑上的文件夹产生一一对应的映射关系"><a href="#File—–-gt-与电脑上的文件夹产生一一对应的映射关系" class="headerlink" title="File—–&gt;与电脑上的文件夹产生一一对应的映射关系"></a>File—–&gt;与电脑上的文件夹产生一一对应的映射关系</h2><h2 id="File是一个类"><a href="#File是一个类" class="headerlink" title="File是一个类"></a>File是一个类</h2><h2 id="java-io包"><a href="#java-io包" class="headerlink" title="java.io包"></a>java.io包</h2><h2 id="文件或目录路径名的抽象形式"><a href="#文件或目录路径名的抽象形式" class="headerlink" title="文件或目录路径名的抽象形式"></a>文件或目录路径名的抽象形式</h2><h2 id="File与真实硬盘中的文件或文件夹-不是同一个东西"><a href="#File与真实硬盘中的文件或文件夹-不是同一个东西" class="headerlink" title="File与真实硬盘中的文件或文件夹 不是同一个东西"></a>File与真实硬盘中的文件或文件夹 不是同一个东西</h2><h2 id="File是内存中的一个对象-lt-—–映射—-gt-磁盘上的文件或文件夹"><a href="#File是内存中的一个对象-lt-—–映射—-gt-磁盘上的文件或文件夹" class="headerlink" title="File是内存中的一个对象&lt;—–映射—-&gt;磁盘上的文件或文件夹"></a>File是内存中的一个对象&lt;—–映射—-&gt;磁盘上的文件或文件夹</h2><h2 id="File类中的常用方法"><a href="#File类中的常用方法" class="headerlink" title="File类中的常用方法"></a>File类中的常用方法</h2><pre><code>canRead() canWrite() isHidden() isFile() isDirectory()length() 获取文件中的字节数lastModified()获取文件最后的修改时间----&gt;毫秒值*String path = getAbstractPath() 获取文件的绝对路径 D://test//Test.txt绝对路径&lt;---&gt;相对路径绝对路径可以通过完整字符串 定位盘符 文件夹 文件相对路径没有盘符的写法 当前工程（项目）所在的位置寻找              C：\Users\Administator\ideaProjects\TestFile\src*String name = getName()获取文件名字 Test.txt*creatNewFile() 创建新的文件*mkdir 创建新的文件夹 外层没有 不能创建*mkdirs 创建新的文件夹 外层没有 自动创建String pname = getParent() 获取当前file的父亲file名字*File file = getParent() 获取当前file父亲的对象String[] names = list() 获取当前file所有儿子的名字*File[]files = listFiles() 获取当前file所有儿子对象*boolean = delete() 删除文件或空的文件及 不能删除带元素的文件夹</code></pre><h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;I-O相关-输入-输出-流（数据流动）&quot;&gt;&lt;a href=&quot;#I-O相关-输入-输出-流（数据流动）&quot; class=&quot;headerlink&quot; title=&quot;I/O相关 输入/输出 流（数据流动）&quot;&gt;&lt;/a&gt;I/O相关 输入/输出 流（数据流动）&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础  （二十九）</title>
    <link href="http://yoursite.com/2020/03/25/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/25/JavaSE基础-（二十九）/</id>
    <published>2020-03-25T15:20:45.000Z</published>
    <updated>2020-03-31T01:25:00.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异常-错误"><a href="#异常-错误" class="headerlink" title="异常/错误"></a>异常/错误</h1><h2 id="程序运行过程中，可能会发生一些不被期望的效果，肯定会阻止我们的程序按指令去执行"><a href="#程序运行过程中，可能会发生一些不被期望的效果，肯定会阻止我们的程序按指令去执行" class="headerlink" title="程序运行过程中，可能会发生一些不被期望的效果，肯定会阻止我们的程序按指令去执行"></a>程序运行过程中，可能会发生一些不被期望的效果，肯定会阻止我们的程序按指令去执行</h2><h2 id="这种不被预期出现的效果，肯定需要抛出来告诉我们"><a href="#这种不被预期出现的效果，肯定需要抛出来告诉我们" class="headerlink" title="这种不被预期出现的效果，肯定需要抛出来告诉我们"></a>这种不被预期出现的效果，肯定需要抛出来告诉我们</h2><h2 id="在JAVA中有一个定义好的Throwable（可以抛出的）"><a href="#在JAVA中有一个定义好的Throwable（可以抛出的）" class="headerlink" title="在JAVA中有一个定义好的Throwable（可以抛出的）"></a>在JAVA中有一个定义好的Throwable（可以抛出的）</h2><h1 id="Error错误"><a href="#Error错误" class="headerlink" title="Error错误"></a>Error错误</h1><h2 id="通常是一些物理性的，JVM虚拟机本身出现的问题，程序指令是处理不了的"><a href="#通常是一些物理性的，JVM虚拟机本身出现的问题，程序指令是处理不了的" class="headerlink" title="通常是一些物理性的，JVM虚拟机本身出现的问题，程序指令是处理不了的"></a>通常是一些物理性的，JVM虚拟机本身出现的问题，程序指令是处理不了的</h2><h1 id="Exception异常"><a href="#Exception异常" class="headerlink" title="Exception异常"></a>Exception异常</h1><h2 id="是一种不正常的现象-通常是给定的指令程序产生了一些不合规范的事情"><a href="#是一种不正常的现象-通常是给定的指令程序产生了一些不合规范的事情" class="headerlink" title="是一种不正常的现象,通常是给定的指令程序产生了一些不合规范的事情"></a>是一种不正常的现象,通常是给定的指令程序产生了一些不合规范的事情</h2><h1 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h1><h2 id="Error（错误）"><a href="#Error（错误）" class="headerlink" title="Error（错误）"></a>Error（错误）</h2><h3 id="StackOverflowError"><a href="#StackOverflowError" class="headerlink" title="StackOverflowError"></a>StackOverflowError</h3><h3 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h3><h2 id="Exception-异常"><a href="#Exception-异常" class="headerlink" title="Exception(异常)"></a>Exception(异常)</h2><h3 id="RuntimeException（运行时）"><a href="#RuntimeException（运行时）" class="headerlink" title="RuntimeException（运行时）"></a>RuntimeException（运行时）</h3><h3 id="IOExceotion"><a href="#IOExceotion" class="headerlink" title="IOExceotion"></a>IOExceotion</h3><h1 id="异常的分支体系"><a href="#异常的分支体系" class="headerlink" title="异常的分支体系"></a>异常的分支体系</h1><h2 id="运行时异常（非检查异常）"><a href="#运行时异常（非检查异常）" class="headerlink" title="运行时异常（非检查异常）"></a>运行时异常（非检查异常）</h2><pre><code>Error和RuntimeException都算作运行时异常javac编译的时候，不会提示发现的在程序编写的时候不要求必须做处理，如果我们愿意可以添加处理手段（try throws）要求大家出现这样的异常的时候，知道怎么产生及如何修改1.InputMisMatchExceotin  输入不匹配        int value = input.nextInt();// abc2.NumberFormatException  数字格式化        int value = Integer.parseInt(&quot;123.45&quot;)3.NegativeArraySizeException 数组长度负数        int Array = new int[-2]4.NullPointerException 空指针异常        int[][] array = new int[3][];        array[0][0] = 10;        Person p = null;        p.getName();5.AirthmeticExceotion 数字异常  10/0  整数不允许除0 infinity小数除0会产生无穷6.ClassCastException 造型异常       Person p = new Teacher();       Student s = (Student) p;7.ArrayIndexOutOfBoundsException 数组索引越界       int[] array ={1,2,3};       array[5];8.StringIndexOutOfBoundsException 字符串越界       String str = &quot;abc&quot;;       str.charAt(5);9.IndexOutOfBoundsException 集合越界       List家族       ArrayList list = new ArrayList();       list.add();list.add();ist.add();       list.get(5);10.IllegalArguementException 非法参数异常       ArrayList list = new ArrayList(-1);</code></pre><h2 id="编译时异常（检查异常）"><a href="#编译时异常（检查异常）" class="headerlink" title="编译时异常（检查异常）"></a>编译时异常（检查异常）</h2><pre><code>除了Error和RuntimeException以外的其他异常javac编译的时候 强制要求我们必须为这样的异常处理（try或throws）因为这样的异常在程序运行中可能会产生问题异常产生后后续的所有执行就被停止啦1.InterruptException            try{                 Thead.sleep(5000);            }catch(Exception e){            }</code></pre><h2 id="添加处理异常的手段"><a href="#添加处理异常的手段" class="headerlink" title="添加处理异常的手段"></a>添加处理异常的手段</h2><h3 id="处理异常不是异常消失了"><a href="#处理异常不是异常消失了" class="headerlink" title="处理异常不是异常消失了"></a>处理异常不是异常消失了</h3><h3 id="处理异常指的是-处理掉异常之后-后续的代码不会因为此异常停止执行"><a href="#处理异常指的是-处理掉异常之后-后续的代码不会因为此异常停止执行" class="headerlink" title="处理异常指的是 处理掉异常之后 后续的代码不会因为此异常停止执行"></a>处理异常指的是 处理掉异常之后 后续的代码不会因为此异常停止执行</h3><h1 id="两种手段"><a href="#两种手段" class="headerlink" title="两种手段"></a>两种手段</h1><h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try{}catch(){}{finally{}}"></a>try{}catch(){}{finally{}}</h2><h3 id="try不能单独出现"><a href="#try不能单独出现" class="headerlink" title="try不能单独出现"></a>try不能单独出现</h3><h3 id="后面必须添加catch或finally"><a href="#后面必须添加catch或finally" class="headerlink" title="后面必须添加catch或finally"></a>后面必须添加catch或finally</h3><h3 id="catch有一组括号（NullPointerException）目的是为了捕获一组异常"><a href="#catch有一组括号（NullPointerException）目的是为了捕获一组异常" class="headerlink" title="catch有一组括号（NullPointerException）目的是为了捕获一组异常"></a>catch有一组括号（NullPointerException）目的是为了捕获一组异常</h3><h3 id="catch可以有多个存在"><a href="#catch可以有多个存在" class="headerlink" title="catch可以有多个存在"></a>catch可以有多个存在</h3><pre><code>捕获的异常直接没有任何的继承关系捕获的异常需要从小到大捕获</code></pre><h3 id="finally-不是必须存在的-若存在则必须执行"><a href="#finally-不是必须存在的-若存在则必须执行" class="headerlink" title="finally 不是必须存在的 若存在则必须执行"></a>finally 不是必须存在的 若存在则必须执行</h3><h2 id="fianl-fianlly-fianlizae-区别"><a href="#fianl-fianlly-fianlizae-区别" class="headerlink" title="fianl fianlly fianlizae 区别"></a>fianl fianlly fianlizae 区别</h2><h2 id="fianl-特征修饰符-修饰变量-属性-方法-类"><a href="#fianl-特征修饰符-修饰变量-属性-方法-类" class="headerlink" title="fianl 特征修饰符 修饰变量 属性 方法 类"></a>fianl 特征修饰符 修饰变量 属性 方法 类</h2><h3 id="修饰变量-基本类型-值不能改变-引用类型-地址不能改变（如果变量没有初值-给一次赋初值的机会）"><a href="#修饰变量-基本类型-值不能改变-引用类型-地址不能改变（如果变量没有初值-给一次赋初值的机会）" class="headerlink" title="修饰变量 基本类型 值不能改变 引用类型 地址不能改变（如果变量没有初值 给一次赋初值的机会）"></a>修饰变量 基本类型 值不能改变 引用类型 地址不能改变（如果变量没有初值 给一次赋初值的机会）</h3><h3 id="修饰属性-特点与修饰变量相似（要求必须给属性赋初值-否则编译报错）"><a href="#修饰属性-特点与修饰变量相似（要求必须给属性赋初值-否则编译报错）" class="headerlink" title="修饰属性 特点与修饰变量相似（要求必须给属性赋初值 否则编译报错）"></a>修饰属性 特点与修饰变量相似（要求必须给属性赋初值 否则编译报错）</h3><h3 id="修饰方法-不能被子类重写"><a href="#修饰方法-不能被子类重写" class="headerlink" title="修饰方法 不能被子类重写"></a>修饰方法 不能被子类重写</h3><h3 id="修饰类-不能被其他子类继承"><a href="#修饰类-不能被其他子类继承" class="headerlink" title="修饰类 不能被其他子类继承"></a>修饰类 不能被其他子类继承</h3><h2 id="fianlly-处理异常的手段的一部分"><a href="#fianlly-处理异常的手段的一部分" class="headerlink" title="fianlly 处理异常的手段的一部分"></a>fianlly 处理异常的手段的一部分</h2><h3 id="try-catch-后面的一个部分"><a href="#try-catch-后面的一个部分" class="headerlink" title="try()catch(){}后面的一个部分"></a>try()catch(){}后面的一个部分</h3><h3 id="这个部分可有可无-如果只能含有一部分-且必须执行"><a href="#这个部分可有可无-如果只能含有一部分-且必须执行" class="headerlink" title="这个部分可有可无 如果只能含有一部分 且必须执行"></a>这个部分可有可无 如果只能含有一部分 且必须执行</h3><h2 id="finalize-是Object类中的一个protected方法"><a href="#finalize-是Object类中的一个protected方法" class="headerlink" title="finalize 是Object类中的一个protected方法"></a>finalize 是Object类中的一个protected方法</h2><h3 id="对象没有任何引用指向的时候—-会被GC回收"><a href="#对象没有任何引用指向的时候—-会被GC回收" class="headerlink" title="对象没有任何引用指向的时候—-会被GC回收"></a>对象没有任何引用指向的时候—-会被GC回收</h3><h3 id="当对象回收的时候-默认调用finalize方法"><a href="#当对象回收的时候-默认调用finalize方法" class="headerlink" title="当对象回收的时候 默认调用finalize方法"></a>当对象回收的时候 默认调用finalize方法</h3><h3 id="若想看到回收的效果-可以重写-public-void-finalize"><a href="#若想看到回收的效果-可以重写-public-void-finalize" class="headerlink" title="若想看到回收的效果 可以重写 public void finalize(){}"></a>若想看到回收的效果 可以重写 public void finalize(){}</h3><h3 id="处理异常放在方法内部可能还会有小问题"><a href="#处理异常放在方法内部可能还会有小问题" class="headerlink" title="处理异常放在方法内部可能还会有小问题"></a>处理异常放在方法内部可能还会有小问题</h3><h3 id="如果在方法内部含有返回值"><a href="#如果在方法内部含有返回值" class="headerlink" title="如果在方法内部含有返回值"></a>如果在方法内部含有返回值</h3><h3 id="不管返回值return关键字在哪里-finally一定会执行完毕"><a href="#不管返回值return关键字在哪里-finally一定会执行完毕" class="headerlink" title="不管返回值return关键字在哪里 finally一定会执行完毕"></a>不管返回值return关键字在哪里 finally一定会执行完毕</h3><h3 id="返回值的具体结果-看情况"><a href="#返回值的具体结果-看情况" class="headerlink" title="返回值的具体结果 看情况"></a>返回值的具体结果 看情况</h3><h2 id="throws-抛出"><a href="#throws-抛出" class="headerlink" title="throws 抛出"></a>throws 抛出</h2><h3 id="异常只能在方法上抛出-属性是不能处理异常的"><a href="#异常只能在方法上抛出-属性是不能处理异常的" class="headerlink" title="异常只能在方法上抛出 属性是不能处理异常的"></a>异常只能在方法上抛出 属性是不能处理异常的</h3><h3 id="方法-构造"><a href="#方法-构造" class="headerlink" title="方法 构造"></a>方法 构造</h3><h3 id="方法-可以抛出不止一个异常，通过，隔开"><a href="#方法-可以抛出不止一个异常，通过，隔开" class="headerlink" title="方法 可以抛出不止一个异常，通过，隔开"></a>方法 可以抛出不止一个异常，通过，隔开</h3><h3 id="抛出的异常与多个catch类似-要么没关系-要么先抛出小异常"><a href="#抛出的异常与多个catch类似-要么没关系-要么先抛出小异常" class="headerlink" title="抛出的异常与多个catch类似 要么没关系 要么先抛出小异常"></a>抛出的异常与多个catch类似 要么没关系 要么先抛出小异常</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;异常-错误&quot;&gt;&lt;a href=&quot;#异常-错误&quot; class=&quot;headerlink&quot; title=&quot;异常/错误&quot;&gt;&lt;/a&gt;异常/错误&lt;/h1&gt;&lt;h2 id=&quot;程序运行过程中，可能会发生一些不被期望的效果，肯定会阻止我们的程序按指令去执行&quot;&gt;&lt;a href=&quot;#程序
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十八）</title>
    <link href="http://yoursite.com/2020/03/25/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/25/JavaSE基础-（二十八）/</id>
    <published>2020-03-25T14:41:32.000Z</published>
    <updated>2020-03-25T16:02:18.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Map-映射"><a href="#Map-映射" class="headerlink" title="Map 映射"></a>Map 映射</h1><h2 id="通过某一个key键可以直接定位到一个Value值"><a href="#通过某一个key键可以直接定位到一个Value值" class="headerlink" title="通过某一个key键可以直接定位到一个Value值"></a>通过某一个key键可以直接定位到一个Value值</h2><h2 id="存储方式以-键值对-存储-Key-Value"><a href="#存储方式以-键值对-存储-Key-Value" class="headerlink" title="存储方式以 键值对 存储 Key-Value"></a>存储方式以 键值对 存储 Key-Value</h2><h2 id="key无序还是一样-指的是存入顺序与取得顺序不一致"><a href="#key无序还是一样-指的是存入顺序与取得顺序不一致" class="headerlink" title="key无序还是一样,指的是存入顺序与取得顺序不一致"></a>key无序还是一样,指的是存入顺序与取得顺序不一致</h2><h2 id="key无重复当然指的是-元素不能一致"><a href="#key无重复当然指的是-元素不能一致" class="headerlink" title="key无重复当然指的是 元素不能一致"></a>key无重复当然指的是 元素不能一致</h2><h1 id="Map基本使用"><a href="#Map基本使用" class="headerlink" title="Map基本使用"></a>Map基本使用</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><h1 id="HashMap-1"><a href="#HashMap-1" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="包-java-util"><a href="#包-java-util" class="headerlink" title="包 java.util"></a>包 java.util</h2><h2 id="如何创建对象"><a href="#如何创建对象" class="headerlink" title="如何创建对象"></a>如何创建对象</h2><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><pre><code>增删改查增put(key,value)   存放一组映射关系 key-value          1.key存储的顺序与取得的顺序不同          2.不同的key可以存储相同的value          3.key若有相同的 则将原有的key覆盖而不是拒绝存入(跟Set刚好相反)删 E = remove(key);改 put = (key,value1) put（key,value2）  replace（key,newValue）查 E = get(key)遍历Map集合   key不一定什么样//获取map集合的全部keySet&lt;Integer&gt; it = map.keySet();//通过迭代器遍历Iterator&lt;Integer&gt; it = keys.iterator();while(it.hashNext()){   Integer key = it.next;   String value = map.get(key);   System.out.println(key+&quot;-&quot;value);}</code></pre><h2 id="API提供的其他方法"><a href="#API提供的其他方法" class="headerlink" title="API提供的其他方法"></a>API提供的其他方法</h2><pre><code>char containsKey(key) containsValue(value)getOrDfault(key.defaultValue)如果key存在就返回对象对应的Value 若没有找到则返回默认返回值isEmpty()putAll(map)putlfAbsent(key.value);//如果key不存在才向集合添加 如果key值不存在就不添加了</code></pre><h2 id="HashMap在什么情形下用"><a href="#HashMap在什么情形下用" class="headerlink" title="HashMap在什么情形下用?"></a>HashMap在什么情形下用?</h2><h3 id="想要存一组元素"><a href="#想要存一组元素" class="headerlink" title="想要存一组元素"></a>想要存一组元素</h3><h4 id="数组-or-集合-如果存储的元素以后长度不变用数组-如果数组长度以后不确定用集合"><a href="#数组-or-集合-如果存储的元素以后长度不变用数组-如果数组长度以后不确定用集合" class="headerlink" title="数组 or 集合 如果存储的元素以后长度不变用数组 如果数组长度以后不确定用集合"></a>数组 or 集合 如果存储的元素以后长度不变用数组 如果数组长度以后不确定用集合</h4><h4 id="如果发现长度以后不确定——————-gt-集合"><a href="#如果发现长度以后不确定——————-gt-集合" class="headerlink" title="如果发现长度以后不确定——————&gt;集合"></a>如果发现长度以后不确定——————&gt;集合</h4><pre><code>List Set MapList家族有序的  存储有顺序用这个       ArrayList       更适合遍历轮循       LinkList        更适合插入删除       Stack          LIFO      Set家族无重复   存储元素希望自动去掉重复元用这个       Hash            性能更高       Tree            希望存进去的元素自动去重复 同时还自动排序按(A-Z)字典顺序Map家族k-v      通过唯一的K快速找寻v用这个       Hash            性能更高       Tree            希望存进去的元素能自动排序</code></pre><h2 id="Hash底层的数据结构"><a href="#Hash底层的数据结构" class="headerlink" title="Hash底层的数据结构"></a>Hash底层的数据结构</h2><pre><code>散列表形式      数组加链表Person对象存入HashMap中  可以HashCode方法   —&gt;不同的对象可以产生相同的hashCode码不同的hashCode码  不同的对象//hashcode码static fial int hash(Object obj){  int h;  return(key == null)?0:(h = key.hashCode())^(h &gt;&gt;&gt;16);}数组：对象的hashCode码    发现hashCode码一致    当前数组后面串一个Node    先扫描数组(位置 )    继续扫描链表    数组中存储的是hash值    （key+value）包装成一个对象Entry    Map.entry</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Map-映射&quot;&gt;&lt;a href=&quot;#Map-映射&quot; class=&quot;headerlink&quot; title=&quot;Map 映射&quot;&gt;&lt;/a&gt;Map 映射&lt;/h1&gt;&lt;h2 id=&quot;通过某一个key键可以直接定位到一个Value值&quot;&gt;&lt;a href=&quot;#通过某一个key键可以直接
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>javaSE基础   （二十七）</title>
    <link href="http://yoursite.com/2020/03/25/javaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/25/javaSE基础-（二十七）/</id>
    <published>2020-03-25T13:58:13.000Z</published>
    <updated>2020-03-25T16:02:07.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><h2 id="以value形式存在"><a href="#以value形式存在" class="headerlink" title="以value形式存在"></a>以value形式存在</h2><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="无序无重复"><a href="#无序无重复" class="headerlink" title="无序无重复"></a>无序无重复</h2><h2 id="具体实现的类"><a href="#具体实现的类" class="headerlink" title="具体实现的类"></a>具体实现的类</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><h2 id="基本的使用"><a href="#基本的使用" class="headerlink" title="基本的使用"></a>基本的使用</h2><h2 id="无序-无重复"><a href="#无序-无重复" class="headerlink" title="无序 无重复"></a>无序 无重复</h2><h3 id="无序-：-我们使用的集合存放元素的顺序-集合内取出来的顺序不一致-（不是集合本身是否有序-Tree自然有序）"><a href="#无序-：-我们使用的集合存放元素的顺序-集合内取出来的顺序不一致-（不是集合本身是否有序-Tree自然有序）" class="headerlink" title="无序 ： 我们使用的集合存放元素的顺序 集合内取出来的顺序不一致 （不是集合本身是否有序 Tree自然有序）"></a>无序 ： 我们使用的集合存放元素的顺序 集合内取出来的顺序不一致 （不是集合本身是否有序 Tree自然有序）</h3><h3 id="无重复-：添加的元素不能一致（如果出现重复元素-只存第一个-不再存入）"><a href="#无重复-：添加的元素不能一致（如果出现重复元素-只存第一个-不再存入）" class="headerlink" title="无重复 ：添加的元素不能一致（如果出现重复元素 只存第一个 不再存入）"></a>无重复 ：添加的元素不能一致（如果出现重复元素 只存第一个 不再存入）</h3><h3 id="集合本身是有自己的算法排布顺序-hash算法"><a href="#集合本身是有自己的算法排布顺序-hash算法" class="headerlink" title="集合本身是有自己的算法排布顺序 hash算法"></a>集合本身是有自己的算法排布顺序 hash算法</h3><h1 id="HashSet——-gt-（HashMap（数组-链表）散列表-邻接表）"><a href="#HashSet——-gt-（HashMap（数组-链表）散列表-邻接表）" class="headerlink" title="HashSet——-&gt;（HashMap（数组+链表）散列表 邻接表）"></a>HashSet——-&gt;（HashMap（数组+链表）散列表 邻接表）</h1><h2 id="java-util包"><a href="#java-util包" class="headerlink" title="java.util包"></a>java.util包</h2><h2 id="如何创建对象"><a href="#如何创建对象" class="headerlink" title="如何创建对象"></a>如何创建对象</h2><h3 id="无参数"><a href="#无参数" class="headerlink" title="无参数"></a>无参数</h3><h3 id="有参数"><a href="#有参数" class="headerlink" title="有参数"></a>有参数</h3><h2 id="集合容器的基本使用"><a href="#集合容器的基本使用" class="headerlink" title="集合容器的基本使用"></a>集合容器的基本使用</h2><pre><code>增删改差boolean = add(value) addAll(collection c) retainAll removeAllboolean = remove(Object)没有修改方法size()</code></pre><h3 id="关于迭代器iterator"><a href="#关于迭代器iterator" class="headerlink" title="关于迭代器iterator"></a>关于迭代器iterator</h3><pre><code>//获取一个迭代器对象 通过set集合获取Iterator &lt;String&gt; it = set.iterator();// Iterator 接口 多态效果 父类引用子类对象//判断下一个位置是否有元素if（it.hashNext）{ String value = it.next(); System.out.println(Value);}</code></pre><h2 id="无重复原则"><a href="#无重复原则" class="headerlink" title="无重复原则"></a>无重复原则</h2><pre><code>首先通过String类和Person类型存储大概猜测 无重复原则 利用equals方法进行比较如果我们让Person对象的name一致 认为是同一个对象我们可以重写equals方法重写了equals方法 发现还没有产生无重复的效果证明可能原则不止equals方法这么简单还有另一个规则同时起着作用 hashcode方法</code></pre><h3 id="为什么要重写equals（）方法？"><a href="#为什么要重写equals（）方法？" class="headerlink" title="为什么要重写equals（）方法？"></a>为什么要重写equals（）方法？</h3><pre><code>  因为默认equals在比较两个对象时，是看他们是否指向同一个地址的。但有时，我们需要两个不同对象只要是某些属性相同就认为它们equals（）的结果为true。比如： person p1 = new person(1,&quot;name&quot;); person p2 = new person(1,&quot;name&quot;); 如果不重写equals的话，他们是不相同的，所以我们要重些equals，判断只要他们的id和名字相同equals就为true，在一些集合里有时也这样用，集合里的contain也是用equals来比较   先来看Object关于equals()的源码：   public boolean equals(Object obj) {   return (this == obj);   } //String 就重写了equals方法public boolean equals(Object obj){    if(this==obj){        return true;    }    if(obj instanceof Question) {        Question anotherQuestion = (Question)obj;       //this.title 按照？截取 与anotherQuestion.title截取之前的部分比较        if(this.title.equals(anotherQuestion.title)){            return true;        }    }    return false;}</code></pre><h3 id="当重写equals方法时，同时也要重写hashCode方法。"><a href="#当重写equals方法时，同时也要重写hashCode方法。" class="headerlink" title="当重写equals方法时，同时也要重写hashCode方法。"></a>当重写equals方法时，同时也要重写hashCode方法。</h3><pre><code>//修改equals 方法一定要修改hashcode方法 因为底层用hashCode比较public int hash(){   return this.title.hashCode();}</code></pre><h1 id="TreeSet—–-gt-（TreeMap-二叉树利用Node（Left-item-right））"><a href="#TreeSet—–-gt-（TreeMap-二叉树利用Node（Left-item-right））" class="headerlink" title="TreeSet—–&gt;（TreeMap 二叉树利用Node（Left item right））"></a>TreeSet—–&gt;（TreeMap 二叉树利用Node（Left item right））</h1><h2 id="无序无重复-java-util"><a href="#无序无重复-java-util" class="headerlink" title="无序无重复 java.util"></a>无序无重复 java.util</h2><h2 id="无参构造方法-带Collection构造方法"><a href="#无参构造方法-带Collection构造方法" class="headerlink" title="无参构造方法 带Collection构造方法"></a>无参构造方法 带Collection构造方法</h2><h2 id="基本常用方法"><a href="#基本常用方法" class="headerlink" title="基本常用方法"></a>基本常用方法</h2><pre><code>add(E e)  iterator() remove(E e) 没有修改 size()</code></pre><h2 id="无序无重复规则是如何实现的"><a href="#无序无重复规则是如何实现的" class="headerlink" title="无序无重复规则是如何实现的"></a>无序无重复规则是如何实现的</h2><pre><code>treeSet集合本身是有顺序的  我们指的无序是存入和取出不一致CompaerTo------&gt;String类 按照字母的自然顺序排列//如果想让Person对象存入TeeSet集合内  必须实现Comapareable接口 重写这个方法piublic int compareTo（o.name）{//当前对象name与另一个对象CompareTo结果return this.name.compareTo(o.name);//当前对象name和另一对象name的CompareTO结果}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Collection&quot;&gt;&lt;a href=&quot;#Collection&quot; class=&quot;headerlink&quot; title=&quot;Collection&quot;&gt;&lt;/a&gt;Collection&lt;/h1&gt;&lt;h2 id=&quot;以value形式存在&quot;&gt;&lt;a href=&quot;#以value形式存在&quot;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础         (二十六）</title>
    <link href="http://yoursite.com/2020/03/25/avaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/25/avaSE基础-（二十六）/</id>
    <published>2020-03-25T13:30:11.000Z</published>
    <updated>2020-03-30T00:03:19.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h1 id="Vector-类"><a href="#Vector-类" class="headerlink" title="Vector 类"></a>Vector 类</h1><h2 id="java-util包"><a href="#java-util包" class="headerlink" title="java.util包"></a>java.util包</h2><h2 id="是ArrayList集合-早期版本"><a href="#是ArrayList集合-早期版本" class="headerlink" title="是ArrayList集合 早期版本"></a>是ArrayList集合 早期版本</h2><pre><code>(StringBuffer类早期 Stringbuilder后来) vector底层也是用动态数组来存储 vector是线程同步的 安全性高 效率低</code></pre><h2 id="扩容方式与ArrayList不同"><a href="#扩容方式与ArrayList不同" class="headerlink" title="扩容方式与ArrayList不同"></a>扩容方式与ArrayList不同</h2><pre><code>默认是扩容两倍  可以通过构造方法创建对象时修改这一机制</code></pre><h1 id="Stack类-栈"><a href="#Stack类-栈" class="headerlink" title="Stack类 栈"></a>Stack类 栈</h1><h2 id="java-util包-1"><a href="#java-util包-1" class="headerlink" title="java.util包"></a>java.util包</h2><h2 id="构造方法只有一个无参数"><a href="#构造方法只有一个无参数" class="headerlink" title="构造方法只有一个无参数"></a>构造方法只有一个无参数</h2><h2 id="只有几个特殊的方法"><a href="#只有几个特殊的方法" class="headerlink" title="只有几个特殊的方法"></a>只有几个特殊的方法</h2><pre><code>push(E e)将某个元素压入栈顶（add()）E = pop()将某一个元素从栈顶取出并删掉(E = remove())E = peek()将某一个元素从栈顶取出并删除掉(E = remove())boolean = empty()判断栈顶元素是否为空(isEmpty)int = search()查找给定元素在栈中的位置(indexof())</code></pre><h2 id="中国象棋-悔棋"><a href="#中国象棋-悔棋" class="headerlink" title="中国象棋 悔棋"></a>中国象棋 悔棋</h2><pre><code>栈中存储每一次的操作步骤撤销功能</code></pre><h1 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h1><h2 id="java-util"><a href="#java-util" class="headerlink" title="java.util"></a>java.util</h2><h3 id="通常子类-Linklist-ArrayQueque"><a href="#通常子类-Linklist-ArrayQueque" class="headerlink" title="通常子类 Linklist ArrayQueque"></a>通常子类 Linklist ArrayQueque</h3><h2 id="通常用无参构造方法实现"><a href="#通常用无参构造方法实现" class="headerlink" title="通常用无参构造方法实现"></a>通常用无参构造方法实现</h2><h2 id="一般方法"><a href="#一般方法" class="headerlink" title="一般方法"></a>一般方法</h2><pre><code>add()element()-----&gt;get()remove()boolean = offer(E e);//相当于add  不会抛出异常E = peek();//相当于element方法E =poll; 剪短//相当于remove()</code></pre><h2 id="双十一秒杀"><a href="#双十一秒杀" class="headerlink" title="双十一秒杀"></a>双十一秒杀</h2><pre><code>所有进入秒杀系统的人存入队列</code></pre><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h1 id="Linklist类"><a href="#Linklist类" class="headerlink" title="Linklist类"></a>Linklist类</h1><h2 id="java-util包-2"><a href="#java-util包-2" class="headerlink" title="java.util包"></a>java.util包</h2><h3 id="自己封装过LinkBox-内部类Node-LT-T-GT-对象（节点-prev-item-next）"><a href="#自己封装过LinkBox-内部类Node-LT-T-GT-对象（节点-prev-item-next）" class="headerlink" title="自己封装过LinkBox 内部类Node&LT;T&GT;对象（节点 prev item next）"></a>自己封装过LinkBox 内部类Node&LT;T&GT;对象（节点 prev item next）</h3><h2 id="底层就是使用双向链表的数据结构形式来存储"><a href="#底层就是使用双向链表的数据结构形式来存储" class="headerlink" title="底层就是使用双向链表的数据结构形式来存储"></a>底层就是使用双向链表的数据结构形式来存储</h2><h3 id="适合插入或删除不适合遍历轮循"><a href="#适合插入或删除不适合遍历轮循" class="headerlink" title="适合插入或删除不适合遍历轮循"></a>适合插入或删除不适合遍历轮循</h3><h2 id="构建对象"><a href="#构建对象" class="headerlink" title="构建对象"></a>构建对象</h2><pre><code>无参构造方法 带参数的构造方法（collection）</code></pre><h2 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h2><pre><code>增删改查 add() remove() set() get() size()手册中提供其他常用方法addAll() addFirst() clear() contains()element() getFirst() getLast() indexOf() lastindex()....</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;List&quot;&gt;&lt;a href=&quot;#List&quot; class=&quot;headerlink&quot; title=&quot;List&quot;&gt;&lt;/a&gt;List&lt;/h1&gt;&lt;h1 id=&quot;Vector-类&quot;&gt;&lt;a href=&quot;#Vector-类&quot; class=&quot;headerlink&quot; title=&quot;V
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十五）</title>
    <link href="http://yoursite.com/2020/03/24/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/24/JavaSE基础-（二十五）/</id>
    <published>2020-03-24T14:23:31.000Z</published>
    <updated>2020-03-31T00:48:53.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合相关"><a href="#集合相关" class="headerlink" title="集合相关"></a>集合相关</h1><h2 id="变量–容器"><a href="#变量–容器" class="headerlink" title="变量–容器"></a>变量–容器</h2><pre><code>存取一个元素</code></pre><h2 id="数组–容器"><a href="#数组–容器" class="headerlink" title="数组–容器"></a>数组–容器</h2><pre><code>一组具有某种特性的数据存放在一起       存储一组元素（数据类型一致）  长度固定</code></pre><h2 id="集合–容器"><a href="#集合–容器" class="headerlink" title="集合–容器"></a>集合–容器</h2><pre><code>与数组类似 集合的长度存储之后还能改变集合用来存储一组元素</code></pre><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><pre><code>存的都是value</code></pre><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><pre><code>有序可重复</code></pre><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><pre><code>无序无重复</code></pre><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><pre><code>存储的是以key-value形式存在key无序无重复  value无序可重复</code></pre><h3 id="序：顺序"><a href="#序：顺序" class="headerlink" title="序：顺序"></a>序：顺序</h3><pre><code>添加进去的元素 取得元素的顺序一致 注意指的不是集合自己的顺序</code></pre><h3 id="重复：两个对象一致"><a href="#重复：两个对象一致" class="headerlink" title="重复：两个对象一致"></a>重复：两个对象一致</h3><h1 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h1><p>   1.ArrayList 2.LinkList 3.Vector</p><h1 id="ArrayList——-底层就是一个数组"><a href="#ArrayList——-底层就是一个数组" class="headerlink" title="ArrayList——-底层就是一个数组"></a>ArrayList——-底层就是一个数组</h1><h2 id="所属的包-java-util"><a href="#所属的包-java-util" class="headerlink" title="所属的包 java.util"></a>所属的包 java.util</h2><h2 id="如何创建对象"><a href="#如何创建对象" class="headerlink" title="如何创建对象"></a>如何创建对象</h2><pre><code>无参数构造方法 带默认参数的都构造方法 带collection参数的构造方法</code></pre><h2 id="常用的方法-—小容器"><a href="#常用的方法-—小容器" class="headerlink" title="常用的方法 —小容器"></a>常用的方法 —小容器</h2><pre><code>   存 add   取 get   删 remove   改   个数 sizeadd(E e) add(int index,E e)addAll(Collection c); add(int index,Collection c)clear();将集合内的元素全部清除boolean = contains(Object);找寻一个给定元素集合中是否拥有ensureCapacity(int minCapacity);E = get(int index);int = indexOf(Object obj); lastindexOf();isEmpty();iterator;//迭代器 1.5之后增强forremoveAll 差集 retainAll()交集addAll()并集E = set(int index,E value)int size();List = subList(int index,E value)toArray();集合变成数组toArray(T[]);trimToSize();//变成有效元素个数那么长</code></pre><h2 id="arryList底层是一个Object"><a href="#arryList底层是一个Object" class="headerlink" title="arryList底层是一个Object[]"></a>arryList底层是一个Object[]</h2><pre><code>什么类型都可以存进去取出来的时候多态效果 需要自己造型 显得用起来非常麻烦</code></pre><h1 id="JDK1-5之后—-gt-泛型"><a href="#JDK1-5之后—-gt-泛型" class="headerlink" title="JDK1.5之后—-&gt;泛型"></a>JDK1.5之后—-&gt;泛型</h1><pre><code>用来规定数据类型的,定义的时候用一个符号代替某种类型在使用的时候具体的数据类型 将定义的那个符号替换掉ArrayBox&lt;T&gt;</code></pre><h2 id="泛型可以用在哪里？"><a href="#泛型可以用在哪里？" class="headerlink" title="泛型可以用在哪里？"></a>泛型可以用在哪里？</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><pre><code>类定义的时候描述某种数据类型 集合就是这样使用</code></pre><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><pre><code>与泛型类的使用基本一致 子类实现接口时必须添加泛型public interface Text&lt;X&gt;{     public X value;}public class Son&lt;X&gt;implements Test&lt;X&gt;</code></pre><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><pre><code>方法调用时传参数 方法的泛型与类无关 带有泛型的方法可以不放在带有泛型的类中</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集合相关&quot;&gt;&lt;a href=&quot;#集合相关&quot; class=&quot;headerlink&quot; title=&quot;集合相关&quot;&gt;&lt;/a&gt;集合相关&lt;/h1&gt;&lt;h2 id=&quot;变量–容器&quot;&gt;&lt;a href=&quot;#变量–容器&quot; class=&quot;headerlink&quot; title=&quot;变量–容器&quot;&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十四）</title>
    <link href="http://yoursite.com/2020/03/24/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/24/JavaSE基础-（二十四）/</id>
    <published>2020-03-24T13:51:09.000Z</published>
    <updated>2020-03-24T15:58:51.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式-regex"><a href="#正则表达式-regex" class="headerlink" title="正则表达式 regex"></a>正则表达式 regex</h1><pre><code>Regualar有规律的   Expression表达式匹配字符串格式的</code></pre><h2 id="正则表达式通常的作用如下"><a href="#正则表达式通常的作用如下" class="headerlink" title="正则表达式通常的作用如下"></a>正则表达式通常的作用如下</h2><h3 id="字符串格式的校验"><a href="#字符串格式的校验" class="headerlink" title="字符串格式的校验"></a>字符串格式的校验</h3><pre><code>String类中提供的方法 boolean = str.match(&quot;regex&quot;);</code></pre><h3 id="字符串的拆分及替换"><a href="#字符串的拆分及替换" class="headerlink" title="字符串的拆分及替换"></a>字符串的拆分及替换</h3><pre><code>String类中提供的方法 replace split</code></pre><h3 id="字符串的查找"><a href="#字符串的查找" class="headerlink" title="字符串的查找"></a>字符串的查找</h3><pre><code>pattern模式 Matcher匹配器[abc]       abc中的一个[^abc]      不能是abc中的一个 其他都可以[a-zA-Z]     表示必须是这两个范围内的[a-z&amp;&amp;[^bc]]  表示a-z其中的一个但不能是b和c.代表任意一个字符\d digit [0-9]\D 非数字[^0-9]\S 非留白\w word单词 [0-9A-Za-z]数字或字母都可以</code></pre><h3 id="所有字符串中寻找如下规则的信息-邮政编码"><a href="#所有字符串中寻找如下规则的信息-邮政编码" class="headerlink" title="所有字符串中寻找如下规则的信息 邮政编码"></a>所有字符串中寻找如下规则的信息 邮政编码</h3><pre><code>String str = &quot;123456abc123456abc123456abc&quot;//1.利用pattern模式创建一个模式 理解为一个正则表达式对象Pattern pattern = Pattern.compile（&quot;\\d{6}&quot;）;//邮编//2.需要提供一个字符串//3.利用pattern模式对象创建一个匹配器Matcher matcher = pattern.matcher(str);//4.找寻字符串中出现满足上述格式的字串   while(matcher.find()){    System.out.println(matcher.group());//找到满足字符串格式的那一串文字</code></pre><h3 id="如下所有都用来描述字符出现的次数"><a href="#如下所有都用来描述字符出现的次数" class="headerlink" title="如下所有都用来描述字符出现的次数"></a>如下所有都用来描述字符出现的次数</h3><pre><code>？ 0-1次 [0-9]?*  0-n次 +  1-n次{n} 固定n次{n,}至少出现n次{m,n}m-n次</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;正则表达式-regex&quot;&gt;&lt;a href=&quot;#正则表达式-regex&quot; class=&quot;headerlink&quot; title=&quot;正则表达式 regex&quot;&gt;&lt;/a&gt;正则表达式 regex&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;Regualar有规律的   Expression表
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十三）</title>
    <link href="http://yoursite.com/2020/03/24/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/24/JavaSE基础-（二十三）/</id>
    <published>2020-03-24T12:54:08.000Z</published>
    <updated>2020-03-31T00:47:17.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="StringBuffer-StringBuilder"><a href="#StringBuffer-StringBuilder" class="headerlink" title="StringBuffer/StringBuilder"></a>StringBuffer/StringBuilder</h1><h2 id="所属的包"><a href="#所属的包" class="headerlink" title="所属的包"></a>所属的包</h2><pre><code>java.lang包</code></pre><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><pre><code>Serializable,CharSequence,Comparable非常特殊的类 可以像常量一样创建对象String str = &quot;abc&quot;;内存存储 &quot;abc&quot;对象 char[] valueString的不可变特性   private fianl char[] value频繁的修改内容的时候 性能不是很好</code></pre><h2 id="默认继承"><a href="#默认继承" class="headerlink" title="默认继承"></a>默认继承</h2><pre><code>obJect 实现接口Serialzable,CharSequence,AppendableStringBuffer/StringBuilder 没有compare To方法StringBuffer/StringBuilder 含有一个String没有的方法 append();拼接</code></pre><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><pre><code>可变字符串 char[] value;动态扩容</code></pre><h2 id="对象的构建"><a href="#对象的构建" class="headerlink" title="对象的构建"></a>对象的构建</h2><pre><code>无参数构造方法有参数构造方法//无参数构造方法 构建一个默认长度16个对象空间 char[] StringBuilder builder = new StringBuilder();//利用给定的参数 构建有一个自定义长度空间的对象 char[] StringBuilder builder = new StringBuilder(20);//利用带String参数的构造方法,默认数组字符长度字符串+16个长度 StringBuilder builder = new StringBuilder(&quot;abc&quot;);</code></pre><h2 id="StringBuilder中的常用方法"><a href="#StringBuilder中的常用方法" class="headerlink" title="StringBuilder中的常用方法"></a>StringBuilder中的常用方法</h2><pre><code>最主要的方法 append() 频繁的拼接字符串时候使用此方法 提高性能capcacity();字符串底层char[]的容量length();字符串有效元素个数（长度）char = charAt(int index);int = codePointAt(int index);String = substring(int start,[int end]);        注意需要接收返回值 看见取出来的字符串效果delete(int start,[int end]);        String Builder类中独有的方法String类没有        将Start到end之间的字符串删掉 不用接收返回值就看到效果啦int = indexOf(String str,[int fromindex]);int = lastindexof（String str,[int fromIndex]）        找寻给定的str字符串中第一次出现的索引位置 带重载 则从某一个位置开始找StringBuilder = deleteCharAt(int Index)        String类中没有的方法        将给定inde位置的某一字符串删除insert(int index,value);        将给定的value插入在index上replace(int start，int end，string str);        将start和end之间的部分替换成str        builder.replace(2.5,&quot;zzt&quot;)setCharAt(int index,char value);        将index位置的字符改成给定字符的valuetoString()        将StringBuilder对象 构建成一个string对象 返回trimToSize()        将数组无用的容量去掉 变成length长度的数组</code></pre><h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1><h2 id="StringBuilder类不一定需要"><a href="#StringBuilder类不一定需要" class="headerlink" title="StringBuilder类不一定需要"></a>StringBuilder类不一定需要</h2><pre><code>是为了避免String频繁拼接修改字符串信息时才使用的 底层是数组是可变的 提高了性能</code></pre><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><pre><code>与String类不同独有的方法append() lnsert() delete() deleteCharAt() reverse()与String类相同的方法charAt() codePointAt() indexOf() lastindexOf() replace() 名字相同 用法不一致不是很常用的方法ensureCapacity() capacity() SetLength() trimToSize() setCharAt();</code></pre><h1 id="String家族笔试中经常考察的知识点"><a href="#String家族笔试中经常考察的知识点" class="headerlink" title="String家族笔试中经常考察的知识点"></a>String家族笔试中经常考察的知识点</h1><h2 id="String所属的包-继承关系-实现接口"><a href="#String所属的包-继承关系-实现接口" class="headerlink" title="String所属的包 继承关系 实现接口"></a>String所属的包 继承关系 实现接口</h2><pre><code>java.lang包 继承Object 实现接口Serializable,CharSequence,Comparable</code></pre><h2 id="String构建方式"><a href="#String构建方式" class="headerlink" title="String构建方式"></a>String构建方式</h2><pre><code>常量 构造方法</code></pre><h2 id="String对象内存结构"><a href="#String对象内存结构" class="headerlink" title="String对象内存结构"></a>String对象内存结构</h2><pre><code>字符串常量区 new堆内存对象= = equals()区别&quot;a&quot; +&quot;b&quot;+&quot;c&quot;</code></pre><h2 id="String不可不变特性"><a href="#String不可不变特性" class="headerlink" title="String不可不变特性"></a>String不可不变特性</h2><pre><code>长度及内容</code></pre><h2 id="String类常用的方法—-与StringBuilder的区别"><a href="#String类常用的方法—-与StringBuilder的区别" class="headerlink" title="String类常用的方法—-与StringBuilder的区别"></a>String类常用的方法—-与StringBuilder的区别</h2><pre><code>concat(); toUpperCase();</code></pre><h2 id="String和StringBuilder区别-String和StringBuffer区别"><a href="#String和StringBuilder区别-String和StringBuffer区别" class="headerlink" title="String和StringBuilder区别|String和StringBuffer区别"></a>String和StringBuilder区别|String和StringBuffer区别</h2><pre><code>String不可变字符串        有一个接口Comparable        不可变体现在长度及内容        有一些方法StringBuilder没有 没有concat compareTo toUpperCaseStringBuilder可变字符串        JDK1.5        有一个接口Appendable        可变字符串 没有final修饰 底层可以进行数组扩容        有一些方法string没有 append() insert() delete() reverse()</code></pre><h2 id="StringBuffer和StringBuild的不同"><a href="#StringBuffer和StringBuild的不同" class="headerlink" title="StringBuffer和StringBuild的不同"></a>StringBuffer和StringBuild的不同</h2><pre><code>stringBuffer早期版本1.0StringBuilder后来的版本1.5方法使用几乎一致早期版本 线程同步  安全性比较高 执行效率相对较低后期版本 线程非同步 安全性能比较低 执行效率相对较高</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;StringBuffer-StringBuilder&quot;&gt;&lt;a href=&quot;#StringBuffer-StringBuilder&quot; class=&quot;headerlink&quot; title=&quot;StringBuffer/StringBuilder&quot;&gt;&lt;/a&gt;StringBu
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十二）</title>
    <link href="http://yoursite.com/2020/03/23/avaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/23/avaSE基础-（二十二）/</id>
    <published>2020-03-23T14:40:39.000Z</published>
    <updated>2020-03-31T00:45:54.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h1><h1 id="String类—-gt-引用类型-java-lang包"><a href="#String类—-gt-引用类型-java-lang包" class="headerlink" title="String类—-&gt;引用类型 java.lang包"></a>String类—-&gt;引用类型 java.lang包</h1><h1 id="常见的String笔试题"><a href="#常见的String笔试题" class="headerlink" title="常见的String笔试题"></a>常见的String笔试题</h1><pre><code>==  equals方法和区别             ==可以比较基本类型 也可以比较引用类型             比较基本类型只比较值 比较引用类型比较地址             equals只能比较引用类型（方法）             默认比较地址this == obj             如果想要修改比较规则可以重写equals方法             通常重写equals方法会伴随重写hashcode方法String的不可变特性             长度及内容String与StringBuffer区别StringBuffer与StringBuilder区别String对象的存储             &quot;abc&quot;-----&gt;字符串常量池             new String（&quot;abc&quot;）---&gt;堆内存*string中的常用方法</code></pre><h1 id="存在哪-java-lang包"><a href="#存在哪-java-lang包" class="headerlink" title="存在哪  java.lang包"></a>存在哪  java.lang包</h1><pre><code>没有任何继承关系  实现三个接口Serializable,CharSequence,Comparable</code></pre><h1 id="如何构建对象"><a href="#如何构建对象" class="headerlink" title="如何构建对象"></a>如何构建对象</h1><pre><code>String str = &quot;abc&quot;; //直接将字符串常量赋值给str （字符串常量池）String str = new String();//无参函数构造方法创建空的对象String str = new String(&quot;abc&quot;);//带参String构造方法创建对象String str = new String(byte[]);//将数组中的每一个元素转化成对应的char 组合成strString str = new String(char[]);//将数组中的每一个char元素拼接成最终的String</code></pre><h1 id="String的不可变特性"><a href="#String的不可变特性" class="headerlink" title="String的不可变特性"></a>String的不可变特性</h1><pre><code>体现在两个地方 长度及内容长度-----&gt;final修饰的数组  数组长度不变 final修饰素组的地址不变内容-----&gt;private修饰的属性 不能再类外访问在String类中包含一个 数组private fianl char[] value;//存储String中的每一个字符fianl最终是不可改变的----&gt;地址不让改变 数组的长度本身不可变private私有的当前类中----&gt;数组中的内容也不能改变</code></pre><h1 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="*4.常用方法"></a>*4.常用方法</h1><pre><code>booean = equals(Obj obj);     //继承自Object类 重写啦 比较两个字符串的字面值是否相等int = hashCode();     //继承自object类 重写啦 将当前字符串的每一个char元素拆开 乘以31求和int = CompareTo(String str);    //实现Comparable接口 实现啦 按照字典（Unicode编码）索引的顺序比较String = toString();    //继承自Object 重写啦 不在输出@hashCode 字符串中的字面值</code></pre><h2 id="char-charAt-int-index"><a href="#char-charAt-int-index" class="headerlink" title="char = charAt(int index);"></a>char = charAt(int index);</h2><pre><code>返回给定index位置对应的字符int = codePointAt(int index);返回给定index位置对应字符的code码</code></pre><h2 id="int-length"><a href="#int-length" class="headerlink" title="int = length();"></a>int = length();</h2><pre><code>返回字符串的长度 （其实就是底层 char[] value属性的长度）注意：区别数组length是属性 String的length()方法  集合size()方法</code></pre><h2 id="String-concat-String-str"><a href="#String-concat-String-str" class="headerlink" title=".String = concat(String str);"></a>.String = concat(String str);</h2><pre><code>将给定的str拼接在当前String对象的后面注意：方法执行完毕需要接受返回值 String的不可变特性      concat方法与 + 拼接性能的问题      开发中若遇到频繁拼接字符串-----&gt;通常使用stringBuilder/stringBuffer</code></pre><h2 id="boolean-contains（”s”）"><a href="#boolean-contains（”s”）" class="headerlink" title="boolean = contains（”s”）;"></a>boolean = contains（”s”）;</h2><pre><code>判断给定的s在字符串中是否存在</code></pre><h2 id="statsWith-String-prefix）-nbsp-nbsp-endWith（String-suffix）"><a href="#statsWith-String-prefix）-nbsp-nbsp-endWith（String-suffix）" class="headerlink" title="statsWith(String prefix）;  &nbsp;&nbsp; endWith（String suffix）;"></a>statsWith(String prefix）; <br> &nbsp;&nbsp; endWith（String suffix）;</h2><pre><code>判断此字符串是否已XX开头/结尾</code></pre><h2 id="byte-getBytes-—-gt-getBytes-String-charsetName-char-toCharArray"><a href="#byte-getBytes-—-gt-getBytes-String-charsetName-char-toCharArray" class="headerlink" title="byte[] = getBytes();—-&gt;getBytes(String charsetName); char[] = toCharArray[];"></a>byte[] = getBytes();—-&gt;getBytes(String charsetName); char[] = toCharArray[];</h2><pre><code>将当前字符串转化为数组 “我爱你中国”“我”“爱”“你”“中”“国”</code></pre><h2 id="int-index-indexOf-int-String-str-int-fromindex"><a href="#int-index-indexOf-int-String-str-int-fromindex" class="headerlink" title="int index = indexOf(int/String str,[int fromindex]);"></a>int index = indexOf(int/String str,[int fromindex]);</h2><pre><code>四个方法重载，找寻给定元素在字符串第一次出现的索引位置 若不存在返回-1lastIndexOf(int/String str,[int fromindex]);找寻给定元素在字符串最后一次出现的索引位置 若不存在返回-1</code></pre><h2 id="boolean-isEmpty"><a href="#boolean-isEmpty" class="headerlink" title="boolean = isEmpty();"></a>boolean = isEmpty();</h2><pre><code>判断当前字符串是否为空字符串（length是否为0）注意与null之间的区别</code></pre><h2 id="replace-replaceAll-replaceFirst"><a href="#replace-replaceAll-replaceFirst" class="headerlink" title="replace(); replaceAll(); replaceFirst();"></a>replace(); replaceAll(); replaceFirst();</h2><pre><code>将给定字符串替换成另一个字符串</code></pre><h2 id="String-split（String-regex-int-limit限度界限-）"><a href="#String-split（String-regex-int-limit限度界限-）" class="headerlink" title="String[] = split（String regex, [int limit限度界限]）;"></a>String[] = split（String regex, [int limit限度界限]）;</h2><pre><code>按照正则表达式将原来的字符串拆开   String str=&quot;a-b-c-d&quot;;   String[] value = str.split(&quot;-&quot;,3);   for(String v:value){     System.out.println(v);   }  </code></pre><h2 id="String-substring-int-beginIndex-int-endIndex"><a href="#String-substring-int-beginIndex-int-endIndex" class="headerlink" title="String = substring(int beginIndex),[int endIndex]);"></a>String = substring(int beginIndex),[int endIndex]);</h2><pre><code>将当前字符串截取一部分从beginIndex开始至endIndex结束[beginIndex，endIndex)若endIndex不写 则默认到字符串最后</code></pre><h2 id="String-toUpperCase-String-toLowerCase"><a href="#String-toUpperCase-String-toLowerCase" class="headerlink" title="String = toUpperCase();String = toLowerCase();"></a>String = toUpperCase();<br>String = toLowerCase();</h2><pre><code>将全部字母转换成大写/小写</code></pre><h2 id="String-trim"><a href="#String-trim" class="headerlink" title="String = trim();"></a>String = trim();</h2><pre><code>去掉字符串前后多余的空格</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字符串相关&quot;&gt;&lt;a href=&quot;#字符串相关&quot; class=&quot;headerlink&quot; title=&quot;字符串相关&quot;&gt;&lt;/a&gt;字符串相关&lt;/h1&gt;&lt;h1 id=&quot;String类—-gt-引用类型-java-lang包&quot;&gt;&lt;a href=&quot;#String类—-gt-引用
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十一）</title>
    <link href="http://yoursite.com/2020/03/23/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/23/JavaSE基础-（二十一）/</id>
    <published>2020-03-23T14:02:16.000Z</published>
    <updated>2020-03-23T15:47:41.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日期相关"><a href="#日期相关" class="headerlink" title="日期相关"></a>日期相关</h1><h2 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h2><pre><code>1.通常使用的是java.util包2.导包 拿来使用 构建对象3.通常使用的是无参构造方法 或者带long构造方法4.Date类中常用的方法     before();after();     setTime();getTime();     compareTo();5.可以处理一个Date日期的格式</code></pre><h2 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h2><pre><code>1.java.text包 需要导包2.此类是一个抽象类 不能创建对象 子类来使用3.SimpleDarteFormat类 是DateFormat的子类4.调用String参数的构造方法创建format对象       SimpleDateFormat sdf =  new Simple DateFormat(&quot;yyyyy--MM--dd HH:mm:ss&quot;)        string v = sdf.format(date.1)//通过sdf将对象格式化成你描述的样子</code></pre><h2 id="Calendar-1-1版本"><a href="#Calendar-1-1版本" class="headerlink" title="Calendar 1.1版本"></a>Calendar 1.1版本</h2><pre><code>1.所属的包 java.util 需要导包2.有构造方法 用protected修饰的 通常访问不到 通常还会调用默认的getInstance()3.常用方法        after() before()        setTime() getTime()---&gt;Date        getTimeInMills()----time        getTimeZone()----TimeZone        Calendar calendar = Calendar.getInstance();//系统当前时间的Calendar对象        Calendar里面包含一个date属性 可以操作某一个局部信息        set get        calendar.set（Calendar.YEAR,2015）;        int year = calendar.get（Calendar.YEAR）;</code></pre><h2 id="TimeZone"><a href="#TimeZone" class="headerlink" title="TimeZone"></a>TimeZone</h2><pre><code>1.java.util包2.可以通过calendar对象.getTimeZone（）获取 或 TimeZone.getDefault();3.常用方法        tz.getID();       System.out.println(tz.getDisplayName());</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;日期相关&quot;&gt;&lt;a href=&quot;#日期相关&quot; class=&quot;headerlink&quot; title=&quot;日期相关&quot;&gt;&lt;/a&gt;日期相关&lt;/h1&gt;&lt;h2 id=&quot;Date类&quot;&gt;&lt;a href=&quot;#Date类&quot; class=&quot;headerlink&quot; title=&quot;Date类&quot;&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十）</title>
    <link href="http://yoursite.com/2020/03/23/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/23/JavaSE基础-（二十）/</id>
    <published>2020-03-23T12:50:35.000Z</published>
    <updated>2020-03-23T15:47:35.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java中提供的工具类——-官方API帮助文档"><a href="#java中提供的工具类——-官方API帮助文档" class="headerlink" title="java中提供的工具类——-官方API帮助文档"></a>java中提供的工具类——-官方API帮助文档</h1><pre><code>Application  Programming interface应用程序编程接口,一些预先创建好的类及方法，目的是为了让我们更好的进行程序开发</code></pre><h2 id="与数学相关的类—-Math类"><a href="#与数学相关的类—-Math类" class="headerlink" title="与数学相关的类—-Math类"></a>与数学相关的类—-Math类</h2><pre><code>1.所属的包java.lang2.Math构造方法是私有的 我们不能直接调用创建对象3.由于Math中提供的属性方法都是static 不需要创建对象4.常用的方法           abs()返回给定数字的绝对值 （参数 int long float double）           double = ceil() 向上取整           double = floor()向下取整           double = rint() 临近的整数 如果两边距离一样则返回偶数           int = round 四舍五入的整数           max（a，b） min（a，b）参数int long float double            pow（a，b） a的b次方（参数double 返回值double）           sqrt（double a） 获取给定参数的平方根           double = random(); 随机产生一个  [0.0-1.0] 5.Math.randon()计算小数的时候精确度可能会有些损失               0-9之间的随机整数               int Value = （int）(Math.random()*10);               5.0----10.9之间的小数               （Math.random()*6)+5               0.0----0.99999 * 6               (0.0---5.49999)+5</code></pre><h2 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h2><pre><code>1.在java.util包中的类 需要import导入2.没有任何继承关系 默认继承Object类3.查找构造方法----》如何创建对象        Random r = new Random();4.类中常用的方法        r.nextInt(); 随机产生int范围内的整数  有正有负        r.nextInt(int bound);随机产生一个[0-bound]整数                 注意bound必须为正数 否则会出现如下的运行时异常                 IllegalArgumentException        r.nextFloat() 随机产生一个[0.0--1.0]        r.nextBoolean()随机产生一个boolean值 true false        //调用的方法都需要用相对应类型的变量接收值</code></pre><h2 id="UUID类"><a href="#UUID类" class="headerlink" title="UUID类"></a>UUID类</h2><pre><code>1.所属的包 java.util  需要import导入2.没有任何继承关系 默认继承Object类3.构造方法有 没有无参的 我们通常不会创建对象          UUID  uuid = UUID.randomUUID();          System.out.println(uuid.toString());//数据库表格主键primary key          产生一个32位的随机元素 每一个位置都是16进制的数字</code></pre><h2 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h2><pre><code>1.所属的包java.math  需要impor导入2.继承自Number3.如何创建对象 提供的构造方法都是带参的        通常利用String参数的构造方法创建这个类的对象        BigInteger bi = new BigInteger{&quot;123&quot;};4.类中常用的方法        做四则运算        add()  substract() multiply() divide()5.小例子 设计一个方法 用来设计给定数字的阶乘        //设计一个方法 用来设计数字的阶乘       //参数 返回值       Public BigInteger factorial(int num){            BigInteger result = new BigInteger(&quot;1&quot;);            for(int i = 1;i &lt;= num;i++){                result=result.multiply(new BigInteger(i+&quot; &quot;))        }        retrun result;      } </code></pre><h2 id="BigDecimal类-超过了double取值范围"><a href="#BigDecimal类-超过了double取值范围" class="headerlink" title="BigDecimal类  超过了double取值范围"></a>BigDecimal类  超过了double取值范围</h2><pre><code>1.所属的包  java.math包2.继承Number类3.通常可以通过 带String参数构造对象4.类中常用的方法         做四则运算         add()  substract() multiply() divide()         两个参数前面保留小数点之后的位数，后面的参数是设置的格式如何保留         对象.setScale(2,BigDecimal.ROUND_DOWN);</code></pre><h2 id="DecimalFormat——-格式化"><a href="#DecimalFormat——-格式化" class="headerlink" title="DecimalFormat——-格式化"></a>DecimalFormat——-格式化</h2><pre><code>1.所属的包 java.text2.import导入才能使用3.通过带String参数的构造方法格式化创建成一个字符串            DecimalFormat df = new DecimalFormat（&quot;000.###&quot;）;            String value = df.format(12.45);            System.out.println(value);1.</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java中提供的工具类——-官方API帮助文档&quot;&gt;&lt;a href=&quot;#java中提供的工具类——-官方API帮助文档&quot; class=&quot;headerlink&quot; title=&quot;java中提供的工具类——-官方API帮助文档&quot;&gt;&lt;/a&gt;java中提供的工具类——-官方A
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十九）</title>
    <link href="http://yoursite.com/2020/03/22/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/22/JavaSE基础-（十九）/</id>
    <published>2020-03-22T15:29:06.000Z</published>
    <updated>2020-03-31T00:43:28.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><pre><code>1.类所在的包2.类的关系 自己默认继承 实现3，类中提供常用方法4.是否可以创建对象 调用 方法本身是静态的包装类（封装类） 1.5版本之后自动拆包byte----Byte   short----Short   int------Integer  long-----Longfloat-----Float  double-----Double char-----Character boolean----Boolean1.八个包装类都在同一个包下  java.lang包  不需要import导包自己使用2.八个包装类有六个都是与数字有关  都默认继承父类Number3.八个包装类都实现了Serializable，Comparable4.八个包装类都带有自己对应类型参数的构造方法 八个包装类中有7个（除了Character）有构造方法重载 带String类型5.创建对象  对象调用方法     有六个与数字相关的类都继承Number   xxValue();将一个包装类类型转化为对应的基本类型（拆包）Interger i1 = new Interger（10）//引用数据类型 包装类 int value = i1.intValue(); int value  = Inter.parseInt(&quot;123&quot;)  Float.parseFloat(&quot;123.45&quot;) int value  = new Integer(&quot;123&quot;);</code></pre><h1 id="经常在笔试中出现的问题"><a href="#经常在笔试中出现的问题" class="headerlink" title="经常在笔试中出现的问题"></a>经常在笔试中出现的问题</h1><pre><code>integer i1 = 10;integer i2 = 10;integer i3 = new Integer(10);integer i4 = new Integer(10);System.out.println(i1==i2);//trueSystem.out.println(i1==i3);//falseSystem.out,println(i3==i4);//falseSystem.out.pritnln(i1.equals(i2));//trueSystem.out.pritnln(i1.equals(i3));//trueSystem.out.pritnln(i1.equals(i4));//true</code></pre><h2 id="与equals-的区别"><a href="#与equals-的区别" class="headerlink" title="==与equals()的区别"></a>==与equals()的区别</h2><pre><code>==可以比较基本数据类型 也可以比较引用数据类型（变量中存储的内容）如果比较基本类型比较的是变量中存储的值如果比较的是引用类型比较的是变量中存储地址的引用equals()是Object类中继承过来的方法==一致 如果想要改变比较规则 可以重写equals方法由于integer类就重写了equals()所以Integer比较的是数值</code></pre><h2 id="考察Integer类加载的时候有一个静态空间"><a href="#考察Integer类加载的时候有一个静态空间" class="headerlink" title="考察Integer类加载的时候有一个静态空间"></a>考察Integer类加载的时候有一个静态空间</h2><pre><code>空间内立即加载Integer类型的数组 内存储256个Integer对象 -128-127如果我们用的对象范围在这之内 integer i1 = 10;直接取静态元素区中找对应的对象如果我们用的对象范围超出了Integer i1 = 1000; 会帮我们创建一个新的Integer对象</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;包装类&quot;&gt;&lt;a href=&quot;#包装类&quot; class=&quot;headerlink&quot; title=&quot;包装类&quot;&gt;&lt;/a&gt;包装类&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1.类所在的包
2.类的关系 自己默认继承 实现
3，类中提供常用方法
4.是否可以创建对象 调用 方法本身是静态的
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十八）</title>
    <link href="http://yoursite.com/2020/03/22/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89-1/"/>
    <id>http://yoursite.com/2020/03/22/JavaSE基础-（十八）-1/</id>
    <published>2020-03-22T15:28:17.000Z</published>
    <updated>2020-03-31T00:42:41.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h1 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h1><pre><code>将一个类直接定义在类的里面，作为成员，与属性或方法层次一次成员内部类可以与正常类一样 使用不同的修饰符去修饰好处1.省略了一个.java文件 好处2.成员内部类可以访问外部类的所有成员 包括私有的若想要在内部类中通过对象.调用外部类成员  外部类.this.外部类成员内部类存在后 源代码进行编译 产生一个字节码 Demo$InnerDemo.class</code></pre><h1 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h1><pre><code>将一个类定义在方法/块里面,作为成员的内部结构，与临时的局部变量一个层次局部内部类像是一个局部变量一样，不能用public protected privtae及staic只能用abstract或final局部内部类命名规则Demo$InnerTestMethod局部内部类使用的变量只能用final修饰</code></pre><h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类<br></h1><pre><code>成员匿名内部类&lt;br&gt;局部匿名内部类public interface Test{          public void test();} Test t = new Test{          public void test(){          }} ;通常接口或抽象类的具体子类这样写开发中为了省略一个类文件 上诉写法比较常见匿名内部类很特殊 只有类体 没有类的所有结构（修饰符 名字 继承 实现）      不能用任何修饰符来修饰 匿名内部类也没有任何构造方法</code></pre><h1 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h1><pre><code>成员静态内部类不需要外部类对象，通过正常的方式直接创建内部类静态元素不能访问非静态成员（自己类和外部类）</code></pre><h1 id="枚举类enum"><a href="#枚举类enum" class="headerlink" title="枚举类enum"></a>枚举类enum</h1><h2 id="一个类中的对象-认为个数有限且固定的，可以将每一个对象一一列举出来"><a href="#一个类中的对象-认为个数有限且固定的，可以将每一个对象一一列举出来" class="headerlink" title="一个类中的对象 认为个数有限且固定的，可以将每一个对象一一列举出来"></a>一个类中的对象 认为个数有限且固定的，可以将每一个对象一一列举出来</h2><pre><code> 1.试一试若没有枚举类型的时候如何动手设计（静态常量 单例模式）Day（类 当做描述星期七个对象）      private 构造方法      public static final 属性 = new      //构造方法私有        private Day(){}      //所有对象都是属性      public static final Day monday = new Day(); 2.JDK1.5版本后可以直接定义enmu类型      我们自己定义的enmu类型直接默认继承enmu（java.lang包）      我们自己定义的enmu类型不能再写extrends但是可以实现      Enum类型             有两个属性             name-------&gt;枚举对象的名字   name()获取name的属性             ordinal------&gt;枚举对象在罗列中的顺序  类似index 也从0开始 ordinal获取序列号             常用的方法             valueof()  通过给定的name获取对应的枚举对象             values()   获取全部的枚举对象----&gt;返回一个数组 Day[]             compaerTo() 可以比较两个枚举对象 int             toString()  由于这个方法没有final修饰 可以覆盖（重写）3.我们也可以在enum中描述自己的一些属性或方法      必须在enum类中第一行 描述一下枚举的样子 最后需要分号结束;      可以定义自己的属性      类创建过程中 帮我们创建枚举类型的对象      需要给枚举型提供对应样子的构造方法 方法只能private修饰 可以重载</code></pre><h1 id="内存机制问题"><a href="#内存机制问题" class="headerlink" title="内存机制问题"></a>内存机制问题</h1><pre><code>栈内存-----&gt;Person p = new Person();-----&gt;堆内存   方法区----类模板栈内存-----&gt;创建开始  用完立即回收   StackoverflowError方法区-----&gt;类 常量 静态 只有一份回收不了堆内存-----&gt;new创建的对象 Garbage Collection 垃圾回收器Runtime类之中提供了几个管理内存的方法        maxMemory        totalMemory        freeMemory        堆内存溢出错误OutOfMemoryErrorObject类中有一个finalize方法 如果重写也能看见对象回收GC系统提供的一个线程  回收算法</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内部类&quot;&gt;&lt;a href=&quot;#内部类&quot; class=&quot;headerlink&quot; title=&quot;内部类&quot;&gt;&lt;/a&gt;内部类&lt;/h1&gt;&lt;h1 id=&quot;成员内部类&quot;&gt;&lt;a href=&quot;#成员内部类&quot; class=&quot;headerlink&quot; title=&quot;成员内部类&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
</feed>
