<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一轮明月照九洲</title>
  
  <subtitle>长将静趣观天地，自有幽怀契古今</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-26T15:59:19.469Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>我与我周旋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaSE基础  （三十一）</title>
    <link href="http://yoursite.com/2020/03/26/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/26/JavaSE基础-（三十一）/</id>
    <published>2020-03-26T15:25:56.000Z</published>
    <updated>2020-03-26T15:59:19.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习文件流"><a href="#学习文件流" class="headerlink" title="学习文件流"></a>学习文件流</h1><h2 id="文件流按照读取或写入的单位（字节数）大小来区分"><a href="#文件流按照读取或写入的单位（字节数）大小来区分" class="headerlink" title="文件流按照读取或写入的单位（字节数）大小来区分"></a>文件流按照读取或写入的单位（字节数）大小来区分</h2><h2 id="字节型文件流（1字节）"><a href="#字节型文件流（1字节）" class="headerlink" title="字节型文件流（1字节）"></a>字节型文件流（1字节）</h2><h3 id="FileInputStream-FileOutputStream"><a href="#FileInputStream-FileOutputStream" class="headerlink" title="FileInputStream/FileOutputStream"></a>FileInputStream/FileOutputStream</h3><h2 id="字符型文件流（2-字节–1字符）"><a href="#字符型文件流（2-字节–1字符）" class="headerlink" title="字符型文件流（2-字节–1字符）"></a>字符型文件流（2-字节–1字符）</h2><h3 id="FileReader-FileWriter"><a href="#FileReader-FileWriter" class="headerlink" title="FileReader/FileWriter"></a>FileReader/FileWriter</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;学习文件流&quot;&gt;&lt;a href=&quot;#学习文件流&quot; class=&quot;headerlink&quot; title=&quot;学习文件流&quot;&gt;&lt;/a&gt;学习文件流&lt;/h1&gt;&lt;h2 id=&quot;文件流按照读取或写入的单位（字节数）大小来区分&quot;&gt;&lt;a href=&quot;#文件流按照读取或写入的单位（字节数）
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础  （三十）</title>
    <link href="http://yoursite.com/2020/03/26/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%B8%89%E5%8D%81%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/26/JavaSE基础-（三十）/</id>
    <published>2020-03-26T14:28:17.000Z</published>
    <updated>2020-03-26T15:59:06.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="I-O相关-输入-输出-流（数据流动）"><a href="#I-O相关-输入-输出-流（数据流动）" class="headerlink" title="I/O相关 输入/输出 流（数据流动）"></a>I/O相关 输入/输出 流（数据流动）</h1><h2 id="数据流动的方向-读数据-输入input-写数据（输出output）"><a href="#数据流动的方向-读数据-输入input-写数据（输出output）" class="headerlink" title="数据流动的方向 读数据(输入input) 写数据（输出output）"></a>数据流动的方向 读数据(输入input) 写数据（输出output）</h2><h2 id="文件流-字符流-数组流-对象流-网络流"><a href="#文件流-字符流-数组流-对象流-网络流" class="headerlink" title="文件流 字符流 数组流 对象流 网络流"></a>文件流 字符流 数组流 对象流 网络流</h2><h1 id="什么叫文件"><a href="#什么叫文件" class="headerlink" title="什么叫文件"></a>什么叫文件</h1><h2 id="一种电脑的存储形式"><a href="#一种电脑的存储形式" class="headerlink" title="一种电脑的存储形式"></a>一种电脑的存储形式</h2><h2 id="文件有不同的格式-txt-doc-ppt-mp4-rar-…"><a href="#文件有不同的格式-txt-doc-ppt-mp4-rar-…" class="headerlink" title="文件有不同的格式 .txt .doc .ppt .mp4 .rar …"></a>文件有不同的格式 .txt .doc .ppt .mp4 .rar …</h2><h2 id="文件夹—–目录路径"><a href="#文件夹—–目录路径" class="headerlink" title="文件夹—–目录路径"></a>文件夹—–目录路径</h2><h2 id="File—–-gt-与电脑上的文件夹产生一一对应的映射关系"><a href="#File—–-gt-与电脑上的文件夹产生一一对应的映射关系" class="headerlink" title="File—–&gt;与电脑上的文件夹产生一一对应的映射关系"></a>File—–&gt;与电脑上的文件夹产生一一对应的映射关系</h2><h2 id="File是一个类"><a href="#File是一个类" class="headerlink" title="File是一个类"></a>File是一个类</h2><h2 id="java-io包"><a href="#java-io包" class="headerlink" title="java.io包"></a>java.io包</h2><h2 id="文件或目录路径名的抽象形式"><a href="#文件或目录路径名的抽象形式" class="headerlink" title="文件或目录路径名的抽象形式"></a>文件或目录路径名的抽象形式</h2><h2 id="File与真实硬盘中的文件或文件夹-不是同一个东西"><a href="#File与真实硬盘中的文件或文件夹-不是同一个东西" class="headerlink" title="File与真实硬盘中的文件或文件夹 不是同一个东西"></a>File与真实硬盘中的文件或文件夹 不是同一个东西</h2><h2 id="File是内存中的一个对象-lt-—–映射—-gt-磁盘上的文件或文件夹"><a href="#File是内存中的一个对象-lt-—–映射—-gt-磁盘上的文件或文件夹" class="headerlink" title="File是内存中的一个对象&lt;—–映射—-&gt;磁盘上的文件或文件夹"></a>File是内存中的一个对象&lt;—–映射—-&gt;磁盘上的文件或文件夹</h2><h2 id="File类中的常用方法"><a href="#File类中的常用方法" class="headerlink" title="File类中的常用方法"></a>File类中的常用方法</h2><pre><code>canRead() canWrite() isHidden() isFile() isDirectory()length() 获取文件中的字节数lastModified()获取文件最后的修改时间----&gt;毫秒值*String path = getAbstractPath() 获取文件的绝对路径 D://test//Test.txt绝对路径&lt;---&gt;相对路径绝对路径可以通过完整字符串 定位盘符 文件夹 文件相对路径没有盘符的写法 当前工程（项目）所在的位置寻找              C：\Users\Administator\ideaProjects\TestFile\src*String name = getName()获取文件名字 Test.txt*creatNewFile() 创建新的文件*mkdir 创建新的文件夹 外层没有 不能创建*mkdirs 创建新的文件夹 外层没有 自动创建String pname = getParent() 获取当前file的父亲file名字*File file = getParent() 获取当前file父亲的对象String[] names = list() 获取当前file所有儿子的名字*File[]files = listFiles() 获取当前file所有儿子对象*boolean = delete() 删除文件或空的文件及 不能删除带元素的文件夹</code></pre><h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;I-O相关-输入-输出-流（数据流动）&quot;&gt;&lt;a href=&quot;#I-O相关-输入-输出-流（数据流动）&quot; class=&quot;headerlink&quot; title=&quot;I/O相关 输入/输出 流（数据流动）&quot;&gt;&lt;/a&gt;I/O相关 输入/输出 流（数据流动）&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十八）</title>
    <link href="http://yoursite.com/2020/03/25/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/25/JavaSE基础-（二十八）/</id>
    <published>2020-03-25T14:41:32.000Z</published>
    <updated>2020-03-25T16:02:18.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Map-映射"><a href="#Map-映射" class="headerlink" title="Map 映射"></a>Map 映射</h1><h2 id="通过某一个key键可以直接定位到一个Value值"><a href="#通过某一个key键可以直接定位到一个Value值" class="headerlink" title="通过某一个key键可以直接定位到一个Value值"></a>通过某一个key键可以直接定位到一个Value值</h2><h2 id="存储方式以-键值对-存储-Key-Value"><a href="#存储方式以-键值对-存储-Key-Value" class="headerlink" title="存储方式以 键值对 存储 Key-Value"></a>存储方式以 键值对 存储 Key-Value</h2><h2 id="key无序还是一样-指的是存入顺序与取得顺序不一致"><a href="#key无序还是一样-指的是存入顺序与取得顺序不一致" class="headerlink" title="key无序还是一样,指的是存入顺序与取得顺序不一致"></a>key无序还是一样,指的是存入顺序与取得顺序不一致</h2><h2 id="key无重复当然指的是-元素不能一致"><a href="#key无重复当然指的是-元素不能一致" class="headerlink" title="key无重复当然指的是 元素不能一致"></a>key无重复当然指的是 元素不能一致</h2><h1 id="Map基本使用"><a href="#Map基本使用" class="headerlink" title="Map基本使用"></a>Map基本使用</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><h1 id="HashMap-1"><a href="#HashMap-1" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="包-java-util"><a href="#包-java-util" class="headerlink" title="包 java.util"></a>包 java.util</h2><h2 id="如何创建对象"><a href="#如何创建对象" class="headerlink" title="如何创建对象"></a>如何创建对象</h2><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><pre><code>增删改查增put(key,value)   存放一组映射关系 key-value          1.key存储的顺序与取得的顺序不同          2.不同的key可以存储相同的value          3.key若有相同的 则将原有的key覆盖而不是拒绝存入(跟Set刚好相反)删 E = remove(key);改 put = (key,value1) put（key,value2）  replace（key,newValue）查 E = get(key)遍历Map集合   key不一定什么样//获取map集合的全部keySet&lt;Integer&gt; it = map.keySet();//通过迭代器遍历Iterator&lt;Integer&gt; it = keys.iterator();while(it.hashNext()){   Integer key = it.next;   String value = map.get(key);   System.out.println(key+&quot;-&quot;value);}</code></pre><h2 id="API提供的其他方法"><a href="#API提供的其他方法" class="headerlink" title="API提供的其他方法"></a>API提供的其他方法</h2><pre><code>char containsKey(key) containsValue(value)getOrDfault(key.defaultValue)如果key存在就返回对象对应的Value 若没有找到则返回默认返回值isEmpty()putAll(map)putlfAbsent(key.value);//如果key不存在才向集合添加 如果key值不存在就不添加了</code></pre><h2 id="HashMap在什么情形下用"><a href="#HashMap在什么情形下用" class="headerlink" title="HashMap在什么情形下用?"></a>HashMap在什么情形下用?</h2><h3 id="想要存一组元素"><a href="#想要存一组元素" class="headerlink" title="想要存一组元素"></a>想要存一组元素</h3><h4 id="数组-or-集合-如果存储的元素以后长度不变用数组-如果数组长度以后不确定用集合"><a href="#数组-or-集合-如果存储的元素以后长度不变用数组-如果数组长度以后不确定用集合" class="headerlink" title="数组 or 集合 如果存储的元素以后长度不变用数组 如果数组长度以后不确定用集合"></a>数组 or 集合 如果存储的元素以后长度不变用数组 如果数组长度以后不确定用集合</h4><h4 id="如果发现长度以后不确定——————-gt-集合"><a href="#如果发现长度以后不确定——————-gt-集合" class="headerlink" title="如果发现长度以后不确定——————&gt;集合"></a>如果发现长度以后不确定——————&gt;集合</h4><pre><code>List Set MapList家族有序的  存储有顺序用这个       ArrayList       更适合遍历轮循       LinkList        更适合插入删除       Stack          LIFO      Set家族无重复   存储元素希望自动去掉重复元用这个       Hash            性能更高       Tree            希望存进去的元素自动去重复 同时还自动排序按(A-Z)字典顺序Map家族k-v      通过唯一的K快速找寻v用这个       Hash            性能更高       Tree            希望存进去的元素能自动排序</code></pre><h2 id="Hash底层的数据结构"><a href="#Hash底层的数据结构" class="headerlink" title="Hash底层的数据结构"></a>Hash底层的数据结构</h2><pre><code>散列表形式      数组加链表Person对象存入HashMap中  可以HashCode方法   —&gt;不同的对象可以产生相同的hashCode码不同的hashCode码  不同的对象//hashcode码static fial int hash(Object obj){  int h;  return(key == null)?0:(h = key.hashCode())^(h &gt;&gt;&gt;16);}数组：对象的hashCode码    发现hashCode码一致    当前数组后面串一个Node    先扫描数组(位置 )    继续扫描链表    数组中存储的是hash值    （key+value）包装成一个对象Entry    Map.entry</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Map-映射&quot;&gt;&lt;a href=&quot;#Map-映射&quot; class=&quot;headerlink&quot; title=&quot;Map 映射&quot;&gt;&lt;/a&gt;Map 映射&lt;/h1&gt;&lt;h2 id=&quot;通过某一个key键可以直接定位到一个Value值&quot;&gt;&lt;a href=&quot;#通过某一个key键可以直接
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>javaSE基础   （二十七）</title>
    <link href="http://yoursite.com/2020/03/25/javaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/25/javaSE基础-（二十七）/</id>
    <published>2020-03-25T13:58:13.000Z</published>
    <updated>2020-03-25T16:02:07.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><h2 id="以value形式存在"><a href="#以value形式存在" class="headerlink" title="以value形式存在"></a>以value形式存在</h2><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="无序无重复"><a href="#无序无重复" class="headerlink" title="无序无重复"></a>无序无重复</h2><h2 id="具体实现的类"><a href="#具体实现的类" class="headerlink" title="具体实现的类"></a>具体实现的类</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><h2 id="基本的使用"><a href="#基本的使用" class="headerlink" title="基本的使用"></a>基本的使用</h2><h2 id="无序-无重复"><a href="#无序-无重复" class="headerlink" title="无序 无重复"></a>无序 无重复</h2><h3 id="无序-：-我们使用的集合存放元素的顺序-集合内取出来的顺序不一致-（不是集合本身是否有序-Tree自然有序）"><a href="#无序-：-我们使用的集合存放元素的顺序-集合内取出来的顺序不一致-（不是集合本身是否有序-Tree自然有序）" class="headerlink" title="无序 ： 我们使用的集合存放元素的顺序 集合内取出来的顺序不一致 （不是集合本身是否有序 Tree自然有序）"></a>无序 ： 我们使用的集合存放元素的顺序 集合内取出来的顺序不一致 （不是集合本身是否有序 Tree自然有序）</h3><h3 id="无重复-：添加的元素不能一致（如果出现重复元素-只存第一个-不再存入）"><a href="#无重复-：添加的元素不能一致（如果出现重复元素-只存第一个-不再存入）" class="headerlink" title="无重复 ：添加的元素不能一致（如果出现重复元素 只存第一个 不再存入）"></a>无重复 ：添加的元素不能一致（如果出现重复元素 只存第一个 不再存入）</h3><h3 id="集合本身是有自己的算法排布顺序-hash算法"><a href="#集合本身是有自己的算法排布顺序-hash算法" class="headerlink" title="集合本身是有自己的算法排布顺序 hash算法"></a>集合本身是有自己的算法排布顺序 hash算法</h3><h1 id="HashSet——-gt-（HashMap（数组-链表）散列表-邻接表）"><a href="#HashSet——-gt-（HashMap（数组-链表）散列表-邻接表）" class="headerlink" title="HashSet——-&gt;（HashMap（数组+链表）散列表 邻接表）"></a>HashSet——-&gt;（HashMap（数组+链表）散列表 邻接表）</h1><h2 id="java-util包"><a href="#java-util包" class="headerlink" title="java.util包"></a>java.util包</h2><h2 id="如何创建对象"><a href="#如何创建对象" class="headerlink" title="如何创建对象"></a>如何创建对象</h2><h3 id="无参数"><a href="#无参数" class="headerlink" title="无参数"></a>无参数</h3><h3 id="有参数"><a href="#有参数" class="headerlink" title="有参数"></a>有参数</h3><h2 id="集合容器的基本使用"><a href="#集合容器的基本使用" class="headerlink" title="集合容器的基本使用"></a>集合容器的基本使用</h2><pre><code>增删改差boolean = add(value) addAll(collection c) retainAll removeAllboolean = remove(Object)没有修改方法size()</code></pre><h3 id="关于迭代器iterator"><a href="#关于迭代器iterator" class="headerlink" title="关于迭代器iterator"></a>关于迭代器iterator</h3><pre><code>//获取一个迭代器对象 通过set集合获取Iterator &lt;String&gt; it = set.iterator();// Iterator 接口 多态效果 父类引用子类对象//判断下一个位置是否有元素if（it.hashNext）{ String value = it.next(); System.out.println(Value);}</code></pre><h2 id="无重复原则"><a href="#无重复原则" class="headerlink" title="无重复原则"></a>无重复原则</h2><pre><code>首先通过String类和Person类型存储大概猜测 无重复原则 利用equals方法进行比较如果我们让Person对象的name一致 认为是同一个对象我们可以重写equals方法重写了equals方法 发现还没有产生无重复的效果证明可能原则不止equals方法这么简单还有另一个规则同时起着作用 hashcode方法</code></pre><h3 id="为什么要重写equals（）方法？"><a href="#为什么要重写equals（）方法？" class="headerlink" title="为什么要重写equals（）方法？"></a>为什么要重写equals（）方法？</h3><pre><code>  因为默认equals在比较两个对象时，是看他们是否指向同一个地址的。但有时，我们需要两个不同对象只要是某些属性相同就认为它们equals（）的结果为true。比如： person p1 = new person(1,&quot;name&quot;); person p2 = new person(1,&quot;name&quot;); 如果不重写equals的话，他们是不相同的，所以我们要重些equals，判断只要他们的id和名字相同equals就为true，在一些集合里有时也这样用，集合里的contain也是用equals来比较   先来看Object关于equals()的源码：   public boolean equals(Object obj) {   return (this == obj);   } //String 就重写了equals方法public boolean equals(Object obj){    if(this==obj){        return true;    }    if(obj instanceof Question) {        Question anotherQuestion = (Question)obj;       //this.title 按照？截取 与anotherQuestion.title截取之前的部分比较        if(this.title.equals(anotherQuestion.title)){            return true;        }    }    return false;}</code></pre><h3 id="当重写equals方法时，同时也要重写hashCode方法。"><a href="#当重写equals方法时，同时也要重写hashCode方法。" class="headerlink" title="当重写equals方法时，同时也要重写hashCode方法。"></a>当重写equals方法时，同时也要重写hashCode方法。</h3><pre><code>//修改equals 方法一定要修改hashcode方法 因为底层用hashCode比较public int hash(){   return this.title.hashCode();}</code></pre><h1 id="TreeSet—–-gt-（TreeMap-二叉树利用Node（Left-item-right））"><a href="#TreeSet—–-gt-（TreeMap-二叉树利用Node（Left-item-right））" class="headerlink" title="TreeSet—–&gt;（TreeMap 二叉树利用Node（Left item right））"></a>TreeSet—–&gt;（TreeMap 二叉树利用Node（Left item right））</h1><h2 id="无序无重复-java-util"><a href="#无序无重复-java-util" class="headerlink" title="无序无重复 java.util"></a>无序无重复 java.util</h2><h2 id="无参构造方法-带Collection构造方法"><a href="#无参构造方法-带Collection构造方法" class="headerlink" title="无参构造方法 带Collection构造方法"></a>无参构造方法 带Collection构造方法</h2><h2 id="基本常用方法"><a href="#基本常用方法" class="headerlink" title="基本常用方法"></a>基本常用方法</h2><pre><code>add(E e)  iterator() remove(E e) 没有修改 size()</code></pre><h2 id="无序无重复规则是如何实现的"><a href="#无序无重复规则是如何实现的" class="headerlink" title="无序无重复规则是如何实现的"></a>无序无重复规则是如何实现的</h2><pre><code>treeSet集合本身是有顺序的  我们指的无序是存入和取出不一致CompaerTo------&gt;String类 按照字母的自然顺序排列//如果想让Person对象存入TeeSet集合内  必须实现Comapareable接口 重写这个方法piublic int compareTo（o.name）{//当前对象name与另一个对象CompareTo结果return this.name.compareTo(o.name);//当前对象name和另一对象name的CompareTO结果}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Collection&quot;&gt;&lt;a href=&quot;#Collection&quot; class=&quot;headerlink&quot; title=&quot;Collection&quot;&gt;&lt;/a&gt;Collection&lt;/h1&gt;&lt;h2 id=&quot;以value形式存在&quot;&gt;&lt;a href=&quot;#以value形式存在&quot;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础      (二十六）</title>
    <link href="http://yoursite.com/2020/03/25/avaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/25/avaSE基础-（二十六）/</id>
    <published>2020-03-25T13:30:11.000Z</published>
    <updated>2020-03-25T16:01:58.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h1 id="Vector-类"><a href="#Vector-类" class="headerlink" title="Vector 类"></a>Vector 类</h1><h2 id="java-util包"><a href="#java-util包" class="headerlink" title="java.util包"></a>java.util包</h2><h2 id="是ArrayList集合-早期版本"><a href="#是ArrayList集合-早期版本" class="headerlink" title="是ArrayList集合 早期版本"></a>是ArrayList集合 早期版本</h2><pre><code>(StringBuffer类早期 Stringbuilder后来) vector底层也是用动态数组来存储 vector是线程同步的 安全性高 效率低</code></pre><h2 id="扩容方式与ArrayList不同"><a href="#扩容方式与ArrayList不同" class="headerlink" title="扩容方式与ArrayList不同"></a>扩容方式与ArrayList不同</h2><pre><code>默认是扩容两倍  可以通过构造方法创建对象时修改这一机制</code></pre><h1 id="Stack类-栈"><a href="#Stack类-栈" class="headerlink" title="Stack类 栈"></a>Stack类 栈</h1><h2 id="java-util包-1"><a href="#java-util包-1" class="headerlink" title="java.util包"></a>java.util包</h2><h2 id="构造方法只有一个无参数"><a href="#构造方法只有一个无参数" class="headerlink" title="构造方法只有一个无参数"></a>构造方法只有一个无参数</h2><h2 id="只有几个特殊的方法"><a href="#只有几个特殊的方法" class="headerlink" title="只有几个特殊的方法"></a>只有几个特殊的方法</h2><pre><code>push(E e)将某个元素压入栈顶（add()）E = pop()将某一个元素从栈顶取出并删掉(E = remove())E = peek()将某一个元素从栈顶取出并删除掉(E = remove())boolean = empty()判断栈顶元素是否为空(isEmpty)int = search()查找给定元素在栈中的位置(indexof())</code></pre><h2 id="中国象棋-悔棋"><a href="#中国象棋-悔棋" class="headerlink" title="中国象棋 悔棋"></a>中国象棋 悔棋</h2><pre><code>栈中存储每一次的操作步骤撤销功能</code></pre><h1 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h1><h2 id="java-util"><a href="#java-util" class="headerlink" title="java.util"></a>java.util</h2><h3 id="通常子类-Linklist-ArrayQueque"><a href="#通常子类-Linklist-ArrayQueque" class="headerlink" title="通常子类 Linklist ArrayQueque"></a>通常子类 Linklist ArrayQueque</h3><h2 id="通常用无参构造方法实现"><a href="#通常用无参构造方法实现" class="headerlink" title="通常用无参构造方法实现"></a>通常用无参构造方法实现</h2><h2 id="一般方法"><a href="#一般方法" class="headerlink" title="一般方法"></a>一般方法</h2><pre><code>add()element()-----&gt;get()remove()boolean = offer(E e);//相当于add  不会抛出异常E = peek();//相当于element方法E =poll; 剪短//相当于remove()</code></pre><h2 id="双十一秒杀"><a href="#双十一秒杀" class="headerlink" title="双十一秒杀"></a>双十一秒杀</h2><pre><code>所有进入秒杀系统的人存入队列</code></pre><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h1 id="Linklist类"><a href="#Linklist类" class="headerlink" title="Linklist类"></a>Linklist类</h1><h2 id="java-util包-2"><a href="#java-util包-2" class="headerlink" title="java.util包"></a>java.util包</h2><h3 id="自己封装过LinkBox-内部类Node-LT-T-GT-对象（节点-prev-item-next）"><a href="#自己封装过LinkBox-内部类Node-LT-T-GT-对象（节点-prev-item-next）" class="headerlink" title="自己封装过LinkBox 内部类Node&LT;T&GT;对象（节点 prev item next）"></a>自己封装过LinkBox 内部类Node&LT;T&GT;对象（节点 prev item next）</h3><h2 id="底层就是使用双向链表的数据结构形式来存储"><a href="#底层就是使用双向链表的数据结构形式来存储" class="headerlink" title="底层就是使用双向链表的数据结构形式来存储"></a>底层就是使用双向链表的数据结构形式来存储</h2><h3 id="适合插入或删除不适合遍历轮循"><a href="#适合插入或删除不适合遍历轮循" class="headerlink" title="适合插入或删除不适合遍历轮循"></a>适合插入或删除不适合遍历轮循</h3><h2 id="构建对象"><a href="#构建对象" class="headerlink" title="构建对象"></a>构建对象</h2><pre><code>无参构造方法 带参数的构造方法（collection）</code></pre><h2 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h2><pre><code>增删改查 add() remove() set() get() size()手册中提供其他常用方法addAll() addFirst() clear() contains()element() getFirst() getLast() indexOf() lastindex()....</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;List&quot;&gt;&lt;a href=&quot;#List&quot; class=&quot;headerlink&quot; title=&quot;List&quot;&gt;&lt;/a&gt;List&lt;/h1&gt;&lt;h1 id=&quot;Vector-类&quot;&gt;&lt;a href=&quot;#Vector-类&quot; class=&quot;headerlink&quot; title=&quot;V
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十五）</title>
    <link href="http://yoursite.com/2020/03/24/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/24/JavaSE基础-（二十五）/</id>
    <published>2020-03-24T14:23:31.000Z</published>
    <updated>2020-03-24T15:58:44.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合相关"><a href="#集合相关" class="headerlink" title="集合相关"></a>集合相关</h1><h2 id="变量–容器"><a href="#变量–容器" class="headerlink" title="变量–容器"></a>变量–容器</h2><pre><code>存取一个元素</code></pre><h2 id="数组–容器"><a href="#数组–容器" class="headerlink" title="数组–容器"></a>数组–容器</h2><pre><code>一组具有某种特性的数据存放在一起       存储一组元素（数据类型一致）  长度固定</code></pre><h2 id="集合–容器"><a href="#集合–容器" class="headerlink" title="集合–容器"></a>集合–容器</h2><pre><code>与数组类似 集合的长度存储之后还能改变集合用来存储一组元素</code></pre><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><pre><code>存的都是value</code></pre><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><pre><code>有序可重复</code></pre><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><pre><code>无序无重复</code></pre><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><pre><code>存储的是以key-value形式存在key无序无重复  value无序可重复</code></pre><h3 id="序：顺序"><a href="#序：顺序" class="headerlink" title="序：顺序"></a>序：顺序</h3><pre><code>添加进去的元素 取得元素的顺序一致 注意指的不是集合自己的顺序</code></pre><h3 id="重复：两个对象一致"><a href="#重复：两个对象一致" class="headerlink" title="重复：两个对象一致"></a>重复：两个对象一致</h3><h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><p>   1.ArrayList 2.LinkList 3.Vector</p><h3 id="ArrayList——-底层就是一个数组"><a href="#ArrayList——-底层就是一个数组" class="headerlink" title="ArrayList——-底层就是一个数组"></a>ArrayList——-底层就是一个数组</h3><h3 id="所属的包-java-util"><a href="#所属的包-java-util" class="headerlink" title="所属的包 java.util"></a>所属的包 java.util</h3><h3 id="如何创建对象"><a href="#如何创建对象" class="headerlink" title="如何创建对象"></a>如何创建对象</h3><pre><code>无参数构造方法 带默认参数的都构造方法 带collection参数的构造方法</code></pre><h3 id="常用的方法-—小容器"><a href="#常用的方法-—小容器" class="headerlink" title="常用的方法 —小容器"></a>常用的方法 —小容器</h3><pre><code>   存 add   取 get   删 remove   改   个数 sizeadd(E e) add(int index,E e)addAll(Collection c); add(int index,Collection c)clear();将集合内的元素全部清除boolean = contains(Object);找寻一个给定元素集合中是否拥有ensureCapacity(int minCapacity);E = get(int index);int = indexOf(Object obj); lastindexOf();isEmpty();iterator;//迭代器 1.5之后增强forremoveAll 差集 retainAll()交集addAll()并集E = set(int index,E value)int size();List = subList(int index,E value)toArray();集合变成数组toArray(T[]);trimToSize();//变成有效元素个数那么长</code></pre><h3 id="arryList底层是一个Object"><a href="#arryList底层是一个Object" class="headerlink" title="arryList底层是一个Object[]"></a>arryList底层是一个Object[]</h3><pre><code>什么类型都可以存进去取出来的时候多态效果 需要自己造型 显得用起来非常麻烦</code></pre><h3 id="JDK1-5之后—-gt-泛型"><a href="#JDK1-5之后—-gt-泛型" class="headerlink" title="JDK1.5之后—-&gt;泛型"></a>JDK1.5之后—-&gt;泛型</h3><pre><code>用来规定数据类型的,定义的时候用一个符号代替某种类型在使用的时候具体的数据类型 将定义的那个符号替换掉ArrayBox&lt;T&gt;</code></pre><h3 id="泛型可以用在哪里？"><a href="#泛型可以用在哪里？" class="headerlink" title="泛型可以用在哪里？"></a>泛型可以用在哪里？</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><pre><code>类定义的时候描述某种数据类型 集合就是这样使用</code></pre><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><pre><code>与泛型类的使用基本一致 子类实现接口时必须添加泛型public interface Text&lt;X&gt;{     public X value;}public class Son&lt;X&gt;implements Test&lt;X&gt;</code></pre><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><pre><code>方法调用时传参数 方法的泛型与类无关 带有泛型的方法可以不放在带有泛型的类中</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集合相关&quot;&gt;&lt;a href=&quot;#集合相关&quot; class=&quot;headerlink&quot; title=&quot;集合相关&quot;&gt;&lt;/a&gt;集合相关&lt;/h1&gt;&lt;h2 id=&quot;变量–容器&quot;&gt;&lt;a href=&quot;#变量–容器&quot; class=&quot;headerlink&quot; title=&quot;变量–容器&quot;&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十四）</title>
    <link href="http://yoursite.com/2020/03/24/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/24/JavaSE基础-（二十四）/</id>
    <published>2020-03-24T13:51:09.000Z</published>
    <updated>2020-03-24T15:58:51.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式-regex"><a href="#正则表达式-regex" class="headerlink" title="正则表达式 regex"></a>正则表达式 regex</h1><pre><code>Regualar有规律的   Expression表达式匹配字符串格式的</code></pre><h2 id="正则表达式通常的作用如下"><a href="#正则表达式通常的作用如下" class="headerlink" title="正则表达式通常的作用如下"></a>正则表达式通常的作用如下</h2><h3 id="字符串格式的校验"><a href="#字符串格式的校验" class="headerlink" title="字符串格式的校验"></a>字符串格式的校验</h3><pre><code>String类中提供的方法 boolean = str.match(&quot;regex&quot;);</code></pre><h3 id="字符串的拆分及替换"><a href="#字符串的拆分及替换" class="headerlink" title="字符串的拆分及替换"></a>字符串的拆分及替换</h3><pre><code>String类中提供的方法 replace split</code></pre><h3 id="字符串的查找"><a href="#字符串的查找" class="headerlink" title="字符串的查找"></a>字符串的查找</h3><pre><code>pattern模式 Matcher匹配器[abc]       abc中的一个[^abc]      不能是abc中的一个 其他都可以[a-zA-Z]     表示必须是这两个范围内的[a-z&amp;&amp;[^bc]]  表示a-z其中的一个但不能是b和c.代表任意一个字符\d digit [0-9]\D 非数字[^0-9]\S 非留白\w word单词 [0-9A-Za-z]数字或字母都可以</code></pre><h3 id="所有字符串中寻找如下规则的信息-邮政编码"><a href="#所有字符串中寻找如下规则的信息-邮政编码" class="headerlink" title="所有字符串中寻找如下规则的信息 邮政编码"></a>所有字符串中寻找如下规则的信息 邮政编码</h3><pre><code>String str = &quot;123456abc123456abc123456abc&quot;//1.利用pattern模式创建一个模式 理解为一个正则表达式对象Pattern pattern = Pattern.compile（&quot;\\d{6}&quot;）;//邮编//2.需要提供一个字符串//3.利用pattern模式对象创建一个匹配器Matcher matcher = pattern.matcher(str);//4.找寻字符串中出现满足上述格式的字串   while(matcher.find()){    System.out.println(matcher.group());//找到满足字符串格式的那一串文字</code></pre><h3 id="如下所有都用来描述字符出现的次数"><a href="#如下所有都用来描述字符出现的次数" class="headerlink" title="如下所有都用来描述字符出现的次数"></a>如下所有都用来描述字符出现的次数</h3><pre><code>？ 0-1次 [0-9]?*  0-n次 +  1-n次{n} 固定n次{n,}至少出现n次{m,n}m-n次</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;正则表达式-regex&quot;&gt;&lt;a href=&quot;#正则表达式-regex&quot; class=&quot;headerlink&quot; title=&quot;正则表达式 regex&quot;&gt;&lt;/a&gt;正则表达式 regex&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;Regualar有规律的   Expression表
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十三）</title>
    <link href="http://yoursite.com/2020/03/24/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/24/JavaSE基础-（二十三）/</id>
    <published>2020-03-24T12:54:08.000Z</published>
    <updated>2020-03-24T15:58:57.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="StringBuffer-StringBuilder"><a href="#StringBuffer-StringBuilder" class="headerlink" title="StringBuffer/StringBuilder"></a>StringBuffer/StringBuilder</h1><h2 id="所属的包"><a href="#所属的包" class="headerlink" title="所属的包"></a>所属的包</h2><pre><code>java.lang包</code></pre><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><pre><code>Serializable,CharSequence,Comparable非常特殊的类 可以像常量一样创建对象String str = &quot;abc&quot;;内存存储 &quot;abc&quot;对象 char[] valueString的不可变特性   private fianl char[] value频繁的修改内容的时候 性能不是很好</code></pre><h2 id="默认继承"><a href="#默认继承" class="headerlink" title="默认继承"></a>默认继承</h2><pre><code>obJect 实现接口Serialzable,CharSequence,AppendableStringBuffer/StringBuilder 没有compare To方法StringBuffer/StringBuilder 含有一个String没有的方法 append();拼接</code></pre><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><pre><code>可变字符串 char[] value;动态扩容</code></pre><h2 id="对象的构建"><a href="#对象的构建" class="headerlink" title="对象的构建"></a>对象的构建</h2><pre><code>无参数构造方法有参数构造方法//无参数构造方法 构建一个默认长度16个对象空间 char[] StringBuilder builder = new StringBuilder();//利用给定的参数 构建有一个自定义长度空间的对象 char[] StringBuilder builder = new StringBuilder(20);//利用带String参数的构造方法,默认数组字符长度字符串+16个长度 StringBuilder builder = new StringBuilder(&quot;abc&quot;);</code></pre><h2 id="StringBuilder中的常用方法"><a href="#StringBuilder中的常用方法" class="headerlink" title="StringBuilder中的常用方法"></a>StringBuilder中的常用方法</h2><pre><code>最主要的方法 append() 频繁的拼接字符串时候使用此方法 提高性能capcacity();字符串底层char[]的容量length();字符串有效元素个数（长度）char = charAt(int index);int = codePointAt(int index);String = substring(int start,[int end]);        注意需要接收返回值 看见取出来的字符串效果delete(int start,[int end]);        String Builder类中独有的方法String类没有        将Start到end之间的字符串删掉 不用接收返回值就看到效果啦int = indexOf(String str,[int fromindex]);int = lastindexof（String str,[int fromIndex]）        找寻给定的str字符串中第一次出现的索引位置 带重载 则从某一个位置开始找StringBuilder = deleteCharAt(int Index)        String类中没有的方法        将给定inde位置的某一字符串删除insert(int index,value);        将给定的value插入在index上replace(int start，int end，string str);        将start和end之间的部分替换成str        builder.replace(2.5,&quot;zzt&quot;)setCharAt(int index,char value);        将index位置的字符改成给定字符的valuetoString()        将StringBuilder对象 构建成一个string对象 返回trimToSize()        将数组无用的容量去掉 变成length长度的数组</code></pre><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><h3 id="StringBuilder类不一定需要"><a href="#StringBuilder类不一定需要" class="headerlink" title="StringBuilder类不一定需要"></a>StringBuilder类不一定需要</h3><pre><code>是为了避免String频繁拼接修改字符串信息时才使用的 底层是数组是可变的 提高了性能</code></pre><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><pre><code>与String类不同独有的方法append() lnsert() delete() deleteCharAt() reverse()与String类相同的方法charAt() codePointAt() indexOf() lastindexOf() replace() 名字相同 用法不一致不是很常用的方法ensureCapacity() capacity() SetLength() trimToSize() setCharAt();</code></pre><h3 id="String家族笔试中经常考察的知识点"><a href="#String家族笔试中经常考察的知识点" class="headerlink" title="String家族笔试中经常考察的知识点"></a>String家族笔试中经常考察的知识点</h3><h4 id="String所属的包-继承关系-实现接口"><a href="#String所属的包-继承关系-实现接口" class="headerlink" title="String所属的包 继承关系 实现接口"></a>String所属的包 继承关系 实现接口</h4><pre><code>java.lang包 继承Object 实现接口Serializable,CharSequence,Comparable</code></pre><h4 id="String构建方式"><a href="#String构建方式" class="headerlink" title="String构建方式"></a>String构建方式</h4><pre><code>常量 构造方法</code></pre><h4 id="String对象内存结构"><a href="#String对象内存结构" class="headerlink" title="String对象内存结构"></a>String对象内存结构</h4><pre><code>字符串常量区 new堆内存对象= = equals()区别&quot;a&quot; +&quot;b&quot;+&quot;c&quot;</code></pre><h4 id="String不可不变特性"><a href="#String不可不变特性" class="headerlink" title="String不可不变特性"></a>String不可不变特性</h4><pre><code>长度及内容</code></pre><h4 id="String类常用的方法—-与StringBuilder的区别"><a href="#String类常用的方法—-与StringBuilder的区别" class="headerlink" title="String类常用的方法—-与StringBuilder的区别"></a>String类常用的方法—-与StringBuilder的区别</h4><pre><code>concat(); toUpperCase();</code></pre><h4 id="String和StringBuilder区别-String和StringBuffer区别"><a href="#String和StringBuilder区别-String和StringBuffer区别" class="headerlink" title="String和StringBuilder区别|String和StringBuffer区别"></a>String和StringBuilder区别|String和StringBuffer区别</h4><pre><code>String不可变字符串        有一个接口Comparable        不可变体现在长度及内容        有一些方法StringBuilder没有 没有concat compareTo toUpperCaseStringBuilder可变字符串        JDK1.5        有一个接口Appendable        可变字符串 没有final修饰 底层可以进行数组扩容        有一些方法string没有 append() insert() delete() reverse()</code></pre><h4 id="StringBuffer和StringBuild的不同"><a href="#StringBuffer和StringBuild的不同" class="headerlink" title="StringBuffer和StringBuild的不同"></a>StringBuffer和StringBuild的不同</h4><pre><code>stringBuffer早期版本1.0StringBuilder后来的版本1.5方法使用几乎一致早期版本 线程同步  安全性比较高 执行效率相对较低后期版本 线程非同步 安全性能比较低 执行效率相对较高</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;StringBuffer-StringBuilder&quot;&gt;&lt;a href=&quot;#StringBuffer-StringBuilder&quot; class=&quot;headerlink&quot; title=&quot;StringBuffer/StringBuilder&quot;&gt;&lt;/a&gt;StringBu
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十二）</title>
    <link href="http://yoursite.com/2020/03/23/avaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/23/avaSE基础-（二十二）/</id>
    <published>2020-03-23T14:40:39.000Z</published>
    <updated>2020-03-23T15:47:49.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h1><h2 id="String类—-gt-引用类型-java-lang包"><a href="#String类—-gt-引用类型-java-lang包" class="headerlink" title="String类—-&gt;引用类型 java.lang包"></a>String类—-&gt;引用类型 java.lang包</h2><h3 id="0-常见的String笔试题"><a href="#0-常见的String笔试题" class="headerlink" title="0.常见的String笔试题"></a>0.常见的String笔试题</h3><pre><code>==  equals方法和区别             ==可以比较基本类型 也可以比较引用类型             比较基本类型只比较值 比较引用类型比较地址             equals只能比较引用类型（方法）             默认比较地址this == obj             如果想要修改比较规则可以重写equals方法             通常重写equals方法会伴随重写hashcode方法String的不可变特性             长度及内容String与StringBuffer区别StringBuffer与StringBuilder区别String对象的存储             &quot;abc&quot;-----&gt;字符串常量池             new String（&quot;abc&quot;）---&gt;堆内存*string中的常用方法</code></pre><h3 id="1-存在哪-java-lang包"><a href="#1-存在哪-java-lang包" class="headerlink" title="1.存在哪  java.lang包"></a>1.存在哪  java.lang包</h3><pre><code>没有任何继承关系  实现三个接口Serializable,CharSequence,Comparable</code></pre><h3 id="2-如何构建对象"><a href="#2-如何构建对象" class="headerlink" title="2.如何构建对象"></a>2.如何构建对象</h3><pre><code>String str = &quot;abc&quot;; //直接将字符串常量赋值给str （字符串常量池）String str = new String();//无参函数构造方法创建空的对象String str = new String(&quot;abc&quot;);//带参String构造方法创建对象String str = new String(byte[]);//将数组中的每一个元素转化成对应的char 组合成strString str = new String(char[]);//将数组中的每一个char元素拼接成最终的String</code></pre><h3 id="3-String的不可变特性"><a href="#3-String的不可变特性" class="headerlink" title="3.String的不可变特性"></a>3.String的不可变特性</h3><pre><code>体现在两个地方 长度及内容长度-----&gt;final修饰的数组  数组长度不变 final修饰素组的地址不变内容-----&gt;private修饰的属性 不能再类外访问在String类中包含一个 数组private fianl char[] value;//存储String中的每一个字符fianl最终是不可改变的----&gt;地址不让改变 数组的长度本身不可变private私有的当前类中----&gt;数组中的内容也不能改变</code></pre><h3 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="*4.常用方法"></a>*4.常用方法</h3><pre><code>booean = equals(Obj obj);     //继承自Object类 重写啦 比较两个字符串的字面值是否相等int = hashCode();     //继承自object类 重写啦 将当前字符串的每一个char元素拆开 乘以31求和int = CompareTo(String str);    //实现Comparable接口 实现啦 按照字典（Unicode编码）索引的顺序比较String = toString();    //继承自Object 重写啦 不在输出@hashCode 字符串中的字面值</code></pre><h3 id="5-char-charAt-int-index"><a href="#5-char-charAt-int-index" class="headerlink" title="5.char = charAt(int index);"></a>5.char = charAt(int index);</h3><pre><code>返回给定index位置对应的字符int = codePointAt(int index);返回给定index位置对应字符的code码</code></pre><h3 id="6-int-length"><a href="#6-int-length" class="headerlink" title="6.int = length();"></a>6.int = length();</h3><pre><code>返回字符串的长度 （其实就是底层 char[] value属性的长度）注意：区别数组length是属性 String的length()方法  集合size()方法</code></pre><h3 id="7-String-concat-String-str"><a href="#7-String-concat-String-str" class="headerlink" title="7.String = concat(String str);"></a>7.String = concat(String str);</h3><pre><code>将给定的str拼接在当前String对象的后面注意：方法执行完毕需要接受返回值 String的不可变特性      concat方法与 + 拼接性能的问题      开发中若遇到频繁拼接字符串-----&gt;通常使用stringBuilder/stringBuffer</code></pre><h3 id="8-boolean-contains（”s”）"><a href="#8-boolean-contains（”s”）" class="headerlink" title="8.boolean = contains（”s”）;"></a>8.boolean = contains（”s”）;</h3><pre><code>判断给定的s在字符串中是否存在</code></pre><h3 id="9-statsWith-String-prefix）-nbsp-nbsp-endWith（String-suffix）"><a href="#9-statsWith-String-prefix）-nbsp-nbsp-endWith（String-suffix）" class="headerlink" title="9.statsWith(String prefix）;  &nbsp;&nbsp; endWith（String suffix）;"></a>9.statsWith(String prefix）; <br> &nbsp;&nbsp; endWith（String suffix）;</h3><pre><code>判断此字符串是否已XX开头/结尾</code></pre><h3 id="10-byte-getBytes-—-gt-getBytes-String-charsetName-char-toCharArray"><a href="#10-byte-getBytes-—-gt-getBytes-String-charsetName-char-toCharArray" class="headerlink" title="10.byte[] = getBytes();—-&gt;getBytes(String charsetName); char[] = toCharArray[];"></a>10.byte[] = getBytes();—-&gt;getBytes(String charsetName); char[] = toCharArray[];</h3><pre><code>将当前字符串转化为数组 “我爱你中国”“我”“爱”“你”“中”“国”</code></pre><h3 id="11-int-index-indexOf-int-String-str-int-fromindex"><a href="#11-int-index-indexOf-int-String-str-int-fromindex" class="headerlink" title="11.int index = indexOf(int/String str,[int fromindex]);"></a>11.int index = indexOf(int/String str,[int fromindex]);</h3><pre><code>四个方法重载，找寻给定元素在字符串第一次出现的索引位置 若不存在返回-1lastIndexOf(int/String str,[int fromindex]);找寻给定元素在字符串最后一次出现的索引位置 若不存在返回-1</code></pre><h3 id="12-boolean-isEmpty"><a href="#12-boolean-isEmpty" class="headerlink" title="12.boolean = isEmpty();"></a>12.boolean = isEmpty();</h3><pre><code>判断当前字符串是否为空字符串（length是否为0）注意与null之间的区别</code></pre><h3 id="13-replace-replaceAll-replaceFirst"><a href="#13-replace-replaceAll-replaceFirst" class="headerlink" title="13.replace(); replaceAll(); replaceFirst();"></a>13.replace(); replaceAll(); replaceFirst();</h3><pre><code>将给定字符串替换成另一个字符串</code></pre><h3 id="14-String-split（String-regex-int-limit限度界限-）"><a href="#14-String-split（String-regex-int-limit限度界限-）" class="headerlink" title="14.String[] = split（String regex, [int limit限度界限]）;"></a>14.String[] = split（String regex, [int limit限度界限]）;</h3><pre><code>按照正则表达式将原来的字符串拆开   String str=&quot;a-b-c-d&quot;;   String[] value = str.split(&quot;-&quot;,3);   for(String v:value){     System.out.println(v);   }  </code></pre><h3 id="15-String-substring-int-beginIndex-int-endIndex"><a href="#15-String-substring-int-beginIndex-int-endIndex" class="headerlink" title="15.String = substring(int beginIndex),[int endIndex]);"></a>15.String = substring(int beginIndex),[int endIndex]);</h3><pre><code>将当前字符串截取一部分从beginIndex开始至endIndex结束[beginIndex，endIndex)若endIndex不写 则默认到字符串最后</code></pre><h3 id="16-String-toUpperCase-String-toLowerCase"><a href="#16-String-toUpperCase-String-toLowerCase" class="headerlink" title="16.String = toUpperCase();String = toLowerCase();"></a>16.String = toUpperCase();<br>String = toLowerCase();</h3><pre><code>将全部字母转换成大写/小写</code></pre><h3 id="17-String-trim"><a href="#17-String-trim" class="headerlink" title="17.String = trim();"></a>17.String = trim();</h3><pre><code>去掉字符串前后多余的空格</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字符串相关&quot;&gt;&lt;a href=&quot;#字符串相关&quot; class=&quot;headerlink&quot; title=&quot;字符串相关&quot;&gt;&lt;/a&gt;字符串相关&lt;/h1&gt;&lt;h2 id=&quot;String类—-gt-引用类型-java-lang包&quot;&gt;&lt;a href=&quot;#String类—-gt-引用
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十一）</title>
    <link href="http://yoursite.com/2020/03/23/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/23/JavaSE基础-（二十一）/</id>
    <published>2020-03-23T14:02:16.000Z</published>
    <updated>2020-03-23T15:47:41.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日期相关"><a href="#日期相关" class="headerlink" title="日期相关"></a>日期相关</h1><h2 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h2><pre><code>1.通常使用的是java.util包2.导包 拿来使用 构建对象3.通常使用的是无参构造方法 或者带long构造方法4.Date类中常用的方法     before();after();     setTime();getTime();     compareTo();5.可以处理一个Date日期的格式</code></pre><h2 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h2><pre><code>1.java.text包 需要导包2.此类是一个抽象类 不能创建对象 子类来使用3.SimpleDarteFormat类 是DateFormat的子类4.调用String参数的构造方法创建format对象       SimpleDateFormat sdf =  new Simple DateFormat(&quot;yyyyy--MM--dd HH:mm:ss&quot;)        string v = sdf.format(date.1)//通过sdf将对象格式化成你描述的样子</code></pre><h2 id="Calendar-1-1版本"><a href="#Calendar-1-1版本" class="headerlink" title="Calendar 1.1版本"></a>Calendar 1.1版本</h2><pre><code>1.所属的包 java.util 需要导包2.有构造方法 用protected修饰的 通常访问不到 通常还会调用默认的getInstance()3.常用方法        after() before()        setTime() getTime()---&gt;Date        getTimeInMills()----time        getTimeZone()----TimeZone        Calendar calendar = Calendar.getInstance();//系统当前时间的Calendar对象        Calendar里面包含一个date属性 可以操作某一个局部信息        set get        calendar.set（Calendar.YEAR,2015）;        int year = calendar.get（Calendar.YEAR）;</code></pre><h2 id="TimeZone"><a href="#TimeZone" class="headerlink" title="TimeZone"></a>TimeZone</h2><pre><code>1.java.util包2.可以通过calendar对象.getTimeZone（）获取 或 TimeZone.getDefault();3.常用方法        tz.getID();       System.out.println(tz.getDisplayName());</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;日期相关&quot;&gt;&lt;a href=&quot;#日期相关&quot; class=&quot;headerlink&quot; title=&quot;日期相关&quot;&gt;&lt;/a&gt;日期相关&lt;/h1&gt;&lt;h2 id=&quot;Date类&quot;&gt;&lt;a href=&quot;#Date类&quot; class=&quot;headerlink&quot; title=&quot;Date类&quot;&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （二十）</title>
    <link href="http://yoursite.com/2020/03/23/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/23/JavaSE基础-（二十）/</id>
    <published>2020-03-23T12:50:35.000Z</published>
    <updated>2020-03-23T15:47:35.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java中提供的工具类——-官方API帮助文档"><a href="#java中提供的工具类——-官方API帮助文档" class="headerlink" title="java中提供的工具类——-官方API帮助文档"></a>java中提供的工具类——-官方API帮助文档</h1><pre><code>Application  Programming interface应用程序编程接口,一些预先创建好的类及方法，目的是为了让我们更好的进行程序开发</code></pre><h2 id="与数学相关的类—-Math类"><a href="#与数学相关的类—-Math类" class="headerlink" title="与数学相关的类—-Math类"></a>与数学相关的类—-Math类</h2><pre><code>1.所属的包java.lang2.Math构造方法是私有的 我们不能直接调用创建对象3.由于Math中提供的属性方法都是static 不需要创建对象4.常用的方法           abs()返回给定数字的绝对值 （参数 int long float double）           double = ceil() 向上取整           double = floor()向下取整           double = rint() 临近的整数 如果两边距离一样则返回偶数           int = round 四舍五入的整数           max（a，b） min（a，b）参数int long float double            pow（a，b） a的b次方（参数double 返回值double）           sqrt（double a） 获取给定参数的平方根           double = random(); 随机产生一个  [0.0-1.0] 5.Math.randon()计算小数的时候精确度可能会有些损失               0-9之间的随机整数               int Value = （int）(Math.random()*10);               5.0----10.9之间的小数               （Math.random()*6)+5               0.0----0.99999 * 6               (0.0---5.49999)+5</code></pre><h2 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h2><pre><code>1.在java.util包中的类 需要import导入2.没有任何继承关系 默认继承Object类3.查找构造方法----》如何创建对象        Random r = new Random();4.类中常用的方法        r.nextInt(); 随机产生int范围内的整数  有正有负        r.nextInt(int bound);随机产生一个[0-bound]整数                 注意bound必须为正数 否则会出现如下的运行时异常                 IllegalArgumentException        r.nextFloat() 随机产生一个[0.0--1.0]        r.nextBoolean()随机产生一个boolean值 true false        //调用的方法都需要用相对应类型的变量接收值</code></pre><h2 id="UUID类"><a href="#UUID类" class="headerlink" title="UUID类"></a>UUID类</h2><pre><code>1.所属的包 java.util  需要import导入2.没有任何继承关系 默认继承Object类3.构造方法有 没有无参的 我们通常不会创建对象          UUID  uuid = UUID.randomUUID();          System.out.println(uuid.toString());//数据库表格主键primary key          产生一个32位的随机元素 每一个位置都是16进制的数字</code></pre><h2 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h2><pre><code>1.所属的包java.math  需要impor导入2.继承自Number3.如何创建对象 提供的构造方法都是带参的        通常利用String参数的构造方法创建这个类的对象        BigInteger bi = new BigInteger{&quot;123&quot;};4.类中常用的方法        做四则运算        add()  substract() multiply() divide()5.小例子 设计一个方法 用来设计给定数字的阶乘        //设计一个方法 用来设计数字的阶乘       //参数 返回值       Public BigInteger factorial(int num){            BigInteger result = new BigInteger(&quot;1&quot;);            for(int i = 1;i &lt;= num;i++){                result=result.multiply(new BigInteger(i+&quot; &quot;))        }        retrun result;      } </code></pre><h2 id="BigDecimal类-超过了double取值范围"><a href="#BigDecimal类-超过了double取值范围" class="headerlink" title="BigDecimal类  超过了double取值范围"></a>BigDecimal类  超过了double取值范围</h2><pre><code>1.所属的包  java.math包2.继承Number类3.通常可以通过 带String参数构造对象4.类中常用的方法         做四则运算         add()  substract() multiply() divide()         两个参数前面保留小数点之后的位数，后面的参数是设置的格式如何保留         对象.setScale(2,BigDecimal.ROUND_DOWN);</code></pre><h2 id="DecimalFormat——-格式化"><a href="#DecimalFormat——-格式化" class="headerlink" title="DecimalFormat——-格式化"></a>DecimalFormat——-格式化</h2><pre><code>1.所属的包 java.text2.import导入才能使用3.通过带String参数的构造方法格式化创建成一个字符串            DecimalFormat df = new DecimalFormat（&quot;000.###&quot;）;            String value = df.format(12.45);            System.out.println(value);1.</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java中提供的工具类——-官方API帮助文档&quot;&gt;&lt;a href=&quot;#java中提供的工具类——-官方API帮助文档&quot; class=&quot;headerlink&quot; title=&quot;java中提供的工具类——-官方API帮助文档&quot;&gt;&lt;/a&gt;java中提供的工具类——-官方A
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十九）</title>
    <link href="http://yoursite.com/2020/03/22/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/22/JavaSE基础-（十九）/</id>
    <published>2020-03-22T15:29:06.000Z</published>
    <updated>2020-03-22T15:58:56.288Z</updated>
    
    <content type="html"><![CDATA[<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><pre><code>1.类所在的包2.类的关系 自己默认继承 实现3，类中提供常用方法4.是否可以创建对象 调用 方法本身是静态的包装类（封装类） 1.5版本之后自动拆包byte----Byte   short----Short   int------Integer  long-----Longfloat-----Float  double-----Double char-----Character boolean----Boolean1.八个包装类都在同一个包下  java.lang包  不需要import导包自己使用2.八个包装类有六个都是与数字有关  都默认继承父类Number3.八个包装类都实现了Serializable，Comparable4.八个包装类都带有自己对应类型参数的构造方法 八个包装类中有7个（除了Character）有构造方法重载 带String类型5.创建对象  对象调用方法     有六个与数字相关的类都继承Number   xxValue();将一个包装类类型转化为对应的基本类型（拆包）Interger i1 = new Interger（10）//引用数据类型 包装类 int value = i1.intValue(); int value  = Inter.parseInt(&quot;123&quot;)  Float.parseFloat(&quot;123.45&quot;) int value  = new Integer(&quot;123&quot;);</code></pre><h3 id="经常在笔试中出现的问题"><a href="#经常在笔试中出现的问题" class="headerlink" title="经常在笔试中出现的问题"></a>经常在笔试中出现的问题</h3><pre><code>       integer i1 = 10;       integer i2 = 10;       integer i3 = new Integer(10);       integer i4 = new Integer(10);       System.out.println(i1==i2);//true       System.out.println(i1==i3);//false       System.out,println(i3==i4);//false       System.out.pritnln(i1.equals(i2));//true       System.out.pritnln(i1.equals(i3));//true       System.out.pritnln(i1.equals(i4));//true 1.==与equals()的区别  ==可以比较基本数据类型 也可以比较引用数据类型（变量中存储的内容）  如果比较基本类型比较的是变量中存储的值  如果比较的是引用类型比较的是变量中存储地址的引用  equals()是Object类中继承过来的方法==一致 如果想要改变比较规则 可以重写equals方法  由于integer类就重写了equals()所以Integer比较的是数值2.考察Integer类加载的时候有一个静态空间  空间内立即加载Integer类型的数组 内存储256个Integer对象 -128-127  如果我们用的对象范围在这之内 integer i1 = 10;直接取静态元素区中找对应的对象  如果我们用的对象范围超出了Integer i1 = 1000; 会帮我们创建一个新的Integer对象</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;包装类&quot;&gt;&lt;a href=&quot;#包装类&quot; class=&quot;headerlink&quot; title=&quot;包装类&quot;&gt;&lt;/a&gt;包装类&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1.类所在的包
2.类的关系 自己默认继承 实现
3，类中提供常用方法
4.是否可以创建对象 调用 方法本身是静态的
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十八）</title>
    <link href="http://yoursite.com/2020/03/22/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89-1/"/>
    <id>http://yoursite.com/2020/03/22/JavaSE基础-（十八）-1/</id>
    <published>2020-03-22T15:28:17.000Z</published>
    <updated>2020-03-22T15:58:30.992Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>1.成员内部类</p><pre><code>将一个类直接定义在类的里面，作为成员，与属性或方法层次一次成员内部类可以与正常类一样 使用不同的修饰符去修饰好处1.省略了一个.java文件 好处2.成员内部类可以访问外部类的所有成员 包括私有的若想要在内部类中通过对象.调用外部类成员  外部类.this.外部类成员内部类存在后 源代码进行编译 产生一个字节码 Demo$InnerDemo.class</code></pre><p>2.局部内部类</p><pre><code>将一个类定义在方法/块里面,作为成员的内部结构，与临时的局部变量一个层次局部内部类像是一个局部变量一样，不能用public protected privtae及staic只能用abstract或final局部内部类命名规则Demo$InnerTestMethod局部内部类使用的变量只能用final修饰</code></pre><p>3.匿名内部类<br><br>        成员匿名内部类<br><br>        局部匿名内部类</p><pre><code>public interface Test{          public void test();} Test t = new Test{          public void test(){          }} ;通常接口或抽象类的具体子类这样写开发中为了省略一个类文件 上诉写法比较常见匿名内部类很特殊 只有类体 没有类的所有结构（修饰符 名字 继承 实现）      不能用任何修饰符来修饰 匿名内部类也没有任何构造方法</code></pre><p>4.静态内部类</p><pre><code>成员静态内部类不需要外部类对象，通过正常的方式直接创建内部类静态元素不能访问非静态成员（自己类和外部类）</code></pre><h2 id="枚举类enum"><a href="#枚举类enum" class="headerlink" title="枚举类enum"></a>枚举类enum</h2><h4 id="一个类中的对象-认为个数有限且固定的，可以将每一个对象一一列举出来"><a href="#一个类中的对象-认为个数有限且固定的，可以将每一个对象一一列举出来" class="headerlink" title="一个类中的对象 认为个数有限且固定的，可以将每一个对象一一列举出来"></a>一个类中的对象 认为个数有限且固定的，可以将每一个对象一一列举出来</h4><pre><code> 1.试一试若没有枚举类型的时候如何动手设计（静态常量 单例模式）Day（类 当做描述星期七个对象）      private 构造方法      public static final 属性 = new      //构造方法私有        private Day(){}      //所有对象都是属性      public static final Day monday = new Day(); 2.JDK1.5版本后可以直接定义enmu类型      我们自己定义的enmu类型直接默认继承enmu（java.lang包）      我们自己定义的enmu类型不能再写extrends但是可以实现      Enum类型             有两个属性             name-------&gt;枚举对象的名字   name()获取name的属性             ordinal------&gt;枚举对象在罗列中的顺序  类似index 也从0开始 ordinal获取序列号             常用的方法             valueof()  通过给定的name获取对应的枚举对象             values()   获取全部的枚举对象----&gt;返回一个数组 Day[]             compaerTo() 可以比较两个枚举对象 int             toString()  由于这个方法没有final修饰 可以覆盖（重写）3.我们也可以在enum中描述自己的一些属性或方法      必须在enum类中第一行 描述一下枚举的样子 最后需要分号结束;      可以定义自己的属性      类创建过程中 帮我们创建枚举类型的对象      需要给枚举型提供对应样子的构造方法 方法只能private修饰 可以重载</code></pre><h3 id="内存机制问题"><a href="#内存机制问题" class="headerlink" title="内存机制问题"></a>内存机制问题</h3><pre><code>栈内存-----&gt;Person p = new Person();-----&gt;堆内存   方法区----类模板栈内存-----&gt;创建开始  用完立即回收   StackoverflowError方法区-----&gt;类 常量 静态 只有一份回收不了堆内存-----&gt;new创建的对象 Garbage Collection 垃圾回收器Runtime类之中提供了几个管理内存的方法        maxMemory        totalMemory        freeMemory        堆内存溢出错误OutOfMemoryErrorObject类中有一个finalize方法 如果重写也能看见对象回收GC系统提供的一个线程  回收算法</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;内部类&quot;&gt;&lt;a href=&quot;#内部类&quot; class=&quot;headerlink&quot; title=&quot;内部类&quot;&gt;&lt;/a&gt;内部类&lt;/h3&gt;&lt;p&gt;1.成员内部类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;将一个类直接定义在类的里面，作为成员，与属性或方法层次一次
成员内部类可以与正常类一样
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十七）</title>
    <link href="http://yoursite.com/2020/03/22/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/22/JavaSE基础-（十七）/</id>
    <published>2020-03-22T13:57:03.000Z</published>
    <updated>2020-03-22T15:58:10.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="策略者模式-Strategy-nbsp-———-行为型模式"><a href="#策略者模式-Strategy-nbsp-———-行为型模式" class="headerlink" title="策略者模式 Strategy &nbsp; ——— 行为型模式"></a>策略者模式 Strategy &nbsp; ——— 行为型模式</h2><h4 id="用来解决-执行流程固定-执行结果由于提供不同策略而不同"><a href="#用来解决-执行流程固定-执行结果由于提供不同策略而不同" class="headerlink" title="用来解决  执行流程固定 执行结果由于提供不同策略而不同"></a>用来解决  执行流程固定 执行结果由于提供不同策略而不同</h4><pre><code>              银行类                  profession（人）{  人----抽象类 接口（不能产生对象） 传递一个子类对象                  欢迎用户进来                  叫号                  办理                  离开                  欢迎您下次再来                  }             长者   年轻人  vip            //按普通设计  可能有问题              1.三个不同的人类方法名不一致（可以）              2.银行办理业务的方法写了3个            //解决上诉所述问题可以在三个人之上创建一个父类              1.解决桑个人类中相同代码 比如name属性 比如get方法之类              2.父类定义的三个方法可以是抽象类 解决了子类命名不一致问题 子类执行也不一致              3.父类可以作为参数传入银行  //主函数     public static void main (String[] args){          Bank bank = new bank ();          Person p = new Oldman(长者); //父类作为参数          bank profession（p）;//银行欢迎长者来办理业务 调的是子类对象       }   //银行三个方法写成一个       public class Bank{       //开门  等待用户进来办理业务       public void profession（Person person）{       System.out，println（person.getName()+&quot;客户进入银行啦&quot;）       person.callNumber();       person.transact();       person.leave();       }//抽象类        public abstract class Person{       protected String name;       public String getName(){        return this.name;        }        //1.进银行叫号        public abstract void callNumaber();        //2.去窗口办理        public abstract void transact();        //3.办理完毕离开啦        public abstract void leave();       }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h1&gt;&lt;h2 id=&quot;策略者模式-Strategy-nbsp-———-行为型模式&quot;&gt;&lt;a href=&quot;#策略者模式-Strategy-n
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础  （十六）</title>
    <link href="http://yoursite.com/2020/03/22/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/22/JavaSE基础-（十六）/</id>
    <published>2020-03-22T13:14:51.000Z</published>
    <updated>2020-03-22T16:07:05.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式<br></h1><h2 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式 Adapter"></a>适配器模式 Adapter</h2><pre><code>定义一个规则-------&gt;和尚 吃斋 念经 打坐 撞钟 习武适配器鲁智深 鲁达 形态丑陋 面貌凶顽 方丈说 此人上应天星 心地刚直 虽时下凶顽 命中驳杂 久后却得清净 证果非凡 汝等不及他public abstract class AbstractBox implements Box{          public booolean add(element);          public void add(int index,int element){//具体化          }          public void addAll(){//具体化          }          public int get（index）;          public int remove（index）;          public int size();          }</code></pre><h2 id="Java面向对象的四大特性"><a href="#Java面向对象的四大特性" class="headerlink" title="Java面向对象的四大特性"></a>Java面向对象的四大特性</h2><pre><code>继承 封装 多态 （抽象）</code></pre><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><pre><code>同一个对象 体现出来的多种不同形态（身份）将一种行为表现出不同效果要想实现多态的效果 需要先有继承关系</code></pre><h3 id="体现"><a href="#体现" class="headerlink" title="体现"></a>体现<br></h3><pre><code>              1.父类类型的引用  指向  子类的对象                   Person p = new Teachher();              2.该引用只能调用父类定义的属性和方法              3.如果子类中将父类的方法重写,那么调取方法后执行的结果是子类重写之后的那个结果              如果父类与子类有同名的属性           执行父类的属性              如果父类与子类有同名的方法（重载）      执行子类重写之后的方法              4.若想要调用子类中独有的成员              （强制类型转换）造型 铸型 （向上/向下转型）//把父类引用向下转型              5.造型时（强制向下转型时）可能会出现一个运行时异常              ClassCastException   造型 铸型 异常              如果想要避免造型异常可以用instanceof关键字来进行判断// O instanceof Student 对象是否属于后面类型                                      Object                          hashCode equals toString getClass......                          Animal                     name属性 eat sleep               Person                                      Pig           name属性 重eat 重sleep 独talk             name属性  重sleep          Teacher                     Student                  name属性 重eat 独有teach       name属性 重talk 独study            Object o = new Teacher();//向上转型            o.hashCode() o.toString();            Animal a = (Animal)o;//向下转型            a.hashCode() a.toString a.name a.eat() a.sleep()            Person p = (Person)o;            p.hashCode();p.name p.eat p.sleep p.talk</code></pre><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><pre><code>1.InputMismatchException  输入不匹配2.NumberFormateException  数字格式化异常3.ArrayIndexOutBoundsException  数组索引越界4.NegativeArraySizeException  数组长度负数5.NullPointerException   空指针异常6.AirthmeticException    算数异常7.ClassCastException     造型异常</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;br&gt;&lt;/h1&gt;&lt;h2 id=&quot;适配器模式-Adapter&quot;&gt;&lt;a href=&quot;#适配器模式-Adapter&quot; class=&quot;header
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础  （十五）</title>
    <link href="http://yoursite.com/2020/03/21/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/21/JavaSE基础-（十五）/</id>
    <published>2020-03-21T15:25:31.000Z</published>
    <updated>2020-03-21T16:01:12.177Z</updated>
    
    <content type="html"><![CDATA[<p>abstract  抽象类</p><pre><code>         不具体 没有执行过程 只是一个概念1.可以修饰什么        修饰方法        用abstract修饰符修饰的方法 只有方法的构造  没有方法执行体叫抽象方法        当然注意native修饰的方法虽然没有方法体 但是不是抽象方法 只是执行的过程是其他语言写的 不属于抽象类        用abstract修饰符修饰的类 叫抽象类2.修饰后有什么特点                抽象类中必须要有抽象方法吗？ 不是必须含有抽象方法        抽象方法必须放在抽象类中？ 目前来看必须要放在抽象类中（或接口中）普通类是不许有抽象方法3.研究一下什么叫抽象类  抽象类有什么特点？        1.类里面有什么 成员                  属性    可以含有一般的属性  也可以含有 private static final 等                  方法    可以含有一般方法    也可以含有 private static final 等                           注意：抽象类中允许含有抽象方法（只有方法结构 没有方法执行体）                  块      可以含有一般程序块  也可以含有static程序块                  构造方法  可以含有一般方法，包括重载        2.类如何使用  创建对象                  抽象类含有构造方法 但我们不能通过调用构造方法创建对象                  抽象类只能通过子类单继承来做事        3.类和类的关系                  抽象类-----直接单继承---抽象类   可以                  抽象类-----直接单继承---具体类   可以                  具体类-----直接单继承---抽象类   不可以（）4.小问题        抽象类中能不能没有抽象方法 全都是具体成员  可以        抽象类能不能没有具体成员 全都是抽象方法 可以 ----&gt;抽象到极致---&gt;接口        接口可以理解为是抽象类抽象到极致-------&gt;还是一个类的结构 不能用class修饰 改用interface修饰</code></pre><p>interface 接口</p><pre><code>什么是接口？接口也是一个类的结构 只不过用interface修饰 替换原有的class1.有什么      成员              属性            不能含有一般属性 只能含有公有的静态常量 public static final              方法            不能含有一般的方法 只能含有公有的抽象方法（1.8以后default修饰具体方法）              块             不能含有一般程序块 也不能含有static块（块本身就是具体的 接口中不让有具体的）              构造方法         不能含有构造方法2.如何使用   创建对象         不能创建对象         只能通过子类多实现（implements）来做事         public class A implements B,C,D{         }3.与别的类结构关系         接口不能继承别的类   最抽象         抽象类--------直接多实现-------接口  可以         具体类--------直接多实现-------接口  不可以（不能直接将抽象方法具体化）         接口----------多继承-----------接口  可以直接多实现</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;abstract  抽象类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;         不具体 没有执行过程 只是一个概念
1.可以修饰什么
        修饰方法
        用abstract修饰符修饰的方法 只有方法的构造  没有方法执行体叫抽象方法
        当然注
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十四）</title>
    <link href="http://yoursite.com/2020/03/21/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/21/JavaSE基础-（十四）/</id>
    <published>2020-03-21T15:16:13.000Z</published>
    <updated>2020-03-21T16:01:03.420Z</updated>
    
    <content type="html"><![CDATA[<p>类的加载关系</p><pre><code>存在继承关系的类 加载机制 及执行过程加载类的过程-----静态元素已经加载new Person();1.加载父类2.父类会产生自己的静态空间 属性 方法 块            执行静态块3.加载子类4.子类会产生自己的静态空间 属性 方法 块            执行静态块5.开辟对象空间  6.加载父类的非静态成员  属性 方法 块 构造方法 7.执行块 执行父类的构造方法8.加载子类的非静态成员 属性 方法 块 构造方法9.执行块 执行子类的构造方法10.将对象空间的地址引用交给变量存储</code></pre><p>native 本地的</p><pre><code>Java源代码看到native就已经再也看不到后续代码后续会调用其他编程语言C++或C执行内存操作 帮我们操作Object类中的一个方法 hashCode</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;类的加载关系&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;存在继承关系的类 加载机制 及执行过程
加载类的过程-----静态元素已经加载
new Person();
1.加载父类
2.父类会产生自己的静态空间 属性 方法 块
            执行静态块
3.加载子类
4.子类会产
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十三）</title>
    <link href="http://yoursite.com/2020/03/21/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/21/JavaSE基础-（十三）/</id>
    <published>2020-03-21T14:43:20.000Z</published>
    <updated>2020-03-21T16:01:25.886Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式<br><br>  &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;  1.设计模式不是知识点<br><br>  &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;  2.设计模式是一种设计经验的总结<br><br>  &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br>  3.设计模式用来解决某些场景下的某一类问题的—-&gt;通用的解决方案<br><br>   &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 4.有了设计模式之后  可以让代码更容易被理解 确保了复用性 可靠性 可扩展性<br>  <br><br> 设计模式分为三类</p><pre><code>1.创新型模式（5种）--------&gt;用于解决创建对象的过程 单例模式  工厂方法模式  抽象模式 工作模式 建造者模式 原型模式2.结构型模式（7种）--------&gt;把类或对象通过某种形式结合在一起 构成某种复杂或合理的结构 适配器模式 装饰者模式 代理模式 外观模式 桥接模式 组合模式 享元模式3.行为行模式（11种）------&gt;用来解决类或对象之间的交互 更合理的优化类或对象之间的关系 观察者模式 策略模式 模板模式 责任链模式 解析器模式 迭代器模式 命令模式 状态模式 备忘录模式 访问者模式 中介者模式</code></pre><p> 单例模式</p><pre><code>设计------&gt;一个类只能创建一个对象 有效减小内存占用空间设计一个系统-----&gt;百度  搜索引擎 public class Baidu{           public void 搜索（String keyword）{           } }创建一个baidu对象 new调用搜索的方法 做事情 方法只执行一遍同一时间有很多很多很多的人在使用这个系统对象------&gt;只能创建一个 堆内存就开辟了一个空间调用一次方法-----&gt;临时执行一次 方法执行空间就回收了</code></pre><p>单例模式的实现</p><pre><code> 1.私有的构造方法 2.私有的静态的当前类作为属性 3.公有的静态的方法当返回值 饿汉式（立即加载） 对象启动时就加载啦           不会产生对象就没有拿来使用的问题 空指针异常           启动项目时的对象加载过多 有些还没有使用 产生服务器承载压力问题 懒汉式（延迟加载）对象什么时候用到了 才会加载           可能会由于没有操作好 导致异常（很严谨）           启动项目时候只有需要的加载 不需要的时候还没有创建 不会浪费空间*生命周期托管（单例对象别人帮我们处理）对象加载过程交给别人    private static SingleTon;               //直接=new SingleTon()饿汉式   public static SingleTon getSingleTon(){     if(single=null){     Single = new SingleTon();            //延迟加载方式  懒汉式     }     return single;  }public static void main(String[] args){    SingleTon s1 = Singleton.getSingleTon();    }}  </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设计模式&lt;br&gt;&lt;br&gt;  &amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;  1.设计模式不是知识点&lt;br&gt;&lt;br&gt;  &amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;n
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十二）</title>
    <link href="http://yoursite.com/2020/03/21/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/21/JavaSE基础-（十二）/</id>
    <published>2020-03-21T14:07:10.000Z</published>
    <updated>2020-03-21T14:42:38.934Z</updated>
    
    <content type="html"><![CDATA[<p>权限修饰符</p><pre><code>public       公共的        本类      同包    子类  当前类的任何位置只要有对象都可以使用protected    保护的        本类      同包    子类 （通过子类对象在子类内部访问）默认不写     默认的        本类     同包private      私有的1.能修饰什么  2.范围如何权限修饰符可以用来修饰   类本身   和类中的成员（除程序块）权限修饰符用来修饰类的时候只有两个可以用 （public 默认不写）权限修饰符可以用来修饰类中的其他成员</code></pre><p>Java类和类直接的关系</p><pre><code>继承  关联 多态（抽象）</code></pre><p>封装：将一些数据或执行过程  进行一个包装<br><br>目的：保护这些数据或执行过程的安全隐藏细节，增加复用性<br><br>对属性本身的封装：<br><br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     属性私有：（封装在类中）<br><br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 提供操作属性的公有方法<br>  <br><br>特征修饰符<br></p><pre><code>1.可以修饰什么2.修饰后什么特点</code></pre><p>  final    </p><pre><code>最终的   不可更改的  修饰变量           如果在定义时没有赋初始值         给变量一次存值的机会（因为变量在栈内存空间内 没有默认值 如果不给机会 就都没法用了         一旦变量存储了一个值若用final修饰后则不让改变----相当于常量         注意变量类型是基本类型还是引用类型         如果修饰的是基本数据类型 则变量内的值不让更改 常量         如果修饰的是引用数据类型 则变量内的地址不让更改对象唯一  修饰属性         全局变量 存储在堆内存的对象空间有一个空间         属性如果没有赋值  有默认值存在         属性用final修饰后 必须给属性赋初值 否则编译报错         特点与修饰变量一致         注意变量类型是基本类型还是引用类型         如果修饰的变量是基本数据类型 则变量内的值不让更改 ---常量         如果修饰的变量是引用数据类型 则变量内地址引用不让更改---对象唯一 修饰方法         方法是最终的方法 不可更改         子类继承父类的方法 可将父类的方法重写（覆盖）         final修饰的方法 要求不可以被子类重写（覆盖） 修饰类本身         类是最终的  不可更改         此类不可被其他字类继承         通常都是一些定义好的工具类         Math Scanner Intneger String</code></pre><p> static静态的</p><pre><code>1.可以修饰：修饰属性 修饰方法 *修饰块 修饰类（内部类）2.特点：     1.静态元素在类加载时就初始化了，创建的非常早，此时没有创建对象     2.静态元素存储在静态元素区中，每一个类都有一个自己的区域，与别的类不冲突     3.静态元素只加载一次（只有一份），全部类对象及类本身共享     4.由于静态元素区加载时候，可能没有创建对象，可以通过类的名字直接访问     5.静态元素区Garbage Collection 无法管理，可以粗暴认为常驻内存     6.可以理解静态元素不属于任何一个对象，是属于类的     7.非静态成员（堆内存对象里）中可以访问静态成员（静态区）     8.静态成员中可以访问静态成员（静态区）     9.静态成员不可以访问非静态成员     10.静态元素不可以出现this或super（静态元素属于类）</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;权限修饰符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public       公共的        本类      同包    子类  当前类的任何位置只要有对象都可以使用
protected    保护的        本类      同包    子类 （通过子类对象在子类内部访问
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十一）</title>
    <link href="http://yoursite.com/2020/03/20/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/20/JavaSE基础-（十一）/</id>
    <published>2020-03-20T15:16:57.000Z</published>
    <updated>2020-03-20T15:29:08.277Z</updated>
    
    <content type="html"><![CDATA[<p>包packge（可以理解为是一个文件夹）</p><pre><code>在我们类的第一行会出现package关键字如果package和import同时出现先写package后写importpackage只能有一个import可以有多个</code></pre><p>类的关系<br>    has-a</p><pre><code>包含关系（组合 聚合 关联） 语义从亲密程度来讲不太一样组合---&gt;人的大脑  人和心脏的关系     整体和部分的关系 不可分割 要出现整体出现 要消亡整体消亡整合----&gt;汽车和轮子 电脑和主板     整体和部分的关系 创建时可能是分开的关联----&gt;人有汽车 人有电脑     整体和部分的关系 可以分割后来形成一起从Java程序来描述这样的关系 通过一个类的对象当做另一个类的属性来存储</code></pre><p>ues a &nbsp;&nbsp;&nbsp;&nbsp;(need a ) 依赖关系</p><pre><code>屠夫 杀 猪           可以做一件事情 杀猪           需要一头猪不是整体和部分的关系 某一件事情产生关系临时组合在一起 这件事情一旦做完关系就解散通过在方法中引用另一个类的对象实现</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;包packge（可以理解为是一个文件夹）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在我们类的第一行会出现package关键字
如果package和import同时出现
先写package后写import
package只能有一个import可以有多个&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
</feed>
