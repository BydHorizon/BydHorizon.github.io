<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一轮明月照九洲</title>
  
  <subtitle>长将静趣观天地，自有幽怀契古今</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-22T15:58:56.288Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>我与我周旋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaSE基础 （十九）</title>
    <link href="http://yoursite.com/2020/03/22/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/22/JavaSE基础-（十九）/</id>
    <published>2020-03-22T15:29:06.000Z</published>
    <updated>2020-03-22T15:58:56.288Z</updated>
    
    <content type="html"><![CDATA[<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><pre><code>1.类所在的包2.类的关系 自己默认继承 实现3，类中提供常用方法4.是否可以创建对象 调用 方法本身是静态的包装类（封装类） 1.5版本之后自动拆包byte----Byte   short----Short   int------Integer  long-----Longfloat-----Float  double-----Double char-----Character boolean----Boolean1.八个包装类都在同一个包下  java.lang包  不需要import导包自己使用2.八个包装类有六个都是与数字有关  都默认继承父类Number3.八个包装类都实现了Serializable，Comparable4.八个包装类都带有自己对应类型参数的构造方法 八个包装类中有7个（除了Character）有构造方法重载 带String类型5.创建对象  对象调用方法     有六个与数字相关的类都继承Number   xxValue();将一个包装类类型转化为对应的基本类型（拆包）Interger i1 = new Interger（10）//引用数据类型 包装类 int value = i1.intValue(); int value  = Inter.parseInt(&quot;123&quot;)  Float.parseFloat(&quot;123.45&quot;) int value  = new Integer(&quot;123&quot;);</code></pre><h3 id="经常在笔试中出现的问题"><a href="#经常在笔试中出现的问题" class="headerlink" title="经常在笔试中出现的问题"></a>经常在笔试中出现的问题</h3><pre><code>       integer i1 = 10;       integer i2 = 10;       integer i3 = new Integer(10);       integer i4 = new Integer(10);       System.out.println(i1==i2);//true       System.out.println(i1==i3);//false       System.out,println(i3==i4);//false       System.out.pritnln(i1.equals(i2));//true       System.out.pritnln(i1.equals(i3));//true       System.out.pritnln(i1.equals(i4));//true 1.==与equals()的区别  ==可以比较基本数据类型 也可以比较引用数据类型（变量中存储的内容）  如果比较基本类型比较的是变量中存储的值  如果比较的是引用类型比较的是变量中存储地址的引用  equals()是Object类中继承过来的方法==一致 如果想要改变比较规则 可以重写equals方法  由于integer类就重写了equals()所以Integer比较的是数值2.考察Integer类加载的时候有一个静态空间  空间内立即加载Integer类型的数组 内存储256个Integer对象 -128-127  如果我们用的对象范围在这之内 integer i1 = 10;直接取静态元素区中找对应的对象  如果我们用的对象范围超出了Integer i1 = 1000; 会帮我们创建一个新的Integer对象</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;包装类&quot;&gt;&lt;a href=&quot;#包装类&quot; class=&quot;headerlink&quot; title=&quot;包装类&quot;&gt;&lt;/a&gt;包装类&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1.类所在的包
2.类的关系 自己默认继承 实现
3，类中提供常用方法
4.是否可以创建对象 调用 方法本身是静态的
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十八）</title>
    <link href="http://yoursite.com/2020/03/22/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89-1/"/>
    <id>http://yoursite.com/2020/03/22/JavaSE基础-（十八）-1/</id>
    <published>2020-03-22T15:28:17.000Z</published>
    <updated>2020-03-22T15:58:30.992Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>1.成员内部类</p><pre><code>将一个类直接定义在类的里面，作为成员，与属性或方法层次一次成员内部类可以与正常类一样 使用不同的修饰符去修饰好处1.省略了一个.java文件 好处2.成员内部类可以访问外部类的所有成员 包括私有的若想要在内部类中通过对象.调用外部类成员  外部类.this.外部类成员内部类存在后 源代码进行编译 产生一个字节码 Demo$InnerDemo.class</code></pre><p>2.局部内部类</p><pre><code>将一个类定义在方法/块里面,作为成员的内部结构，与临时的局部变量一个层次局部内部类像是一个局部变量一样，不能用public protected privtae及staic只能用abstract或final局部内部类命名规则Demo$InnerTestMethod局部内部类使用的变量只能用final修饰</code></pre><p>3.匿名内部类<br><br>        成员匿名内部类<br><br>        局部匿名内部类</p><pre><code>public interface Test{          public void test();} Test t = new Test{          public void test(){          }} ;通常接口或抽象类的具体子类这样写开发中为了省略一个类文件 上诉写法比较常见匿名内部类很特殊 只有类体 没有类的所有结构（修饰符 名字 继承 实现）      不能用任何修饰符来修饰 匿名内部类也没有任何构造方法</code></pre><p>4.静态内部类</p><pre><code>成员静态内部类不需要外部类对象，通过正常的方式直接创建内部类静态元素不能访问非静态成员（自己类和外部类）</code></pre><h2 id="枚举类enum"><a href="#枚举类enum" class="headerlink" title="枚举类enum"></a>枚举类enum</h2><h4 id="一个类中的对象-认为个数有限且固定的，可以将每一个对象一一列举出来"><a href="#一个类中的对象-认为个数有限且固定的，可以将每一个对象一一列举出来" class="headerlink" title="一个类中的对象 认为个数有限且固定的，可以将每一个对象一一列举出来"></a>一个类中的对象 认为个数有限且固定的，可以将每一个对象一一列举出来</h4><pre><code> 1.试一试若没有枚举类型的时候如何动手设计（静态常量 单例模式）Day（类 当做描述星期七个对象）      private 构造方法      public static final 属性 = new      //构造方法私有        private Day(){}      //所有对象都是属性      public static final Day monday = new Day(); 2.JDK1.5版本后可以直接定义enmu类型      我们自己定义的enmu类型直接默认继承enmu（java.lang包）      我们自己定义的enmu类型不能再写extrends但是可以实现      Enum类型             有两个属性             name-------&gt;枚举对象的名字   name()获取name的属性             ordinal------&gt;枚举对象在罗列中的顺序  类似index 也从0开始 ordinal获取序列号             常用的方法             valueof()  通过给定的name获取对应的枚举对象             values()   获取全部的枚举对象----&gt;返回一个数组 Day[]             compaerTo() 可以比较两个枚举对象 int             toString()  由于这个方法没有final修饰 可以覆盖（重写）3.我们也可以在enum中描述自己的一些属性或方法      必须在enum类中第一行 描述一下枚举的样子 最后需要分号结束;      可以定义自己的属性      类创建过程中 帮我们创建枚举类型的对象      需要给枚举型提供对应样子的构造方法 方法只能private修饰 可以重载</code></pre><h3 id="内存机制问题"><a href="#内存机制问题" class="headerlink" title="内存机制问题"></a>内存机制问题</h3><pre><code>栈内存-----&gt;Person p = new Person();-----&gt;堆内存   方法区----类模板栈内存-----&gt;创建开始  用完立即回收   StackoverflowError方法区-----&gt;类 常量 静态 只有一份回收不了堆内存-----&gt;new创建的对象 Garbage Collection 垃圾回收器Runtime类之中提供了几个管理内存的方法        maxMemory        totalMemory        freeMemory        堆内存溢出错误OutOfMemoryErrorObject类中有一个finalize方法 如果重写也能看见对象回收GC系统提供的一个线程  回收算法</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;内部类&quot;&gt;&lt;a href=&quot;#内部类&quot; class=&quot;headerlink&quot; title=&quot;内部类&quot;&gt;&lt;/a&gt;内部类&lt;/h3&gt;&lt;p&gt;1.成员内部类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;将一个类直接定义在类的里面，作为成员，与属性或方法层次一次
成员内部类可以与正常类一样
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十七）</title>
    <link href="http://yoursite.com/2020/03/22/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/22/JavaSE基础-（十七）/</id>
    <published>2020-03-22T13:57:03.000Z</published>
    <updated>2020-03-22T15:58:10.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="策略者模式-Strategy-nbsp-———-行为型模式"><a href="#策略者模式-Strategy-nbsp-———-行为型模式" class="headerlink" title="策略者模式 Strategy &nbsp; ——— 行为型模式"></a>策略者模式 Strategy &nbsp; ——— 行为型模式</h2><h4 id="用来解决-执行流程固定-执行结果由于提供不同策略而不同"><a href="#用来解决-执行流程固定-执行结果由于提供不同策略而不同" class="headerlink" title="用来解决  执行流程固定 执行结果由于提供不同策略而不同"></a>用来解决  执行流程固定 执行结果由于提供不同策略而不同</h4><pre><code>              银行类                  profession（人）{  人----抽象类 接口（不能产生对象） 传递一个子类对象                  欢迎用户进来                  叫号                  办理                  离开                  欢迎您下次再来                  }             长者   年轻人  vip            //按普通设计  可能有问题              1.三个不同的人类方法名不一致（可以）              2.银行办理业务的方法写了3个            //解决上诉所述问题可以在三个人之上创建一个父类              1.解决桑个人类中相同代码 比如name属性 比如get方法之类              2.父类定义的三个方法可以是抽象类 解决了子类命名不一致问题 子类执行也不一致              3.父类可以作为参数传入银行  //主函数     public static void main (String[] args){          Bank bank = new bank ();          Person p = new Oldman(长者); //父类作为参数          bank profession（p）;//银行欢迎长者来办理业务 调的是子类对象       }   //银行三个方法写成一个       public class Bank{       //开门  等待用户进来办理业务       public void profession（Person person）{       System.out，println（person.getName()+&quot;客户进入银行啦&quot;）       person.callNumber();       person.transact();       person.leave();       }//抽象类        public abstract class Person{       protected String name;       public String getName(){        return this.name;        }        //1.进银行叫号        public abstract void callNumaber();        //2.去窗口办理        public abstract void transact();        //3.办理完毕离开啦        public abstract void leave();       }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h1&gt;&lt;h2 id=&quot;策略者模式-Strategy-nbsp-———-行为型模式&quot;&gt;&lt;a href=&quot;#策略者模式-Strategy-n
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础  （十六）</title>
    <link href="http://yoursite.com/2020/03/22/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/22/JavaSE基础-（十六）/</id>
    <published>2020-03-22T13:14:51.000Z</published>
    <updated>2020-03-22T15:57:57.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式<br></h1><h2 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式 Adapter"></a>适配器模式 Adapter</h2><pre><code>定义一个规则-------&gt;和尚 吃斋 念经 打坐 撞钟 习武适配器鲁智深 鲁达 形态丑陋 面貌凶顽 方丈说 此人上应天星 心地刚直 虽时下凶顽 命中驳杂 久后却得清净 证果非凡 汝等不及他public abstract class AbstractBox implements Box{          public booolean add(element);          public void add(int index,int element){//具体化          }          public void addAll(){//具体化          }          public int get（index）;          public int remove（index）;          public int size();          }</code></pre><h2 id="Java面向对象的四大特性"><a href="#Java面向对象的四大特性" class="headerlink" title="Java面向对象的四大特性"></a>Java面向对象的四大特性</h2><pre><code>&lt;br&gt;    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;继承 封装 多态 （抽象）&lt;br&gt;多态&lt;br&gt;同一个对象 体现出来的多种不同形态（身份）将一种行为表现出不同效果要想实现多态的效果 需要先有继承关系&lt;BR&gt;</code></pre><h3 id="体现"><a href="#体现" class="headerlink" title="体现"></a>体现<br></h3><pre><code>              1.父类类型的引用  指向  子类的对象                   Person p = new Teachher();              2.该引用只能调用父类定义的属性和方法              3.如果子类中将父类的方法重写,那么调取方法后执行的结果是子类重写之后的那个结果              如果父类与子类有同名的属性           执行父类的属性              如果父类与子类有同名的方法（重载）      执行子类重写之后的方法              4.若想要调用子类中独有的成员              （强制类型转换）造型 铸型 （向上/向下转型）//把父类引用向下转型              5.造型时（强制向下转型时）可能会出现一个运行时异常              ClassCastException   造型 铸型 异常              如果想要避免造型异常可以用instanceof关键字来进行判断// O instanceof Student 对象是否属于后面类型                                      Object                          hashCode equals toString getClass......                          Animal                     name属性 eat sleep               Person                                      Pig           name属性 重eat 重sleep 独talk             name属性  重sleep          Teacher                     Student                  name属性 重eat 独有teach       name属性 重talk 独study            Object o = new Teacher();//向上转型            o.hashCode() o.toString();            Animal a = (Animal)o;//向下转型            a.hashCode() a.toString a.name a.eat() a.sleep()            Person p = (Person)o;            p.hashCode();p.name p.eat p.sleep p.talk</code></pre><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><pre><code>1.InputMismatchException  输入不匹配2.NumberFormateException  数字格式化异常3.ArrayIndexOutBoundsException  数组索引越界4.NegativeArraySizeException  数组长度负数5.NullPointerException   空指针异常6.AirthmeticException    算数异常7.ClassCastException     造型异常</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;br&gt;&lt;/h1&gt;&lt;h2 id=&quot;适配器模式-Adapter&quot;&gt;&lt;a href=&quot;#适配器模式-Adapter&quot; class=&quot;header
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础  （十五）</title>
    <link href="http://yoursite.com/2020/03/21/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/21/JavaSE基础-（十五）/</id>
    <published>2020-03-21T15:25:31.000Z</published>
    <updated>2020-03-21T16:01:12.177Z</updated>
    
    <content type="html"><![CDATA[<p>abstract  抽象类</p><pre><code>         不具体 没有执行过程 只是一个概念1.可以修饰什么        修饰方法        用abstract修饰符修饰的方法 只有方法的构造  没有方法执行体叫抽象方法        当然注意native修饰的方法虽然没有方法体 但是不是抽象方法 只是执行的过程是其他语言写的 不属于抽象类        用abstract修饰符修饰的类 叫抽象类2.修饰后有什么特点                抽象类中必须要有抽象方法吗？ 不是必须含有抽象方法        抽象方法必须放在抽象类中？ 目前来看必须要放在抽象类中（或接口中）普通类是不许有抽象方法3.研究一下什么叫抽象类  抽象类有什么特点？        1.类里面有什么 成员                  属性    可以含有一般的属性  也可以含有 private static final 等                  方法    可以含有一般方法    也可以含有 private static final 等                           注意：抽象类中允许含有抽象方法（只有方法结构 没有方法执行体）                  块      可以含有一般程序块  也可以含有static程序块                  构造方法  可以含有一般方法，包括重载        2.类如何使用  创建对象                  抽象类含有构造方法 但我们不能通过调用构造方法创建对象                  抽象类只能通过子类单继承来做事        3.类和类的关系                  抽象类-----直接单继承---抽象类   可以                  抽象类-----直接单继承---具体类   可以                  具体类-----直接单继承---抽象类   不可以（）4.小问题        抽象类中能不能没有抽象方法 全都是具体成员  可以        抽象类能不能没有具体成员 全都是抽象方法 可以 ----&gt;抽象到极致---&gt;接口        接口可以理解为是抽象类抽象到极致-------&gt;还是一个类的结构 不能用class修饰 改用interface修饰</code></pre><p>interface 接口</p><pre><code>什么是接口？接口也是一个类的结构 只不过用interface修饰 替换原有的class1.有什么      成员              属性            不能含有一般属性 只能含有公有的静态常量 public static final              方法            不能含有一般的方法 只能含有公有的抽象方法（1.8以后default修饰具体方法）              块             不能含有一般程序块 也不能含有static块（块本身就是具体的 接口中不让有具体的）              构造方法         不能含有构造方法2.如何使用   创建对象         不能创建对象         只能通过子类多实现（implements）来做事         public class A implements B,C,D{         }3.与别的类结构关系         接口不能继承别的类   最抽象         抽象类--------直接多实现-------接口  可以         具体类--------直接多实现-------接口  不可以（不能直接将抽象方法具体化）         接口----------多继承-----------接口  可以直接多实现</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;abstract  抽象类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;         不具体 没有执行过程 只是一个概念
1.可以修饰什么
        修饰方法
        用abstract修饰符修饰的方法 只有方法的构造  没有方法执行体叫抽象方法
        当然注
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十四）</title>
    <link href="http://yoursite.com/2020/03/21/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/21/JavaSE基础-（十四）/</id>
    <published>2020-03-21T15:16:13.000Z</published>
    <updated>2020-03-21T16:01:03.420Z</updated>
    
    <content type="html"><![CDATA[<p>类的加载关系</p><pre><code>存在继承关系的类 加载机制 及执行过程加载类的过程-----静态元素已经加载new Person();1.加载父类2.父类会产生自己的静态空间 属性 方法 块            执行静态块3.加载子类4.子类会产生自己的静态空间 属性 方法 块            执行静态块5.开辟对象空间  6.加载父类的非静态成员  属性 方法 块 构造方法 7.执行块 执行父类的构造方法8.加载子类的非静态成员 属性 方法 块 构造方法9.执行块 执行子类的构造方法10.将对象空间的地址引用交给变量存储</code></pre><p>native 本地的</p><pre><code>Java源代码看到native就已经再也看不到后续代码后续会调用其他编程语言C++或C执行内存操作 帮我们操作Object类中的一个方法 hashCode</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;类的加载关系&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;存在继承关系的类 加载机制 及执行过程
加载类的过程-----静态元素已经加载
new Person();
1.加载父类
2.父类会产生自己的静态空间 属性 方法 块
            执行静态块
3.加载子类
4.子类会产
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十三）</title>
    <link href="http://yoursite.com/2020/03/21/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/21/JavaSE基础-（十三）/</id>
    <published>2020-03-21T14:43:20.000Z</published>
    <updated>2020-03-21T16:01:25.886Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式<br><br>  &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;  1.设计模式不是知识点<br><br>  &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;  2.设计模式是一种设计经验的总结<br><br>  &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br>  3.设计模式用来解决某些场景下的某一类问题的—-&gt;通用的解决方案<br><br>   &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 4.有了设计模式之后  可以让代码更容易被理解 确保了复用性 可靠性 可扩展性<br>  <br><br> 设计模式分为三类</p><pre><code>1.创新型模式（5种）--------&gt;用于解决创建对象的过程 单例模式  工厂方法模式  抽象模式 工作模式 建造者模式 原型模式2.结构型模式（7种）--------&gt;把类或对象通过某种形式结合在一起 构成某种复杂或合理的结构 适配器模式 装饰者模式 代理模式 外观模式 桥接模式 组合模式 享元模式3.行为行模式（11种）------&gt;用来解决类或对象之间的交互 更合理的优化类或对象之间的关系 观察者模式 策略模式 模板模式 责任链模式 解析器模式 迭代器模式 命令模式 状态模式 备忘录模式 访问者模式 中介者模式</code></pre><p> 单例模式</p><pre><code>设计------&gt;一个类只能创建一个对象 有效减小内存占用空间设计一个系统-----&gt;百度  搜索引擎 public class Baidu{           public void 搜索（String keyword）{           } }创建一个baidu对象 new调用搜索的方法 做事情 方法只执行一遍同一时间有很多很多很多的人在使用这个系统对象------&gt;只能创建一个 堆内存就开辟了一个空间调用一次方法-----&gt;临时执行一次 方法执行空间就回收了</code></pre><p>单例模式的实现</p><pre><code> 1.私有的构造方法 2.私有的静态的当前类作为属性 3.公有的静态的方法当返回值 饿汉式（立即加载） 对象启动时就加载啦           不会产生对象就没有拿来使用的问题 空指针异常           启动项目时的对象加载过多 有些还没有使用 产生服务器承载压力问题 懒汉式（延迟加载）对象什么时候用到了 才会加载           可能会由于没有操作好 导致异常（很严谨）           启动项目时候只有需要的加载 不需要的时候还没有创建 不会浪费空间*生命周期托管（单例对象别人帮我们处理）对象加载过程交给别人    private static SingleTon;               //直接=new SingleTon()饿汉式   public static SingleTon getSingleTon(){     if(single=null){     Single = new SingleTon();            //延迟加载方式  懒汉式     }     return single;  }public static void main(String[] args){    SingleTon s1 = Singleton.getSingleTon();    }}  </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设计模式&lt;br&gt;&lt;br&gt;  &amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;  1.设计模式不是知识点&lt;br&gt;&lt;br&gt;  &amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;n
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十二）</title>
    <link href="http://yoursite.com/2020/03/21/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/21/JavaSE基础-（十二）/</id>
    <published>2020-03-21T14:07:10.000Z</published>
    <updated>2020-03-21T14:42:38.934Z</updated>
    
    <content type="html"><![CDATA[<p>权限修饰符</p><pre><code>public       公共的        本类      同包    子类  当前类的任何位置只要有对象都可以使用protected    保护的        本类      同包    子类 （通过子类对象在子类内部访问）默认不写     默认的        本类     同包private      私有的1.能修饰什么  2.范围如何权限修饰符可以用来修饰   类本身   和类中的成员（除程序块）权限修饰符用来修饰类的时候只有两个可以用 （public 默认不写）权限修饰符可以用来修饰类中的其他成员</code></pre><p>Java类和类直接的关系</p><pre><code>继承  关联 多态（抽象）</code></pre><p>封装：将一些数据或执行过程  进行一个包装<br><br>目的：保护这些数据或执行过程的安全隐藏细节，增加复用性<br><br>对属性本身的封装：<br><br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     属性私有：（封装在类中）<br><br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 提供操作属性的公有方法<br>  <br><br>特征修饰符<br></p><pre><code>1.可以修饰什么2.修饰后什么特点</code></pre><p>  final    </p><pre><code>最终的   不可更改的  修饰变量           如果在定义时没有赋初始值         给变量一次存值的机会（因为变量在栈内存空间内 没有默认值 如果不给机会 就都没法用了         一旦变量存储了一个值若用final修饰后则不让改变----相当于常量         注意变量类型是基本类型还是引用类型         如果修饰的是基本数据类型 则变量内的值不让更改 常量         如果修饰的是引用数据类型 则变量内的地址不让更改对象唯一  修饰属性         全局变量 存储在堆内存的对象空间有一个空间         属性如果没有赋值  有默认值存在         属性用final修饰后 必须给属性赋初值 否则编译报错         特点与修饰变量一致         注意变量类型是基本类型还是引用类型         如果修饰的变量是基本数据类型 则变量内的值不让更改 ---常量         如果修饰的变量是引用数据类型 则变量内地址引用不让更改---对象唯一 修饰方法         方法是最终的方法 不可更改         子类继承父类的方法 可将父类的方法重写（覆盖）         final修饰的方法 要求不可以被子类重写（覆盖） 修饰类本身         类是最终的  不可更改         此类不可被其他字类继承         通常都是一些定义好的工具类         Math Scanner Intneger String</code></pre><p> static静态的</p><pre><code>1.可以修饰：修饰属性 修饰方法 *修饰块 修饰类（内部类）2.特点：     1.静态元素在类加载时就初始化了，创建的非常早，此时没有创建对象     2.静态元素存储在静态元素区中，每一个类都有一个自己的区域，与别的类不冲突     3.静态元素只加载一次（只有一份），全部类对象及类本身共享     4.由于静态元素区加载时候，可能没有创建对象，可以通过类的名字直接访问     5.静态元素区Garbage Collection 无法管理，可以粗暴认为常驻内存     6.可以理解静态元素不属于任何一个对象，是属于类的     7.非静态成员（堆内存对象里）中可以访问静态成员（静态区）     8.静态成员中可以访问静态成员（静态区）     9.静态成员不可以访问非静态成员     10.静态元素不可以出现this或super（静态元素属于类）</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;权限修饰符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public       公共的        本类      同包    子类  当前类的任何位置只要有对象都可以使用
protected    保护的        本类      同包    子类 （通过子类对象在子类内部访问
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十一）</title>
    <link href="http://yoursite.com/2020/03/20/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/20/JavaSE基础-（十一）/</id>
    <published>2020-03-20T15:16:57.000Z</published>
    <updated>2020-03-20T15:29:08.277Z</updated>
    
    <content type="html"><![CDATA[<p>包packge（可以理解为是一个文件夹）</p><pre><code>在我们类的第一行会出现package关键字如果package和import同时出现先写package后写importpackage只能有一个import可以有多个</code></pre><p>类的关系<br>    has-a</p><pre><code>包含关系（组合 聚合 关联） 语义从亲密程度来讲不太一样组合---&gt;人的大脑  人和心脏的关系     整体和部分的关系 不可分割 要出现整体出现 要消亡整体消亡整合----&gt;汽车和轮子 电脑和主板     整体和部分的关系 创建时可能是分开的关联----&gt;人有汽车 人有电脑     整体和部分的关系 可以分割后来形成一起从Java程序来描述这样的关系 通过一个类的对象当做另一个类的属性来存储</code></pre><p>ues a &nbsp;&nbsp;&nbsp;&nbsp;(need a ) 依赖关系</p><pre><code>屠夫 杀 猪           可以做一件事情 杀猪           需要一头猪不是整体和部分的关系 某一件事情产生关系临时组合在一起 这件事情一旦做完关系就解散通过在方法中引用另一个类的对象实现</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;包packge（可以理解为是一个文件夹）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在我们类的第一行会出现package关键字
如果package和import同时出现
先写package后写import
package只能有一个import可以有多个&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>html-css-js  （二）</title>
    <link href="http://yoursite.com/2020/03/20/html-css-js-%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/20/html-css-js-（二）/</id>
    <published>2020-03-20T14:19:19.000Z</published>
    <updated>2020-03-20T15:15:27.772Z</updated>
    
    <content type="html"><![CDATA[<p>高级标签 </p><pre><code>空格标签     &amp;nbsp;左尖括号     &amp;lt;   less than右尖括号     &amp;gt;   great than换行        &lt;br&gt;划线        &lt;hr&gt;</code></pre><p>   有序列表   </p><pre><code>  &lt;ol&gt;       &lt;li&gt;苹果&lt;/li&gt;     &lt;li&gt;香蕉&lt;/li&gt;     &lt;li&gt;菠萝&lt;/li&gt;   &lt;/ol&gt;  有序表属性  &lt;ol type =&quot;a&quot;(a,A,1,i,I)  reversed = &quot;reversed&quot;  start = &quot;3&quot;&gt;  //排序可以按a，A，1,罗马小写i，罗马大写 i reversed属性表示倒序 start表示起始顺序                </code></pre><p>   *无序表 </p><pre><code>&lt;ul&gt;   &lt;li&gt;Marvel&lt;/li&gt;   &lt;li&gt;返老还童&lt;/li&gt;   &lt;li&gt;了不起的盖茨比&lt;/li&gt; &lt;/ul&gt;&lt;ul type = &quot;disc&quot; (square circle)&gt;//标签是实心圆 实心方块 空心圆</code></pre><p>   超文本链接 </p><pre><code>&lt;a herf &quot; &quot; &gt;www.baidu.com&lt;/a&gt; //hyperText reference   数字 文字 图片均可以跳转 target在当前页面打开 blank打开新页面  &lt;打电话&gt;  &lt;a herf=&quot;tel:&quot;&gt;  &lt;发邮件&gt;  &lt;a herf=&quot;mailto&quot;&gt;  &lt;协议限定符&gt;  //&lt;a herf=&quot;javascript=while(1）{alert（&quot;让你手欠&quot;）} 你点我试试呀！come on 来呀！&lt;/a&gt;</code></pre><p> 图片标签   </p><pre><code>    &lt;img src=&quot;url&quot;&gt;//可以打开网络url；本地绝对路径；本地相对路径 alt属性图片占位符（图片出错时显示信息）     title属性图片提示符（光标移动到图片显示） </code></pre><p>锚点                   </p><pre><code>anhor（实现置顶）记录位置 </code></pre><p>表单                     </p><pre><code>&lt;form method=&quot;get/post&quot; action=&quot;&quot;&gt;&lt;input type=&quot;text&quot;  name=&quot;username&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;login&quot;&gt;&lt;/form&gt;// 发送数据 需要数据名和数据内容两项  提交检验 pro/Desktop/lesson2.html?username=sunny&amp;password=123123.  md5协议进行加密         123123                     加密后&amp;@#￥&amp;￥&lt;input type =&quot;radio&quot;&gt;单选                     </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;高级标签 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;空格标签     &amp;amp;nbsp;
左尖括号     &amp;amp;lt;   less than
右尖括号     &amp;amp;gt;   great than
换行        &amp;lt;br&amp;gt;
划线        &amp;lt;
      
    
    </summary>
    
      <category term="前端基础" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （十）</title>
    <link href="http://yoursite.com/2020/03/19/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%8D%81%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/19/JavaSE基础-（十）/</id>
    <published>2020-03-19T15:03:29.000Z</published>
    <updated>2020-03-19T15:58:48.949Z</updated>
    
    <content type="html"><![CDATA[<p>类和类之间的关系</p><p>A is a B 泛化 （继承 实现）</p><p>A has a B 包含 （组合 聚合 关联）</p><p>A use a B 依赖 （依赖）need a </p><p>继承</p><pre><code>1.子类继承父类，通过一个关键字 extends2.子类的对象可以调用父类中的（public protected）属性和方法3.子类可以添加自己的属性和方法4.子类从父类继承过来的方法不能满足子类的需要，可以在子类中重写父类的方法 指内容重写5.每一个类都有一个继承类，如果extrends关键字不写，默认继承Object类6.java中继承是单个存在的（单继承）每一个类都只能有一个继承类（在extrends后面写一个类）目的是让类变得更安全，可以通过传递方式实现多继承的效果，后续还有多实现7.继承在内存中的存储形式8.关于this和super的使用</code></pre><p>   方法重写与重载</p><pre><code>   方法重写override                                 方法重载overload1.   产生两个继承关系的类                          一个类中的一组方法     子类可以写父类的方法2.特征符            final static abstract                          没有要求          父类方法是 final  子类不能重写      父类方法是 static 子类不存在      父类方法是 abstract 子类必须重写3.权限修饰符         子类可以大于等于父类                             没有要求4.返回值          子类可以小于等于父类                             没有要求5.参数             子类父类必须一致                          每一个方法参数必须不一致6.名字            子类父类必须一致                          一个类中的方法名必须一致7.异常                 运行时 编译时    如果父类方法抛出运行时异常：                         没有要求    子类可不予理会    如果父类方法抛出编译时异常：    子类抛出异常的个数和类型都少于等于父类8.方法体   子类方法内容和父类不一致              每个重载方法执行过程不一致</code></pre><p> Object类       </p><pre><code>        Object类是所有类的父类 Object类没有父类        Object方法         1.toString方法 打印输出一个对象变成字符串        public String toString() {    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());}        2.hashcode（）将对象的地址在内存中计算得到一个整数        3.equals（）用来比较两个对象的内容         == 和equals的区别         equals方法是Object类中继承的方法 默认比较地址         ==可以比较基本类型比较（值）也可以用来比较引用类型比较（地址）         如果想要改变规则可以方法重写          public boolean equals(Object obj) {    return (this == obj);}        4.getclass（）   获取对应类的映射        5.wait（）      线程进入挂起等待状态        6.notify（）     唤醒线程        7.notifyAll（）   唤醒所有        8.finalize      权限修饰符 protected在对象被GC回收时默认执行方法 相当于C++析构函数        9.clone（）     权限修饰符 protected为了克隆对象</code></pre><p> this和super的使用  </p><pre><code>1.this和super都是指代词 代替的是对象2.this代替的是当前执行方法时的那个对象 不一定是当前类的  super代替的是当前执行方法时父类的那个对象 空间内部那个3.都能调用一般属性和方法4.可以放在类成员的任一位置（属性，方法，构造，块）5.注意调用一般方法的时候来回调用（写法编译好用）执行可能产生问题 （stack overflow error）6.可调用构造方法（放在构造方法的第一行）7.this和super在构造方法中调用另一个类的构造方法不能出现在第一行8.构造方法之间不能用来互相调用（编译不好用）</code></pre><p>  <img src="/2020/03/19/JavaSE基础-（十）/%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;类和类之间的关系&lt;/p&gt;
&lt;p&gt;A is a B 泛化 （继承 实现）&lt;/p&gt;
&lt;p&gt;A has a B 包含 （组合 聚合 关联）&lt;/p&gt;
&lt;p&gt;A use a B 依赖 （依赖）need a &lt;/p&gt;
&lt;p&gt;继承&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.子类继承父类，通过一个
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>html-css-js  （一）</title>
    <link href="http://yoursite.com/2020/03/19/html-css-js-%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/19/html-css-js-（一）/</id>
    <published>2020-03-19T14:38:00.000Z</published>
    <updated>2020-03-19T15:02:14.840Z</updated>
    
    <content type="html"><![CDATA[<p>HTML 基础标签</p><p>html  （hyper text markup language） 超文本标记语言</p><pre><code>&lt;html lang = &quot;en&quot;&gt;&lt;head&gt;     &lt;meta charset = &quot;utf-8&quot;&gt;     &lt;title&gt; hello！new friend！&lt;/title&gt;&lt;/head&gt;&lt; body&gt;      Life is full of hope!      生活充满希望！&lt;/body&gt;&lt;/html&gt;</code></pre><p>  基础标签</p><pre><code>根标签 &lt;html&gt; &lt;/html&gt;头标签 &lt;head&gt; &lt;/head&gt;   浏览器设置内容标签 &lt;body&gt; &lt;/body&gt;  用户可见属性标签 &lt;meta&gt;       可对关键字赋值标题标签 &lt;title&gt; &lt;/title&gt; 设置浏览器角标段落标签 &lt;p&gt; &lt;/p&gt;字号标签 &lt;h1-6&gt; &lt;h1-6&gt;   由大到小加粗标签 &lt;strong&gt; &lt;/strong&gt;斜体标签 &lt;em&gt; &lt;/em&gt;     斜体中划线标签 &lt;dek&gt; &lt;/del&gt;地址标签 &lt;adress&gt; &lt;/adress&gt;容器标签 &lt;div&gt; &lt;/div&gt;    换行 结构化 分块明确 捆绑操作         &lt;span&gt;&lt;sapn&gt;</code></pre><p> 字符集</p><pre><code>gb2312    只收录简体gbk      包含繁体unicod    万国码utf -8    Unicode transformation format 第八版lang = &quot;en&quot; en表示英语 中文 zh</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HTML 基础标签&lt;/p&gt;
&lt;p&gt;html  （hyper text markup language） 超文本标记语言&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;html lang = &amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
     &amp;lt;meta 
      
    
    </summary>
    
      <category term="前端基础" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （九）</title>
    <link href="http://yoursite.com/2020/03/15/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/15/JavaSE基础-（九）/</id>
    <published>2020-03-15T14:04:33.000Z</published>
    <updated>2020-03-15T14:57:18.907Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象的编程思想"><a href="#面向对象的编程思想" class="headerlink" title="面向对象的编程思想"></a>面向对象的编程思想</h3><p>类——–抽象的  属性（特征）和方法（行为）</p><p>对象—–具体的</p><p>1.描述一个类</p><pre><code>属性权限修饰符  {特征修饰符}  数据类型  属性名字  {=值}方法权限修饰符  {特征修饰符}  返回值类型 方法名字（参数列表）  {抛出异常} {{方法体}}；</code></pre><p>2.创建一个对象          </p><pre><code>new  对象     调用属性   存值/取值对象.方法  调用方法   执行一次  （存储 执行）</code></pre><p>3.类的加载</p><pre><code>对象的创建属性及方法的存储方法的执行方法执行的过程中  参数返回值的传递{基本数据类型  引用数据类型的区别}</code></pre><p>4.方法的重载 overloard</p><pre><code>1.概念：一个类中的一个一组方法  相同的方法名字 不同的参数列表  构成了方法的重载参数的不同体现在  参数的个数 参数的类型 参数的顺序 三个方面2.作用为了便于记忆和调用 使得方法调用的时候更加的灵活3.自己也可以设计方法的重载  调用的时候 先通过方法的名字来定位  名字一致 通过参数列表的数据类型来定位  方法返回值  修饰符 ---- 与方法重载无关4.JDK1.5之后的  新写法 动态参数列表 ...   参数类型固定  参数的个数可以动态  0-n  使用起来类似于数组的使用 length index  int...x    int[][] x  动态参数列表的方法   对应匹配的数组类型的方法不能构成重载（本质上是一样的）  动态参数列表在方法的参数中只能存一份  且放置在参数的末尾 </code></pre><p>5.构造方法 —–做事情</p><pre><code>1.作用：只有一个  构建（构造）当前类的对象2.写法：   权限修饰符  与类名一致的方法名 （参数列表）{抛出异常}{方法体}3.用法  通过new关键字调用4.特点：      （1）每个类都有构造方法：若自己的类中没有定义系统会默认提供一个无参的构造方法，若在类中定义了构造方法，则默认无参的狗造方法被覆盖      （2）构造方法存值方法重载5.每个类都提供一个构造方法  在创建对象的时候想做一些事情可以用构造方法</code></pre><p>6.程序块  （代码块） </p><pre><code>1.作用：跟普通方法一样 做事情的2.写法：可以认为程序块是一个 没有修饰符 没有参数 没有返回值 没有名字的特殊方法{}3.用法：块需要调用才执行 我们自己调用不到（没有名字）每次我们调用构造方法之前系统就会调用一次程序块（让他执行一遍）4.特点：没有什么重载的概念 但可以在类中定义多个程序块5.可以在里面写一些程序 我想要在创建对象之前执行</code></pre><p>7.this关键字的使用</p><pre><code>1.是一个关键字  代替某一个对象 （当前调用属性或方法时的那个对象）2.this 既然指代一个对象  this 可以调用 属性 方法  this 可以调用构造方法  通过this();省略了构造方法的名字（必须与类名一致） 必须放在程序第一行  一般方法不能调用构造方法</code></pre><p>8.Scanner类</p><pre><code>              1.导包               java.util              2.创建对象         Scanner input = new Scanner(System.in);              3.做事情          int value = input.nextInt（）;                                String value = input.nextLine();            --------------------------------------------------------------------------             nextInt（nextFloat nextByte）next nextLine1.读取方式上  大家都以回车符作为结束符号          除了nextLine以外其余方法都不读取回车符2.读取的返回结果来讲    nextInt---&gt;int   nextFloat----float  nextLine---String  next--string            next 方法看到回车或空格都认为结束               输入  abc def  g              输出  abc             nextLine 只认回车是结束符              输入 abc def g              输出 abc def g</code></pre><p>8.利用包装类做string与基本类型的转化问题</p><pre><code>int value = Interger.parseInt(&quot;&quot;);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;面向对象的编程思想&quot;&gt;&lt;a href=&quot;#面向对象的编程思想&quot; class=&quot;headerlink&quot; title=&quot;面向对象的编程思想&quot;&gt;&lt;/a&gt;面向对象的编程思想&lt;/h3&gt;&lt;p&gt;类——–抽象的  属性（特征）和方法（行为）&lt;/p&gt;
&lt;p&gt;对象—–具体的&lt;/p&gt;

      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （八）</title>
    <link href="http://yoursite.com/2020/03/14/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%85%AB%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/14/JavaSE基础-（八）/</id>
    <published>2020-03-14T14:33:53.000Z</published>
    <updated>2020-03-14T15:20:08.371Z</updated>
    
    <content type="html"><![CDATA[<p>转义字符</p><pre><code>\转义字符 将身后的一个字符意思发生转换 转换特殊符号   比如 &quot; &apos; \ 转换几个特殊的字母 比如 \n换行  \r回车 \t制表符</code></pre><p>main方法</p><pre><code>public static void static (String[] args){}public 访问权限修饰符  公有的staric  特征修饰符  静态的 有且只有一份void   关键字   方法执行完没有返回值main()  方法名称  主要的主方法中的参数args参数  可否传递？1.主方法不是我们调用的 JVM虚拟机启动的时候 虚拟机调用的2.主方法里面有args参数 是一个String[]类型 我们可以传递参数进去给JVM</code></pre><p>命名规则和规约</p><p>规则</p><pre><code>字母 数字 符号 中文字母 区分大小写数字 不能开头符号 _$中文 不推荐</code></pre><p>规约</p><pre><code>类名字  首字母大写 两个单词以上 每一个首字母都大写      Test TestOne TestTwo 属性/方法/变量 驼峰式命名规约 首字母小写 两个单词以上 第二个以后的每个首字母大写构造方法  与类名一致 类中唯一的大写字母开头的方法静态常量  全部字母大写 通过 做具体说明 BOOKSTORE ADMIN包名    全部字母小写 java关键字都是小写 注意与关键字不要冲突</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转义字符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\转义字符 将身后的一个字符意思发生转换
 转换特殊符号   比如 &amp;quot; &amp;apos; \
 转换几个特殊的字母 比如 \n换行  \r回车 \t制表符&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;main方法&lt;/p&gt;
&lt;pre&gt;&lt;code
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础  （七）</title>
    <link href="http://yoursite.com/2020/03/13/avaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/13/avaSE基础-（七）/</id>
    <published>2020-03-13T14:12:24.000Z</published>
    <updated>2020-03-13T14:36:43.119Z</updated>
    
    <content type="html"><![CDATA[<p>多维数组</p><p>0.数组的特点</p><pre><code>数组本身是一个引用类型声明时必须指定长度  长度一旦确定就不能再次发生改变</code></pre><p> 1.定义/声明</p><pre><code>里面存储的类型[] 数组名字;int[][]  arry;</code></pre><p> 2.初始化</p><pre><code>静态---有长度 有元素  int[][] arry = {{1,2},{1}.{1.2.3}};动态---只有长度 没有元素（默认值）  int[][] arry = new int[3][2];  arry -----&gt;{{x,x},{x,x},{x,x}}  x默认值是0</code></pre><p> 3.元素访问          </p><pre><code>通过元素在数组中的位置----indexarray[i][j]i控制大数组中 小数组的位置j控制小数组中 元素的位置</code></pre><p> 4.遍历轮循          </p><pre><code>正常for 增强for  嵌套完成</code></pre><p> 5.引用类型在内存中的结构</p><pre><code>二维数组在内存中的存储，逻辑结构不是矩阵而是树int[][] arry = new int[3][2];//3表示有3个小数组int[]//2表示每一个小数组有两个元素//NullPointerException    空指针异常</code></pre><p>6.常见的运行时异常</p><pre><code>1.InputMisMatchException   输入类型不匹配      input.nextInt();      如：输入一个a2.ArrayIndexOutOfBoundsException  数组索引越界  静态初始化 int array[]={10,20};             array[2]  //索引超过边界3.NegativeArraySizeException  数组长度不合法（长度出现负数）  动态初始化 int[] array = new int [-2]4.NullPointerException    空指针异常    引用为null 还拿来使用就不行啦   int[] arry = null;   arry[0] = 10 ;//空元素再来用</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;多维数组&lt;/p&gt;
&lt;p&gt;0.数组的特点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;数组本身是一个引用类型
声明时必须指定长度  长度一旦确定就不能再次发生改变&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 1.定义/声明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;里面存储的类型[] 数组名字;
int[][] 
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （六）</title>
    <link href="http://yoursite.com/2020/03/12/JavaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/12/JavaSE基础-（六）/</id>
    <published>2020-03-12T14:13:00.000Z</published>
    <updated>2020-03-12T15:39:07.081Z</updated>
    
    <content type="html"><![CDATA[<p>数组（容器）</p><pre><code>数组是一组数据类型相同的数据的组合，将这些数据统一管理起来数组本身是一个引用数据类型，但数组内可以存储基本数据类型，也可以存储引用数据类型</code></pre><p>1.数组的定义（声明）  </p><pre><code>数据类型[] 数组名字;    int[] a;    char[] b;    boolean[] c;    string[] m;</code></pre><p>2.数组的（赋值）初始化 </p><pre><code>静态初始化    有长度 有元素    int[] arry = {10,20,30,40,50,60};    int[] arry = new int[] {10,20,30,40,50,60};动态初始化    有长度   没有元素（默认值0）    int[] arry = new int[5] ;    整数默认值-----0    浮点数默认值---0.0    字符型默认值----0--char  97-a 65-A 48-&apos;0&apos;    布尔型默认值----false    引用数据类型默认值----null</code></pre><p>3.数组元素的访问 </p><pre><code>通过元素在数组中的位置来访问存值/取值位置-------&gt;index索引索引是有取值范围    [从0开始------到数组长度减1]如果数组的索引超过了上诉范围会出现了一个运行时的异常ArrayIndexOutOfBoundsException</code></pre><p>4 数组元素的遍历<br>                  通过循环的方式访问数组每一个元素<br>                  for（;;）{</p><pre><code>}JDK1.5版本之后 增加新特性 增强for循环 加强for forEachfor（自定义的变量（接收数组内每一个元素）：遍历的数组arry）{}1.正常的for循环 有三个必要的条件 找到一个元素的位置可以通过index直接访问数组的某一个位置 存值 取值都可以不好在于写法相对比较麻烦2.增强for 有两个条件 用来取值的变量 用来遍历的数组 没有index索引 写法相对容易只能取值 不能存值没有index索引  找不到元素是哪一个</code></pre><p>5.基本数据类型和引用数据类型在内存结构上的区别<br>              所有的变量空间都存储在栈内存<br>              变量空间可以存储基本数据类型  也可以引用数据类型<br>              如果变量空间存储的是一个基本数据类型  存储的是值 一个变量改变 另一个不会改变<br>              如果变量空间存储的是引用数据类型 存储的是引用（地址）一个变量地址改变 另一个跟着改变</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数组（容器）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;数组是一组数据类型相同的数据的组合，将这些数据统一管理起来
数组本身是一个引用数据类型，但数组内可以存储基本数据类型，也可以存储引用数据类型&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;1.数组的定义（声明）  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础 （五）</title>
    <link href="http://yoursite.com/2020/03/11/avaSE%E5%9F%BA%E7%A1%80-%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/11/avaSE基础-（五）/</id>
    <published>2020-03-11T14:47:00.000Z</published>
    <updated>2020-03-12T15:46:00.760Z</updated>
    
    <content type="html"><![CDATA[<p>java运算符</p><p>   运算符：用来指明操作数的运算方式</p><p>   按照操作数的数目来分类</p><pre><code>单目运算符    a++双目运算符    a+b三目运算符    (a&gt;b)? x : y</code></pre><p>   按运算符的功能来分类</p><pre><code>算数运算符   + - * / %（取余 求模）++（自增） --（自减）int x=1；int y=x++；//++在后 先赋值 再自增（先进行计算 后赋值）     x++//x=x+1//将x变量空间的内容 先取出 从常量区取出1 进行计算 再次存到x中     想要做值交换的时候 会产生一个临时的副本空间（备份）     ++在变量的前面 先自增后备份 ++在变量的后面 先备份后自增 并将副本空间（备份）内的值赋给别人     x=2 y=1例：int a = 1;   for(int i=0;1&lt;100;i++){        a=a++;   }   a=1   //因为赋值的永远是备份空间的1   --------------------------------------------------------------   int m = 1；//210   int n = 2；//321   int sum = m++ + ++n - n-- - --m + n-- - --m；   m=0 n= 1 sum=2   ----------------------------------------------------------------   赋值运算符   = 赋值符号   将=右边的值()   关系运算符（比较）   &gt; &lt; &gt;= &lt;= != ==   逻辑运算符   &amp; | ^ ！ &amp;&amp;短路与 ||   // ^逻辑异或 只要两个表达式结果不同 最终结果就是true   位（bit）运算   &amp;按位与 |按位或 ^按位异或 ~ 按位取反&lt;&lt;按位左移位 &gt;&gt;按位右移位 &gt;&gt;&gt;按位右移（无符号）</code></pre><p> 笔试题</p><p> 1.&amp;和&amp;&amp;的区别</p><pre><code>&amp;可以视为逻辑运算 也可以视为位运算 &amp;&amp;只能当做逻辑运算来用如果两个都当做逻辑运算符来用 区别如下&amp;前后两个条件都是true 最终结果就是true&amp;&amp; 短路与正常情况下&amp;的执行结果一致   当前面条件为flase的时候发生短路最终结果flase</code></pre><p>2.最有效率的方式计算2*8的结果</p><pre><code>   00000001                  2 &lt;&lt; 3相当于2乘以2的3次幂*  00001000                  00000010-------------                00010000 == 1600000010000==16</code></pre><p>3.两个变量 int a = 1； b = 2如果将两个变量的值互换</p><pre><code> int a = 1; int b = 2; 方式一 采用一个中间变量 int c = a;     a = b;      b =c;好处容易理解 值不会出问题 不好在于会产生一个新的存储空间方式二a = a+b;b = a-b;a = a-b;好处省略了一个存储空间，不好在于+值可能产生越界方法三a = a^b;b = a^b;a = a^b;学的就是高难度~</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java运算符&lt;/p&gt;
&lt;p&gt;   运算符：用来指明操作数的运算方式&lt;/p&gt;
&lt;p&gt;   按照操作数的数目来分类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;单目运算符    a++
双目运算符    a+b
三目运算符    (a&amp;gt;b)? x : y&lt;/code&gt;&lt;/pre&gt;&lt;p
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>GIT (一)</title>
    <link href="http://yoursite.com/2020/03/10/GIT%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/10/GIT（一）/</id>
    <published>2020-03-10T11:12:00.000Z</published>
    <updated>2020-03-10T11:48:12.764Z</updated>
    
    <content type="html"><![CDATA[<p>GIt Bash 常用命令</p><p>#change director</p><pre><code>cd</code></pre><p>#make director</p><pre><code>mkdir</code></pre><p>#print working directory </p><pre><code>pwd</code></pre><p>#move </p><pre><code>mv</code></pre><p>#copy                     </p><pre><code>cp</code></pre><p>#remove</p><pre><code>rm</code></pre><p>其他  </p><pre><code>echo 打印echo &apos;hello&apos; 在命令行中打印一个 helloecho &apos;hello&apos; &gt; a.txt 创建一个纯文本文件a把hello打印进去cat a.txt 查看a中的内容cp a.txt b.txt 复制a 到bls 目录ls ..上一级目录mv b.txt ../b.txt 把b移动到上一级文件夹mv a.txt c.txt 重命名rm c.txt  删除c</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;GIt Bash 常用命令&lt;/p&gt;
&lt;p&gt;#change director&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;#make director&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;#print working 
      
    
    </summary>
    
      <category term="GIT" scheme="http://yoursite.com/categories/GIT/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE基础（四）</title>
    <link href="http://yoursite.com/2020/03/09/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/09/JavaSE基础（四）/</id>
    <published>2020-03-09T15:33:00.000Z</published>
    <updated>2020-03-10T11:04:44.665Z</updated>
    
    <content type="html"><![CDATA[<p>内存结构与执行过程</p><p>1.在硬盘上创建一个文件                            Test.java</p><p>2.文件的内容是我们编写的源代码（跟计算机发送的指令）</p><pre><code>public  class Test{         static void main( String[] args ){              byte x;              x=1;        }  }</code></pre><p>3.将Test.java源文件——&gt;编译——&gt;Test.classc</p><p>4.执行——–&gt;内存中执行</p><p><img src="/2020/03/09/JavaSE基础（四）/pasted-0.png" alt="upload successful"><br>常量值</p><pre><code>常量值是在常量缓存区中的常量区只存一份   常量存储的形式不是十进制而是二进制在常量池中整数默认是按照 int型存储如果使用长整型时需要末尾加L告知long d = 2147483648L;浮点型默认为64位double.</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;内存结构与执行过程&lt;/p&gt;
&lt;p&gt;1.在硬盘上创建一个文件                            Test.java&lt;/p&gt;
&lt;p&gt;2.文件的内容是我们编写的源代码（跟计算机发送的指令）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public  class Test{

      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE基础（三）</title>
    <link href="http://yoursite.com/2020/03/08/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/08/JavaSE基础（三）/</id>
    <published>2020-03-08T15:54:16.000Z</published>
    <updated>2020-03-10T11:06:40.491Z</updated>
    
    <content type="html"><![CDATA[<p>常量</p><pre><code>常量是代表在程序运行过程中，不能再改变的值。</code></pre><p>常量的作用     </p><pre><code>1.固定的值  代表在计算过程中经常用到的值便于程序计算。    如：  圆周率  3.14159262.表示一个含义    如：  up==&gt;1 down==&gt;2</code></pre><p>什么样的值算是常量</p><pre><code>1. 可以认为所有基本类型的值固定不变是常量    如：    3.14   &apos;a&apos;  true2.特殊的常量     如：   “a b c”-----&gt;string        string是一个引用数据类型，它的值很特殊，可以简单视为常量3.自己创建的空间存储一个值让他固定不变    如：   final int up = 1；</code></pre><p>变量</p><pre><code>变量是指程序执行过程中可以改变的量；变量是内存空间（小容器）；变量空间在创建（声明）的时候必须指定数据类型变量空间的名字；变量空间里面只能存储一个内容（值 引用）变量空间的内容可以改变；</code></pre><p>变量如何创建/声明</p><pre><code>数据类型   类型名字；int a；string b；</code></pre><p>创建变量需要注意命名的问题</p><pre><code>命名规则： 字母、数字（不允许作为开头）、符号（英文符号_和$）还有中文（不推荐）命名的规约：              类名字：  首字母大写 如果两个以上单词  所有首字母都大写                     如：SuperPerson            变量名：  首字母小写 如果两个以上单词之后首字母大写                     如： superPerson                     遵循驼峰式命名规约            所有名字需要见名知意，为了增强程序可读性！注意：变量是空间可以只创建东西不存放内容      变量空间创建后是无内容的、空的      空的变量空间是不能拿来使用的</code></pre><p>注释</p><pre><code>1.单行注释     //2.多行注释     /*         */3.文档注释     //*        */</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;常量是代表在程序运行过程中，不能再改变的值。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;常量的作用     &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.固定的值  代表在计算过程中经常用到的值便于程序计算。
    如：  圆周率  3.1415926
2.
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
</feed>
